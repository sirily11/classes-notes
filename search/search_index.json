{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"List of notes \u00b6","title":"List of notes"},{"location":"#list-of-notes","text":"","title":"List of notes"},{"location":"MSBD5001/Lecture%202/","text":"Supervised learning \u00b6 Supervised larning Unsupervised learning Reinforcement learning Whats is machine learning \u00b6 A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks. Linear Regression \u00b6 A Part of machine learning Given training set x, y Find a good approximation to f: \\(x \\to y\\) Examples: Spam detection ( Classification) Digit recognition ( Classification) House price prediction (Refression) Terminology \u00b6 Given a data point (x, y), x is called featyre vector, y is called label The dataset given for learning is training data The dataset to be tested is called testing data Machine learning 3 steps \u00b6 Collect data, extract features Determine a model Train the model with the data Loss \u00b6 Loss on traning set We measure the error using a loss function \\(L(y, \\hat{y})\\) For regression, squared error is often used \\( \\(L(y_1, f(x_i)) = (y_i - f(x_i))^2\\) \\) Loss on testing set Empirical loss is measuring the loss on the training set We assume both training set and testing set are i.i.d from the same distribution D - Minimizing loss on training set will make loss on testing set small Minimizing loss functions \u00b6 The minimizers of some loss functions have analytical solutions: an exact solution you can explicitly derive by analyzing the formula. However, most poular supervised learning models use loss functions with no analytical solution We use gradient descent to approximate the minimal value of function. Gradients: A vector, points to the direction where changing value is the fastest. Method \u00b6 For function G, randomly guess an initial value \\(x_0\\) Repeat \\(xi+1 = x_i - r \\times \\nabla G(x)\\) where \\(\\nabla\\) denotes the gradients, r denotes learning rate Until convergence from sympy import symbols , diff r = 0.1 f_i = ( 1 , 1 , 1 ) x , y , z = symbols ( 'x y z' , real = True ) f = ( y + 2 * x ) ** 2 + y + 2 * x g = ( diff ( f , x ), diff ( f , y ), diff ( f , z )) G (8*x + 4*y + 2, 4*x + 2*y + 1, 0) import numpy as np result = np . array ([ 8 , 6 , 3 ]) * r + np . array ([ 1 , 1 , 1 ]) result array([1.8, 1.6, 1.3]) Linear Classification \u00b6 Use a line to separate data points Use \\(x = (x_1, x_2)\\) , \\(w = (w_1, w_2)\\) , i.e., x, w are vectors in 2D space Doesn't work well with classification problem Label y as either 1 or -1 Find f_w(x) = w^Tx that minimizes the loss function \\( \\(L(f_w(x)) = \\frac{1}{n}\\sum_{i=1}^n(w^Tx_i-y_1)^2\\) \\) Find a line that minimizes the distance between red and blue If there is a outlier in the graph, the seperation line will miss classification some points - If the value get very large, the \\(w^TX_i\\) is correct \\(\\to\\) large loss value even if predict value is positive. \u00b6 Solution: We use sigmoid function to minimize the value between 0 and 1 \\( \\(\\sigma(a) = \\frac{1}{1+exp(-a)}\\) \\) Similar to step functions Continuous and easy to compute Some properties of sigmoid function \u00b6 \\(\\sigma(a) = \\frac{1}{1+exp(-a)} \\in (0, 1)\\) symetric Easy to compute gradients Logistic Regression \u00b6 Better approach ( cross-entropy loss function) find w that minimizes loss function If misclassfication happens on i-th data with label 1, \\(log(\\sigma(w^Tx_i))\\) is very large No analytical solution, needs gradient descent SVM \u00b6 A svm performs classification by finding the hyperplane that maximizes the margin between the two classes K-Nearest neighbor methods \u00b6 Learning algorithm: just store training examples Prediction algorithm: Regression: take the average value of k nearest neighbors Classification: assign to the most frequent class of k nearest neighbors Easy to train with high storage requirement, but high-computation cost at prediction --- Linear knn Advantages Easy to fit Strong assumtions on linear relationship Disadvantages Hard to classify the data Takes a lot of computation power Decision Tree \u00b6 Entropy is used to measure how informative is a probability distribution. The more entropy, the more uncertainty. More info Wrap up \u00b6 Collect data, extract features Determine a model Select a good model for your data","title":"Lecture 2"},{"location":"MSBD5001/Lecture%202/#supervised-learning","text":"Supervised larning Unsupervised learning Reinforcement learning","title":"Supervised learning"},{"location":"MSBD5001/Lecture%202/#whats-is-machine-learning","text":"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks.","title":"Whats is machine learning"},{"location":"MSBD5001/Lecture%202/#linear-regression","text":"A Part of machine learning Given training set x, y Find a good approximation to f: \\(x \\to y\\) Examples: Spam detection ( Classification) Digit recognition ( Classification) House price prediction (Refression)","title":"Linear Regression"},{"location":"MSBD5001/Lecture%202/#terminology","text":"Given a data point (x, y), x is called featyre vector, y is called label The dataset given for learning is training data The dataset to be tested is called testing data","title":"Terminology"},{"location":"MSBD5001/Lecture%202/#machine-learning-3-steps","text":"Collect data, extract features Determine a model Train the model with the data","title":"Machine learning 3 steps"},{"location":"MSBD5001/Lecture%202/#loss","text":"Loss on traning set We measure the error using a loss function \\(L(y, \\hat{y})\\) For regression, squared error is often used \\( \\(L(y_1, f(x_i)) = (y_i - f(x_i))^2\\) \\) Loss on testing set Empirical loss is measuring the loss on the training set We assume both training set and testing set are i.i.d from the same distribution D - Minimizing loss on training set will make loss on testing set small","title":"Loss"},{"location":"MSBD5001/Lecture%202/#minimizing-loss-functions","text":"The minimizers of some loss functions have analytical solutions: an exact solution you can explicitly derive by analyzing the formula. However, most poular supervised learning models use loss functions with no analytical solution We use gradient descent to approximate the minimal value of function. Gradients: A vector, points to the direction where changing value is the fastest.","title":"Minimizing loss functions"},{"location":"MSBD5001/Lecture%202/#method","text":"For function G, randomly guess an initial value \\(x_0\\) Repeat \\(xi+1 = x_i - r \\times \\nabla G(x)\\) where \\(\\nabla\\) denotes the gradients, r denotes learning rate Until convergence from sympy import symbols , diff r = 0.1 f_i = ( 1 , 1 , 1 ) x , y , z = symbols ( 'x y z' , real = True ) f = ( y + 2 * x ) ** 2 + y + 2 * x g = ( diff ( f , x ), diff ( f , y ), diff ( f , z )) G (8*x + 4*y + 2, 4*x + 2*y + 1, 0) import numpy as np result = np . array ([ 8 , 6 , 3 ]) * r + np . array ([ 1 , 1 , 1 ]) result array([1.8, 1.6, 1.3])","title":"Method"},{"location":"MSBD5001/Lecture%202/#linear-classification","text":"Use a line to separate data points Use \\(x = (x_1, x_2)\\) , \\(w = (w_1, w_2)\\) , i.e., x, w are vectors in 2D space Doesn't work well with classification problem Label y as either 1 or -1 Find f_w(x) = w^Tx that minimizes the loss function \\( \\(L(f_w(x)) = \\frac{1}{n}\\sum_{i=1}^n(w^Tx_i-y_1)^2\\) \\) Find a line that minimizes the distance between red and blue If there is a outlier in the graph, the seperation line will miss classification some points","title":"Linear Classification"},{"location":"MSBD5001/Lecture%202/#-if-the-value-get-very-large-the-wtx_i-is-correct-to-large-loss-value-even-if-predict-value-is-positive","text":"Solution: We use sigmoid function to minimize the value between 0 and 1 \\( \\(\\sigma(a) = \\frac{1}{1+exp(-a)}\\) \\) Similar to step functions Continuous and easy to compute","title":"- If the value get very large, the \\(w^TX_i\\) is correct \\(\\to\\) large loss value even if predict value is positive."},{"location":"MSBD5001/Lecture%202/#some-properties-of-sigmoid-function","text":"\\(\\sigma(a) = \\frac{1}{1+exp(-a)} \\in (0, 1)\\) symetric Easy to compute gradients","title":"Some properties of sigmoid function"},{"location":"MSBD5001/Lecture%202/#logistic-regression","text":"Better approach ( cross-entropy loss function) find w that minimizes loss function If misclassfication happens on i-th data with label 1, \\(log(\\sigma(w^Tx_i))\\) is very large No analytical solution, needs gradient descent","title":"Logistic Regression"},{"location":"MSBD5001/Lecture%202/#svm","text":"A svm performs classification by finding the hyperplane that maximizes the margin between the two classes","title":"SVM"},{"location":"MSBD5001/Lecture%202/#k-nearest-neighbor-methods","text":"Learning algorithm: just store training examples Prediction algorithm: Regression: take the average value of k nearest neighbors Classification: assign to the most frequent class of k nearest neighbors Easy to train with high storage requirement, but high-computation cost at prediction --- Linear knn Advantages Easy to fit Strong assumtions on linear relationship Disadvantages Hard to classify the data Takes a lot of computation power","title":"K-Nearest neighbor methods"},{"location":"MSBD5001/Lecture%202/#decision-tree","text":"Entropy is used to measure how informative is a probability distribution. The more entropy, the more uncertainty. More info","title":"Decision Tree"},{"location":"MSBD5001/Lecture%202/#wrap-up","text":"Collect data, extract features Determine a model Select a good model for your data","title":"Wrap up"},{"location":"MSBD5001/Lecture%203/","text":"Overfitting and underfitting \u00b6 Overfitting \u00b6 Even when training data and testing data are i.i.d, generalization may also fail. Is a modeling error which occurs when a function is too closely fit to a limited set of data points. Why is overfitting a problem \u00b6 Overfitting leads to low training error yet high testing error. Out goal is to make the testing error small, Not the training error. Plotting a polynomial \u00b6 Using a polynomial of degree N to fit \\(y==\\sum^N_{i=1}w_ix_i\\) Higher degree has more complex curve to fit the data. https://github.com/MSBD-5001/Lecture-Materials/blob/master/l3_simulation_lecture.ipynb Underfitting \u00b6 Occurs when the model or algorithm doesn't fit the the data well enough. Example \u00b6 import numpy as np import matplotlib.pyplot as plt import pandas as pd import statsmodels.api as sm from statsmodels import regression from scipy i0mport poly1d /usr/local/lib/python3.6/dist-packages/statsmodels/tools/_testing.py:19: FutureWarning: pandas.util.testing is deprecated. Use the functions in the public API at pandas.testing instead. import pandas.util.testing as tm x = np . arange ( 10 ) y = 2 * np . random . randn ( 10 ) + x ** 2 xs = np . linspace ( - 0 . 25 , 9 . 25 , 200 ) lin = np . polyfit ( x , y , 1 ) quad = np . polyfit ( x , y , 2 ) many = np . polyfit ( x , y , 9 ) plt . scatter ( x , y ) plt . plot ( xs , poly1d ( lin )( xs )) plt . plot ( xs , poly1d ( quad )( xs )) plt . plot ( xs , poly1d ( many )( xs )) plt . ylabel ( 'Y' ) plt . xlabel ( 'X' ) plt . legend ([ 'Underfit' , 'Good fit' , 'Overfit' ]); Errors: Bias and variance \u00b6 Expect error = \\(Bias^2\\) + Variance + Noise Bias: Difference between the average prediction of our model and the correct value which we are trying to predict Variance: The variability of model prediction for a fiven data point. Our goal is to select models that are of optimal complexity. Complex models have low bias and high variance: - Low bias: Complicated models capture a lot of features - High variance: testing set many not have the same feature - Overfitting Simeple models have low variance and high bias. - Underfitting How to reduce variance and keep bias at a low value? \u00b6 Larger training dataset reduces variance Noise is unavoidable on the data Regularization and ensemble learning Selecting good models \u00b6 Validation \u00b6 Split training data into training and validation data Validation data are only used to evaluate the performance of trained model. If model generalize well on validation data, then should also generalize well on testing data. Wasting part of original training data. Cross validation \u00b6 Will make all training data for validation Partition training data into serveral groups repeat: One group as validation set, train new model Performance metric: average error on validation data. k-fold cross validation \u00b6 Equally split data into k folds Each time uses one fold as validation K fold can be used for large dataset Leave-one-out can be used when dataset is small. Use only 1 sample for validation, the rest for training. Select models with cross-validation. Use cross validation to evaluate performance of different models. Select the best model. Improving the models \u00b6 Method Train sequentially or in parallel How to generate different models Reduces bias or variance Bagging Parallel Boostrap data Variance Random Forest Parallel Bootsrap + random subset of features at splitting Variance Boosting Sequential Reweight training data Bias and variance Regularization \u00b6 Prevent overfitting by reducing flexibility of the model. Prevent parameters having too large absolute values. - Reduce variance - Prevent overfitting Ensemeble \u00b6 Standard decision trees can achieve low bias. - Training set error can be zero. You can always train to the last branch - Large variance Early stopping with fixed nodes or fixed depth may incur high bias Averaging \u00b6 For regression: Simply average the results predicted by different trees, can take weighted average For classification: just select the most predicted value. Also called voting Baging \u00b6 Short for Boostrap aggregating. Bootstrap samples B times, each with size N, with replacement. Train B classifiers each with a bootstrap sample. Bagging gets similar bias: data are from resampling. Random Forest \u00b6 Refinement of the bagged trees. Problem: We want the trees to be independent, don't want them to be similar. But bootstrapping data doesn't help that much: still drawn from same dataset with all features. At each tree split, a random sample of m features are drawn. Only these m features are consldered for splitting. Typically, m is \\(\\sqrt{p}\\) pr \\(p/3\\) where p is the total number of features. Boosting \u00b6 Random forest and bagging: trees are trained in parallel Boosting: trees should be trained sequentially - Start with original training sample - In each iteration: - Train a classifier and check wich samples are hard to train - Increase the weight of those mis-classified samples in training data - Repeat this - Final classifier: weighted classifier model.","title":"Lecture 3"},{"location":"MSBD5001/Lecture%203/#overfitting-and-underfitting","text":"","title":"Overfitting and underfitting"},{"location":"MSBD5001/Lecture%203/#overfitting","text":"Even when training data and testing data are i.i.d, generalization may also fail. Is a modeling error which occurs when a function is too closely fit to a limited set of data points.","title":"Overfitting"},{"location":"MSBD5001/Lecture%203/#why-is-overfitting-a-problem","text":"Overfitting leads to low training error yet high testing error. Out goal is to make the testing error small, Not the training error.","title":"Why is overfitting a problem"},{"location":"MSBD5001/Lecture%203/#plotting-a-polynomial","text":"Using a polynomial of degree N to fit \\(y==\\sum^N_{i=1}w_ix_i\\) Higher degree has more complex curve to fit the data. https://github.com/MSBD-5001/Lecture-Materials/blob/master/l3_simulation_lecture.ipynb","title":"Plotting a polynomial"},{"location":"MSBD5001/Lecture%203/#underfitting","text":"Occurs when the model or algorithm doesn't fit the the data well enough.","title":"Underfitting"},{"location":"MSBD5001/Lecture%203/#example","text":"import numpy as np import matplotlib.pyplot as plt import pandas as pd import statsmodels.api as sm from statsmodels import regression from scipy i0mport poly1d /usr/local/lib/python3.6/dist-packages/statsmodels/tools/_testing.py:19: FutureWarning: pandas.util.testing is deprecated. Use the functions in the public API at pandas.testing instead. import pandas.util.testing as tm x = np . arange ( 10 ) y = 2 * np . random . randn ( 10 ) + x ** 2 xs = np . linspace ( - 0 . 25 , 9 . 25 , 200 ) lin = np . polyfit ( x , y , 1 ) quad = np . polyfit ( x , y , 2 ) many = np . polyfit ( x , y , 9 ) plt . scatter ( x , y ) plt . plot ( xs , poly1d ( lin )( xs )) plt . plot ( xs , poly1d ( quad )( xs )) plt . plot ( xs , poly1d ( many )( xs )) plt . ylabel ( 'Y' ) plt . xlabel ( 'X' ) plt . legend ([ 'Underfit' , 'Good fit' , 'Overfit' ]);","title":"Example"},{"location":"MSBD5001/Lecture%203/#errors-bias-and-variance","text":"Expect error = \\(Bias^2\\) + Variance + Noise Bias: Difference between the average prediction of our model and the correct value which we are trying to predict Variance: The variability of model prediction for a fiven data point. Our goal is to select models that are of optimal complexity. Complex models have low bias and high variance: - Low bias: Complicated models capture a lot of features - High variance: testing set many not have the same feature - Overfitting Simeple models have low variance and high bias. - Underfitting","title":"Errors: Bias and variance"},{"location":"MSBD5001/Lecture%203/#how-to-reduce-variance-and-keep-bias-at-a-low-value","text":"Larger training dataset reduces variance Noise is unavoidable on the data Regularization and ensemble learning","title":"How to reduce variance and keep bias at a low value?"},{"location":"MSBD5001/Lecture%203/#selecting-good-models","text":"","title":"Selecting good models"},{"location":"MSBD5001/Lecture%203/#validation","text":"Split training data into training and validation data Validation data are only used to evaluate the performance of trained model. If model generalize well on validation data, then should also generalize well on testing data. Wasting part of original training data.","title":"Validation"},{"location":"MSBD5001/Lecture%203/#cross-validation","text":"Will make all training data for validation Partition training data into serveral groups repeat: One group as validation set, train new model Performance metric: average error on validation data.","title":"Cross validation"},{"location":"MSBD5001/Lecture%203/#k-fold-cross-validation","text":"Equally split data into k folds Each time uses one fold as validation K fold can be used for large dataset Leave-one-out can be used when dataset is small. Use only 1 sample for validation, the rest for training. Select models with cross-validation. Use cross validation to evaluate performance of different models. Select the best model.","title":"k-fold cross validation"},{"location":"MSBD5001/Lecture%203/#improving-the-models","text":"Method Train sequentially or in parallel How to generate different models Reduces bias or variance Bagging Parallel Boostrap data Variance Random Forest Parallel Bootsrap + random subset of features at splitting Variance Boosting Sequential Reweight training data Bias and variance","title":"Improving the models"},{"location":"MSBD5001/Lecture%203/#regularization","text":"Prevent overfitting by reducing flexibility of the model. Prevent parameters having too large absolute values. - Reduce variance - Prevent overfitting","title":"Regularization"},{"location":"MSBD5001/Lecture%203/#ensemeble","text":"Standard decision trees can achieve low bias. - Training set error can be zero. You can always train to the last branch - Large variance Early stopping with fixed nodes or fixed depth may incur high bias","title":"Ensemeble"},{"location":"MSBD5001/Lecture%203/#averaging","text":"For regression: Simply average the results predicted by different trees, can take weighted average For classification: just select the most predicted value. Also called voting","title":"Averaging"},{"location":"MSBD5001/Lecture%203/#baging","text":"Short for Boostrap aggregating. Bootstrap samples B times, each with size N, with replacement. Train B classifiers each with a bootstrap sample. Bagging gets similar bias: data are from resampling.","title":"Baging"},{"location":"MSBD5001/Lecture%203/#random-forest","text":"Refinement of the bagged trees. Problem: We want the trees to be independent, don't want them to be similar. But bootstrapping data doesn't help that much: still drawn from same dataset with all features. At each tree split, a random sample of m features are drawn. Only these m features are consldered for splitting. Typically, m is \\(\\sqrt{p}\\) pr \\(p/3\\) where p is the total number of features.","title":"Random Forest"},{"location":"MSBD5001/Lecture%203/#boosting","text":"Random forest and bagging: trees are trained in parallel Boosting: trees should be trained sequentially - Start with original training sample - In each iteration: - Train a classifier and check wich samples are hard to train - Increase the weight of those mis-classified samples in training data - Repeat this - Final classifier: weighted classifier model.","title":"Boosting"},{"location":"MSBD5001/Lecture%209/","text":"Big Data integration: Record linkage \u00b6 Record linkage: blocking + pairwise matching + clustering - Scalability, similarity, semantics Blocking: e\u000eciently create small blocks of similar records - Ensures scalability Pairwise matching: compares all record pairs in a block - Computes similarity Clustering: groups sets of records into entities - Ensures semantics Volume : dealing with billions of records - Map-reduce based record linkage - Blocking Velocity Incremental record linkage Variety Matching structured and unstructured data Matching Web tables and catalogs Veracity Linking temporal records Data Fusion \u00b6 Data fusion: voting + source quality + copy detection - Resolves inconsistency across diversity of sources - Support di erence of opinion Data fusion: voting + source quality + copy detection - Gives more weight to knowledgeable sources - Reduces weight of copier sources Rule-based \u00b6 Using the observed value from the most recently updated source Taking the average, maximum, or minimum for numerical values Majority voting Naive voting \u00b6 Supports dierence of opinion, allows conflict resolution Works well for independent sources that have similar accuracy When sources have di erent accuracies - Need to give more weight to votes by knowledgeable sources When sources copy from other sources - Need to reduce the weight of votes by copiers Problem: the wisdom of minority fkccecia, Truth Discovery \u00b6 A important feature of turth discover is to estimate source reliabilities. To identify the trustworthy information, i.e. truths: - weighted aggregation of data based on the estimated source reliabilities Both source reliabilities and truths are unknown. - If a source provide trustworthy information frequently, it will be assigned a higher reliability. - If a piece of information is supported by soruces with high reliabilities, it will have a larger change to be selected as the truth. Iteratively until converges: - Truth computation step - Source weight estimation step Truth computation: - The truth is inferred through weighted voting. Optimization-based Methods Easier to understand and interpret - Iteration methods Prior knowledge - Optimization-based: can be formulated as extra constraints - Probabilistic graphical model: can be captured by the hyper parameters Techniques for big data \u00b6 Veracity - Using source trustworthiness - Combining source accuracy and copy detection - Multiple truth values - Erroneous numeric data - Experimental comparison on deep web data Volume: Online data fusion Velocity Truth discovery for dynamic data Variety Combining record linkage with data fusion fkccecia,","title":"Lecture 9"},{"location":"MSBD5001/Lecture%209/#big-data-integration-record-linkage","text":"Record linkage: blocking + pairwise matching + clustering - Scalability, similarity, semantics Blocking: e\u000eciently create small blocks of similar records - Ensures scalability Pairwise matching: compares all record pairs in a block - Computes similarity Clustering: groups sets of records into entities - Ensures semantics Volume : dealing with billions of records - Map-reduce based record linkage - Blocking Velocity Incremental record linkage Variety Matching structured and unstructured data Matching Web tables and catalogs Veracity Linking temporal records","title":"Big Data integration: Record linkage"},{"location":"MSBD5001/Lecture%209/#data-fusion","text":"Data fusion: voting + source quality + copy detection - Resolves inconsistency across diversity of sources - Support di erence of opinion Data fusion: voting + source quality + copy detection - Gives more weight to knowledgeable sources - Reduces weight of copier sources","title":"Data Fusion"},{"location":"MSBD5001/Lecture%209/#rule-based","text":"Using the observed value from the most recently updated source Taking the average, maximum, or minimum for numerical values Majority voting","title":"Rule-based"},{"location":"MSBD5001/Lecture%209/#naive-voting","text":"Supports dierence of opinion, allows conflict resolution Works well for independent sources that have similar accuracy When sources have di erent accuracies - Need to give more weight to votes by knowledgeable sources When sources copy from other sources - Need to reduce the weight of votes by copiers Problem: the wisdom of minority fkccecia,","title":"Naive voting"},{"location":"MSBD5001/Lecture%209/#truth-discovery","text":"A important feature of turth discover is to estimate source reliabilities. To identify the trustworthy information, i.e. truths: - weighted aggregation of data based on the estimated source reliabilities Both source reliabilities and truths are unknown. - If a source provide trustworthy information frequently, it will be assigned a higher reliability. - If a piece of information is supported by soruces with high reliabilities, it will have a larger change to be selected as the truth. Iteratively until converges: - Truth computation step - Source weight estimation step Truth computation: - The truth is inferred through weighted voting. Optimization-based Methods Easier to understand and interpret - Iteration methods Prior knowledge - Optimization-based: can be formulated as extra constraints - Probabilistic graphical model: can be captured by the hyper parameters","title":"Truth Discovery"},{"location":"MSBD5001/Lecture%209/#techniques-for-big-data","text":"Veracity - Using source trustworthiness - Combining source accuracy and copy detection - Multiple truth values - Erroneous numeric data - Experimental comparison on deep web data Volume: Online data fusion Velocity Truth discovery for dynamic data Variety Combining record linkage with data fusion fkccecia,","title":"Techniques for big data"},{"location":"MSBD5001/Lecture1/","text":"Lecture 1 \u00b6 Classification - Data to classes Regression - Predicting a numeric value Clustering Different types of problems \u00b6 Classification Problem - MNIST Dataset Regression - Predicting stock value Clustering Automatically identify the data Data integration \u00b6 Data are created independently A higher-level abstraction Statical analysis \u00b6 Collecting data \u00b6 Collecting, exploring and presenting large amounts of data to discover underlying patterns and trends Data come in two types: - Discrete - Continuous We have - barchart - piechart, Stem-and-leaf plot - Scatterplot ( it uses caresian coordinates to display values for two variables for set of data) - Form - Direction Numerical descriptive measures of data (Central tendency) - Mean - Min - Max - Median - Mode A sampling method is a procudure for selecting sample elements from a population. Relationship between variables: \u00b6 Eyeball fit: Fit two points on the plot so that the line passing through them fives a fairly good fit. Least square fit: Fit a line \\(y = a + bX\\) such that it minimaizes the error S Correlation coefficient, denoted as r, measures the degree to which two variables movements are associated. r = 1 means perfect positive relationship r = 1 means a perfect negative relationship r = 0 means no relationship Forecasting \u00b6 An experiment is an action where the result is uncertain A sample space is all the possible outomes of an experiment, denoted as \\(S\\) . A event is a subset of S Probability : is the measure of how likely an event is to occur out of the number of possible outcomes. $p = \\frac{The\\ number\\ of outcomes}{sample space} $ Parameters \u00b6 Sample can be generated by a probability model, where parameters are characteristics of the model Variance \u00b6 Variance is another parameter of probability model It is a measure of how spread out it is Statical analysis \u00b6 Collecting, exploring and presenting large amounts of data to discover underlying patterns and","title":"Lecture1"},{"location":"MSBD5001/Lecture1/#lecture-1","text":"Classification - Data to classes Regression - Predicting a numeric value Clustering","title":"Lecture 1"},{"location":"MSBD5001/Lecture1/#different-types-of-problems","text":"Classification Problem - MNIST Dataset Regression - Predicting stock value Clustering Automatically identify the data","title":"Different types of problems"},{"location":"MSBD5001/Lecture1/#data-integration","text":"Data are created independently A higher-level abstraction","title":"Data integration"},{"location":"MSBD5001/Lecture1/#statical-analysis","text":"","title":"Statical analysis"},{"location":"MSBD5001/Lecture1/#collecting-data","text":"Collecting, exploring and presenting large amounts of data to discover underlying patterns and trends Data come in two types: - Discrete - Continuous We have - barchart - piechart, Stem-and-leaf plot - Scatterplot ( it uses caresian coordinates to display values for two variables for set of data) - Form - Direction Numerical descriptive measures of data (Central tendency) - Mean - Min - Max - Median - Mode A sampling method is a procudure for selecting sample elements from a population.","title":"Collecting data"},{"location":"MSBD5001/Lecture1/#relationship-between-variables","text":"Eyeball fit: Fit two points on the plot so that the line passing through them fives a fairly good fit. Least square fit: Fit a line \\(y = a + bX\\) such that it minimaizes the error S Correlation coefficient, denoted as r, measures the degree to which two variables movements are associated. r = 1 means perfect positive relationship r = 1 means a perfect negative relationship r = 0 means no relationship","title":"Relationship between variables:"},{"location":"MSBD5001/Lecture1/#forecasting","text":"An experiment is an action where the result is uncertain A sample space is all the possible outomes of an experiment, denoted as \\(S\\) . A event is a subset of S Probability : is the measure of how likely an event is to occur out of the number of possible outcomes. $p = \\frac{The\\ number\\ of outcomes}{sample space} $","title":"Forecasting"},{"location":"MSBD5001/Lecture1/#parameters","text":"Sample can be generated by a probability model, where parameters are characteristics of the model","title":"Parameters"},{"location":"MSBD5001/Lecture1/#variance","text":"Variance is another parameter of probability model It is a measure of how spread out it is","title":"Variance"},{"location":"MSBD5001/Lecture1/#statical-analysis_1","text":"Collecting, exploring and presenting large amounts of data to discover underlying patterns and","title":"Statical analysis"},{"location":"MSBD5001/Lecture4/","text":"Unsupervised learning \u00b6 Another important class of machine learning methods Analyze the structure of the data using feature X Supervised: Use features X to predict labels Y Unsupervised: Only requires features, don\u2019t deal with labels Examples: - Clustering: divide a dataset into meaningful groups. Data points in the same group are more similar with each other, compared to those in different groups. Dimensionality Reduction: | have a dataset of extremely high dimension of features (e.g., images), can | represent them with a lower dimension? Ranking: | have a dataset represented as a graph, each data point is a node, and their relationship are edges, e.g., the World Wide Web, can | rank the importance of the data points? Clustering \u00b6 Clustering: the process of grouping a set of objects into classes of similar objects Objects within the same cluster should be more similar. Objects across the different clusters should be less similar. K-means clustering method \u00b6 Given k, the k-means algorithm is implemented in four steps: Partition objects into k nonempty subsets Compute the mean point for every cluster at current partitioning Reassign each object to the cluster with the nearest mean point Go back to Step 2, stop when the assignment does not change k means by python \u00b6 Original Graph import matplotlib.pyplot as plt import seaborn as sns ; sns . set () # for plot styling import numpy as np from sklearn.datasets.samples_generator import make_blobs X , y_true = make_blobs ( n_samples = 300 , centers = 4 , cluster_std = 0.60 , random_state = 0 ) plt . scatter ( X [:, 0 ], X [:, 1 ], s = 50 ); After grouping from sklearn.cluster import KMeans for i in range ( 1 , 10 ): kmeans = KMeans ( n_clusters = i ) kmeans . fit ( X ) y_kmeans = kmeans . predict ( X ) plt . scatter ( X [:, 0 ], X [:, 1 ], c = y_kmeans , s = 50 , cmap = 'viridis' ) centers = kmeans . cluster_centers_ plt . scatter ( centers [:, 0 ], centers [:, 1 ], c = 'black' , s = 200 , alpha = 0.5 ) plt . title ( f \"k-means cluster: {i}\" ) plt . show () Example 1 \u00b6 Suppose you have 5 points in 1-D: {1,2,4,7,10}. Use k-means to cluster these points with k=2. Start with initial partition {1} and {2,4,7,10}. The distance is difference of coordinate on the axis. Drawbacks \u00b6 Both large K and small K can lead to bad results: left K=4, right K=2. Didn't describe data well Hierarchical clustering \u00b6 A method of cluster analysis which seeks to build a hierarchy of clusters No need to specify the number of clusters, we can generate partitions at different levels of the hierarchy. A dendrogram is a tree diagram that can be used to represent the hierarchical clustering structure between data points. The height of connections in the dendrogram represents the distance between partitions: The higher the connection, the larger distance between the two connected clusters. Cut the dendrogram: Clustering is obtained by cutting the dendrogram at the desired level, then each connected component forms a cluster. Building diagram \u00b6 Two types: bottom-up (agglomerative), and top-down (divisive) Bottom-up: two groups are merged if distance between them is less than a threshold Top-down: one group is split into two if inter- group distance is more than a threshold Dimensionality Reduction \u00b6 Given data points in d dimensions, convert them to data points in r<d dimensions, with minimal loss of information. Used for statistical analysis, data compression, and data visualization Idea of Principle Component Analysis \u00b6 Reduce from n-dimension to k-dimension: Find vectors \\(u^1,u^2,...,u^k\\) onto which to project the data, so as to minimize the projection error. These vectors should represent primary information of data, we call them principle components Identity matrix \u00b6 In linear algebra, the identity matrix (sometimes ambiguously called a unit matrix) of size n is the n \u00d7 n square matrix with ones on the main diagonal and zeros elsewhere. It is denoted by In, or simply by I if the size is immaterial or can be trivially determined by the context. In some fields, such as quantum mechanics, the identity matrix is denoted by a boldface one, 1; otherwise it is identical to I. Less frequently, some mathematics books use U or E to represent the identity matrix, meaning \"unit matrix\" and the German word Einheitsmatrix respectively. Eigenvalues and eigenvectors \u00b6 https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors https://www.khanacademy.org/math/linear-algebra/alternate-bases/eigen-everything/v/linear-algebra-introduction-to-eigenvalues-and-eigenvectors Intuitive Idea of PCA \u00b6 https://dilloncamp.com/projects/pca.html What we DON\u2019T want for projection: Original data has large variance, but projected data has small variance. lt means original data is spread, but projected data is not: A lot of information loss during projection. PCA\u2018s goal: maximize the variance of projected data. In fact, the mathematical definition of principle. components (PC) is the eigenvectors of covariance matrix of data points The order of PCs follows the magnitude of. eigenvalues, e.g., the most Signi icant PC is the eigenvector corresponding to largest eigenvalue Page rating \u00b6 A method for rating the importance of web pages using the link structure of the web Simple Recursive Formulation \u00b6 Each link\u2019s vote is proportional to the importance of its source page If page P with importance x has n out-links, each link gets x/n votes Page P\u2019s own importance is the sum of the votes on its in-links Final PageRank score: Importance=sum of votes from all in-links Page rank in python \u00b6 \\[ r_a = \\sum_{j=1}^n L_{a.j}r_j\\] import numpy as np import matplotlib.pyplot as plt # set plot size plt . rcParams [ 'figure.figsize' ] = [ 20 , 5 ] def page_rank ( matrix : np . array , iter = 3 ): shape = matrix . shape [ 1 ] r = np . full (( shape , 1 ), 1 / shape ) l = matrix total_results = None for i in range ( iter ): r = l . dot ( r ) if i == 0 : total_results = r else : total_results = np . concatenate (( total_results , r ), axis = 1 ) return r , total_results m = np . array ( [[ 0 , 0.5 , 0 , 0 ], [ 1 / 3 , 0 , 0 , 1 / 2 ], [ 1 / 3 , 0 , 0 , 1 / 2 ], [ 1 / 3 , 1 / 2 , 1 , 0 ] ] ) r , total_results = page_rank ( m , 20 ) for i , p in enumerate ( total_results ): plt . plot ( p , label = f \" { i } - line\" ) plt . legend () <matplotlib.legend.Legend at 0x7fc4907065c0> Random walk interpretation \u00b6 An equivalent view of PageRank. Imagine a random web surfer At any time t, surfer is on some page P At time t+1, the surfer follows an outlink from P uniformly at random. Ends up on some page Q linked from P, process repeats indefinitely Let p(t) be a vector whose \\(i^{th}\\) component is the probability that the surfer is at page i at time t * p(t) is a probability distribution on pages Stationary Distribution \u00b6 Where is the surfer at time t+1? - Follows a link uniformly at some probability - p(t+1) = Mp(t) where M is the transition probability Suppose the random walk reaches a state such that p(t+1) = Mp(t) = p(t) Then p(t) is called a stationary distribution for the random walk The PageRank score r is the stationary distribution, can be solved by r=Mr. Normalization by scaling sum of r to 1. Stationary Distribution=PageRank Score \u00b6 Stationary distribution represents PageRank score. PageRank Score: A node\u2019s importance equals to the votes from adjacent nodes. Stationary Distribution: Probability of being at one node equals to sum of the probabilities coming from other nodes Both of them describe the stable state. Spider Traps \u00b6 Agroup of pages is a spider trap if there are no links from pages within the group to pages outside the group Random surfer gets trapped, it continuously walk in the trap. Spider traps violate the conditions needed for the random walk theorem import numpy as np def pagerank ( M , num_iterations : int = 100 , d : float = 0.85 ): \"\"\"PageRank: The trillion dollar algorithm. Parameters ---------- M : numpy array adjacency matrix where M_i,j represents the link from 'j' to 'i', such that for all 'j' sum(i, M_i,j) = 1 num_iterations : int, optional number of iterations, by default 100 d : float, optional damping factor, by default 0.85 Returns ------- numpy array a vector of ranks such that v_i is the i-th rank from [0, 1], v sums to 1 \"\"\" N = M . shape [ 1 ] v = np . random . rand ( N , 1 ) v = v / np . linalg . norm ( v , 1 ) M_hat = ( d * M + ( 1 - d ) / N ) for i in range ( num_iterations ): v = M_hat @ v return v M = np . array ([[ 0.5 , 0.5 , 0 ], [ 0.5 , 0 , 0 ], [ 0 , 0.5 , 1 ], ]) v = pagerank ( M , 100 , 0.8 ) print ( v ) [[0.21212121] [0.15151515] [0.63636364]]","title":"Lecture4"},{"location":"MSBD5001/Lecture4/#unsupervised-learning","text":"Another important class of machine learning methods Analyze the structure of the data using feature X Supervised: Use features X to predict labels Y Unsupervised: Only requires features, don\u2019t deal with labels Examples: - Clustering: divide a dataset into meaningful groups. Data points in the same group are more similar with each other, compared to those in different groups. Dimensionality Reduction: | have a dataset of extremely high dimension of features (e.g., images), can | represent them with a lower dimension? Ranking: | have a dataset represented as a graph, each data point is a node, and their relationship are edges, e.g., the World Wide Web, can | rank the importance of the data points?","title":"Unsupervised learning"},{"location":"MSBD5001/Lecture4/#clustering","text":"Clustering: the process of grouping a set of objects into classes of similar objects Objects within the same cluster should be more similar. Objects across the different clusters should be less similar.","title":"Clustering"},{"location":"MSBD5001/Lecture4/#k-means-clustering-method","text":"Given k, the k-means algorithm is implemented in four steps: Partition objects into k nonempty subsets Compute the mean point for every cluster at current partitioning Reassign each object to the cluster with the nearest mean point Go back to Step 2, stop when the assignment does not change","title":"K-means clustering method"},{"location":"MSBD5001/Lecture4/#k-means-by-python","text":"Original Graph import matplotlib.pyplot as plt import seaborn as sns ; sns . set () # for plot styling import numpy as np from sklearn.datasets.samples_generator import make_blobs X , y_true = make_blobs ( n_samples = 300 , centers = 4 , cluster_std = 0.60 , random_state = 0 ) plt . scatter ( X [:, 0 ], X [:, 1 ], s = 50 ); After grouping from sklearn.cluster import KMeans for i in range ( 1 , 10 ): kmeans = KMeans ( n_clusters = i ) kmeans . fit ( X ) y_kmeans = kmeans . predict ( X ) plt . scatter ( X [:, 0 ], X [:, 1 ], c = y_kmeans , s = 50 , cmap = 'viridis' ) centers = kmeans . cluster_centers_ plt . scatter ( centers [:, 0 ], centers [:, 1 ], c = 'black' , s = 200 , alpha = 0.5 ) plt . title ( f \"k-means cluster: {i}\" ) plt . show ()","title":"k means by python"},{"location":"MSBD5001/Lecture4/#example-1","text":"Suppose you have 5 points in 1-D: {1,2,4,7,10}. Use k-means to cluster these points with k=2. Start with initial partition {1} and {2,4,7,10}. The distance is difference of coordinate on the axis.","title":"Example 1"},{"location":"MSBD5001/Lecture4/#drawbacks","text":"Both large K and small K can lead to bad results: left K=4, right K=2. Didn't describe data well","title":"Drawbacks"},{"location":"MSBD5001/Lecture4/#hierarchical-clustering","text":"A method of cluster analysis which seeks to build a hierarchy of clusters No need to specify the number of clusters, we can generate partitions at different levels of the hierarchy. A dendrogram is a tree diagram that can be used to represent the hierarchical clustering structure between data points. The height of connections in the dendrogram represents the distance between partitions: The higher the connection, the larger distance between the two connected clusters. Cut the dendrogram: Clustering is obtained by cutting the dendrogram at the desired level, then each connected component forms a cluster.","title":"Hierarchical clustering"},{"location":"MSBD5001/Lecture4/#building-diagram","text":"Two types: bottom-up (agglomerative), and top-down (divisive) Bottom-up: two groups are merged if distance between them is less than a threshold Top-down: one group is split into two if inter- group distance is more than a threshold","title":"Building diagram"},{"location":"MSBD5001/Lecture4/#dimensionality-reduction","text":"Given data points in d dimensions, convert them to data points in r<d dimensions, with minimal loss of information. Used for statistical analysis, data compression, and data visualization","title":"Dimensionality Reduction"},{"location":"MSBD5001/Lecture4/#idea-of-principle-component-analysis","text":"Reduce from n-dimension to k-dimension: Find vectors \\(u^1,u^2,...,u^k\\) onto which to project the data, so as to minimize the projection error. These vectors should represent primary information of data, we call them principle components","title":"Idea of Principle Component Analysis"},{"location":"MSBD5001/Lecture4/#identity-matrix","text":"In linear algebra, the identity matrix (sometimes ambiguously called a unit matrix) of size n is the n \u00d7 n square matrix with ones on the main diagonal and zeros elsewhere. It is denoted by In, or simply by I if the size is immaterial or can be trivially determined by the context. In some fields, such as quantum mechanics, the identity matrix is denoted by a boldface one, 1; otherwise it is identical to I. Less frequently, some mathematics books use U or E to represent the identity matrix, meaning \"unit matrix\" and the German word Einheitsmatrix respectively.","title":"Identity matrix"},{"location":"MSBD5001/Lecture4/#eigenvalues-and-eigenvectors","text":"https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors https://www.khanacademy.org/math/linear-algebra/alternate-bases/eigen-everything/v/linear-algebra-introduction-to-eigenvalues-and-eigenvectors","title":"Eigenvalues and eigenvectors"},{"location":"MSBD5001/Lecture4/#intuitive-idea-of-pca","text":"https://dilloncamp.com/projects/pca.html What we DON\u2019T want for projection: Original data has large variance, but projected data has small variance. lt means original data is spread, but projected data is not: A lot of information loss during projection. PCA\u2018s goal: maximize the variance of projected data. In fact, the mathematical definition of principle. components (PC) is the eigenvectors of covariance matrix of data points The order of PCs follows the magnitude of. eigenvalues, e.g., the most Signi icant PC is the eigenvector corresponding to largest eigenvalue","title":"Intuitive Idea of PCA"},{"location":"MSBD5001/Lecture4/#page-rating","text":"A method for rating the importance of web pages using the link structure of the web","title":"Page rating"},{"location":"MSBD5001/Lecture4/#simple-recursive-formulation","text":"Each link\u2019s vote is proportional to the importance of its source page If page P with importance x has n out-links, each link gets x/n votes Page P\u2019s own importance is the sum of the votes on its in-links Final PageRank score: Importance=sum of votes from all in-links","title":"Simple Recursive Formulation"},{"location":"MSBD5001/Lecture4/#page-rank-in-python","text":"\\[ r_a = \\sum_{j=1}^n L_{a.j}r_j\\] import numpy as np import matplotlib.pyplot as plt # set plot size plt . rcParams [ 'figure.figsize' ] = [ 20 , 5 ] def page_rank ( matrix : np . array , iter = 3 ): shape = matrix . shape [ 1 ] r = np . full (( shape , 1 ), 1 / shape ) l = matrix total_results = None for i in range ( iter ): r = l . dot ( r ) if i == 0 : total_results = r else : total_results = np . concatenate (( total_results , r ), axis = 1 ) return r , total_results m = np . array ( [[ 0 , 0.5 , 0 , 0 ], [ 1 / 3 , 0 , 0 , 1 / 2 ], [ 1 / 3 , 0 , 0 , 1 / 2 ], [ 1 / 3 , 1 / 2 , 1 , 0 ] ] ) r , total_results = page_rank ( m , 20 ) for i , p in enumerate ( total_results ): plt . plot ( p , label = f \" { i } - line\" ) plt . legend () <matplotlib.legend.Legend at 0x7fc4907065c0>","title":"Page rank in python"},{"location":"MSBD5001/Lecture4/#random-walk-interpretation","text":"An equivalent view of PageRank. Imagine a random web surfer At any time t, surfer is on some page P At time t+1, the surfer follows an outlink from P uniformly at random. Ends up on some page Q linked from P, process repeats indefinitely Let p(t) be a vector whose \\(i^{th}\\) component is the probability that the surfer is at page i at time t * p(t) is a probability distribution on pages","title":"Random walk interpretation"},{"location":"MSBD5001/Lecture4/#stationary-distribution","text":"Where is the surfer at time t+1? - Follows a link uniformly at some probability - p(t+1) = Mp(t) where M is the transition probability Suppose the random walk reaches a state such that p(t+1) = Mp(t) = p(t) Then p(t) is called a stationary distribution for the random walk The PageRank score r is the stationary distribution, can be solved by r=Mr. Normalization by scaling sum of r to 1.","title":"Stationary Distribution"},{"location":"MSBD5001/Lecture4/#stationary-distributionpagerank-score","text":"Stationary distribution represents PageRank score. PageRank Score: A node\u2019s importance equals to the votes from adjacent nodes. Stationary Distribution: Probability of being at one node equals to sum of the probabilities coming from other nodes Both of them describe the stable state.","title":"Stationary Distribution=PageRank Score"},{"location":"MSBD5001/Lecture4/#spider-traps","text":"Agroup of pages is a spider trap if there are no links from pages within the group to pages outside the group Random surfer gets trapped, it continuously walk in the trap. Spider traps violate the conditions needed for the random walk theorem import numpy as np def pagerank ( M , num_iterations : int = 100 , d : float = 0.85 ): \"\"\"PageRank: The trillion dollar algorithm. Parameters ---------- M : numpy array adjacency matrix where M_i,j represents the link from 'j' to 'i', such that for all 'j' sum(i, M_i,j) = 1 num_iterations : int, optional number of iterations, by default 100 d : float, optional damping factor, by default 0.85 Returns ------- numpy array a vector of ranks such that v_i is the i-th rank from [0, 1], v sums to 1 \"\"\" N = M . shape [ 1 ] v = np . random . rand ( N , 1 ) v = v / np . linalg . norm ( v , 1 ) M_hat = ( d * M + ( 1 - d ) / N ) for i in range ( num_iterations ): v = M_hat @ v return v M = np . array ([[ 0.5 , 0.5 , 0 ], [ 0.5 , 0 , 0 ], [ 0 , 0.5 , 1 ], ]) v = pagerank ( M , 100 , 0.8 ) print ( v ) [[0.21212121] [0.15151515] [0.63636364]]","title":"Spider Traps"},{"location":"MSBD5001/Lecture6/","text":"Similarity and Dissimilarity \u00b6 Similarity is the numerical measure of how alike two data objects are. Similarity is important. It is the basic component of many data processing techniques, such as - data integration - data mining: classi cation, clustering, recommendation, anomaly detection Dissimilarity is the numerical measure of how two objects are different. The term distance is frequently used as a synonym for dissimilarity. Attibute Type \u00b6 Norminal (Categorical) Ordinal Interval or Ratio String Matching: \u00b6 Matching strings often appear quite di erently - Typing and OCR errors: David Smith vs. Davod Smith - Di erent formatting convertions: 10/8 vs Oct 8 - Custom abbreviation, shortening, or omission: Daniel Walker Herbert Smith vs. Dan W. Smith - Di erent names, nick names: William Smith vs. Bill Smith - Shu\u000fing parts of strings: Dept. of Computer Science, UST vs. Computer Science Dept., UST namea = \"Dave Smith\" nameb = 'David D. Smith' Edit Distance \u00b6 \\[min \\begin{cases}d(i-1, j) + 1\\\\ d(i, j-1)+1\\\\ d(i-1, j-1) +1\\ if x_1 \\neq y_j \\\\ d(i-1,j-1)\\ if x_1 =y_1 \\end{cases}\\] from pprint import pprint def minDistance ( word1 : str , word2 : str ) -> int : # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) min_edit_dist = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] # initialization for top row for x in range ( 1 , w ): min_edit_dist [ 0 ][ x ] = x # initialization for left-most column for y in range ( 1 , h ): min_edit_dist [ y ][ 0 ] = y # compute minimum edit distance with optimal substructure for y in range ( 1 , h ): for x in range ( 1 , w ): if word_1 [ y ] == word_2 [ x ]: # current character match, no need to edit min_edit_dist [ y ][ x ] = min_edit_dist [ y - 1 ][ x - 1 ] else : # current character mismatch, choose the method of lowest cost, among character replacement, character addition, or character deletion min_edit_dist [ y ][ x ] = min ( min_edit_dist [ y ][ x - 1 ], min_edit_dist [ y - 1 ][ x ], min_edit_dist [ y - 1 ][ x - 1 ]) + 1 pprint ( min_edit_dist ) return min_edit_dist [ - 1 ][ - 1 ] minDistance(namea, nameb) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [4, 3, 2, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [5, 4, 3, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10], [6, 5, 4, 3, 3, 3, 3, 3, 4, 5, 5, 6, 7, 8, 9], [7, 6, 5, 4, 4, 4, 4, 4, 4, 5, 6, 5, 6, 7, 8], [8, 7, 6, 5, 4, 5, 5, 5, 5, 5, 6, 6, 5, 6, 7], [9, 8, 7, 6, 5, 5, 6, 6, 6, 6, 6, 7, 6, 5, 6], [10, 9, 8, 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 6, 5]] 5 Needleman wunch measure \u00b6 initialize matrix of size (n + 1)x(m + 1) where s(a; b) is the element at the a\udbc0\udc00th row and b\udbc0\udc00th column. fill matrix: \\(s(i,0) = -i*c_g, s(0,j)=-j*c_g\\) \\[s(i, j) = max \\begin{cases} s(u - 1, j) - c_g\\\\ s(i, j-1)-c_g\\\\ s(i-1,j-1)=c(x_i,y_j) \\end{cases}\\] from pprint import pprint def find_match ( word1 : str , word2 : str , cg , c , cm ): if word1 == word2 : return c elif word1 == ' ' or word2 == ' ' : return - cg else : return - cm def needle_man ( word1 : str , word2 : str , cg = 1 , c = 1 , cm = 1 ) -> int : \"\"\" cg: gap_penalty c: match award cm: mismatch penalty \"\"\" # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) s = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] # initialization for top row for j in range ( 1 , w ): s [ 0 ][ j ] = - j * cg # initialization for left-most column for i in range ( 1 , h ): s [ i ][ 0 ] = - i * cg for i in range ( 1 , h ): for j in range ( 1 , w ): s [ i ][ j ] = max ( s [ i - 1 ][ j ] - cg , s [ i ][ j - 1 ] - cg , s [ i - 1 ][ j - 1 ] + find_match ( word_1 [ i ], word_2 [ j ], cg , c , cm )) pprint ( s ) return s [ - 1 ][ - 1 ] needle_man(\"dva\", \"deeve\", c=2) [[0, -1, -2, -3, -4, -5], [-1, 2, 1, 0, -1, -2], [-2, 1, 1, 0, 2, 1], [-3, 0, 0, 0, 1, 1]] 1 Affine gap measure \u00b6 Define x = \\(x_1x_2...x_n\\) ; y = \\(y_1y_2..y_m\\) where xi and yj are the i-th and j-th prefixes of x and y Initialization: \\(M(0, 0) = 0, l_x(0,0)=-c_o, l_u(0,0)=-c_o\\) \\(l_x(i,0)=-c_o - c_r * (i - 1)\\) - \\(l_y(0, j) = -c_o - c_r * (j - 1)\\) Other cells in top row and leftmost column = \\(-\\infty\\) \\[M(i, j) = max \\begin{cases} M(i -1, j-1)+c(x_i,y_i)\\\\ l_x(i - 1, j -1) + c(x_i,y_i)\\\\ l_y(u - 1, j-1)+c(x_i, y_i) \\end{cases} \\] \\[ l_x(i, j) = max\\begin{cases} M(i - 1, j) - c_o \\\\ l_x(i - 1, j) - c_r \\end{cases} \\] \\[ l_y(i, j) = max\\begin{cases} M(i , j - 1) - c_o \\\\ l_y(i, j - 1) - c_r \\end{cases} \\] where \\(c_o\\) is the cost of opening a gap, \\(c_r\\) is the cost of continuing a gap, \\((x_i, y_j)\\) is the score for correspoding character \\(x_i\\) with \\(y_j\\) in the score matrix. Score: max(m, ix, iy) from math import inf def find_match ( word1 , word2 , reward , penalty ): if word1 == word2 : return reward else : return - penalty def affine_gap ( word1 : str , word2 : str , co = 1 , cr = 1 , cg = 1 , c = 1 , cm = 1 ) -> int : \"\"\" co: cost of opening a gap cm: cost of continuing the gap cg: gap_penalty c: match award cm: mismatch penalty \"\"\" # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) m = [ [ - inf for _ in range ( w ) ] for _ in range ( h ) ] i_x = [ [ - inf for _ in range ( w ) ] for _ in range ( h ) ] i_y = [ [ - inf for _ in range ( w ) ] for _ in range ( h ) ] m [ 0 ][ 0 ] = 0 i_x [ 0 ][ 0 ] = - co i_y [ 0 ][ 0 ] = - co # initialization for top row for j in range ( 1 , w ): i_y [ 0 ][ j ] = - co - cr * ( j - 1 ) # initialization for left-most column for i in range ( 1 , h ): i_x [ i ][ 0 ] = - co - cr * ( i - 1 ) for i in range ( 1 , h ): for j in range ( 1 , w ): match_reward = find_match ( word_1 [ i ], word_2 [ j ], reward = c , penalty = cm ) m [ i ][ j ] = max ( m [ i - 1 ][ j - 1 ] + match_reward , i_x [ i - 1 ][ j - 1 ] + match_reward , i_y [ i - 1 ][ j - 1 ] + match_reward ) i_x [ i ][ j ] = max ( m [ i - 1 ][ j ] - co , i_x [ i - 1 ][ j ] - cr ) i_y [ i ][ j ] = max ( m [ i ][ j - 1 ] - co , i_y [ i ][ j - 1 ] - cr ) print ( \"m: \" ) pprint ( m ) print ( \"i_x: \" ) pprint ( i_x ) print ( \"i_y: \" ) pprint ( i_y ) return max ( m [ - 1 ][ - 1 ], i_x [ - 1 ][ - 1 ], i_y [ - 1 ][ - 1 ]) affine_gap(\"AAT\", \"ACACT\", c=1, co=4, cr=1) m: [[0, -inf, -inf, -inf, -inf, -inf], [-inf, 1, -5, -4, -7, -8], [-inf, -3, 0, -2, -5, -6], [-inf, -6, -4, -1, -3, -4]] i_x: [[-4, -inf, -inf, -inf, -inf, -inf], [-4, -inf, -inf, -inf, -inf, -inf], [-5, -3, -9, -8, -11, -12], [-6, -4, -4, -6, -9, -10]] i_y: [[-4, -4, -5, -6, -7, -8], [-inf, -inf, -3, -4, -5, -6], [-inf, -inf, -7, -4, -5, -6], [-inf, -inf, -10, -8, -5, -6]] -4 Smith-Waterman Measure \u00b6 Initialization: - initialize matrix of size (n + 1)x(m + 1) where s(a; b) is the element at the a-th row and b-th column. - fill matrix: s(i ; 0) = 0, s(0; j) = 0 \\[s(i, j) = max= \\begin {cases} 0 \\\\ s_i - 1, j)-c_g\\\\ s(i, j-1)-c_g\\\\ s(i-1,j-1)+c(x_i,y_i) \\end{cases}\\] def smith_waterman ( word1 : str , word2 : str , cm = 1 , c = 1 , cg = 1 ) -> int : \"\"\" cg: gap_penalty c: match award cm: mismatch penalty \"\"\" # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) s = [ [ 0 for _ in range (w ) ] for _ in range ( h ) ] # initialization for top row for j in range ( 1 , w ) : s [ 0 ][ j ] = 0 # initialization for left - most column for i in range ( 1 , h ) : s [ i ][ 0 ] = 0 for i in range ( 1 , h ) : for j in range ( 1 , w ) : match_reward = find_match ( word_1 [ i ] , word_2 [ j ] , reward = c , penalty = cg ) s [ i ][ j ] = max ( 0 , s [ i - 1 ][ j ] - cg , s [ i ][ j - 1 ] - cg , s [ i - 1 ][ j - 1 ] + match_reward ) pprint ( s ) return s [ -1 ][ -1 ] smith_waterman(\" avd\", \"dave\") [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 2, 1], [0, 1, 0, 1, 1]] 1 Set base \u00b6 View strings as sets or multi-sets of tokens Common methods to generate tokens words delimited by space e.g. for the string \\david smith\", the tokens are \\david\" and \\smith\" stem the words if necessary remove stop words (e.g. the, and of) I q-grams, substrings of length q e.g. for the string \\david smith\", the set of 3-grams are ##d, #da, dav, avi, ..., h## special character # to handle the start and end of string fkccecia, Overlap Measure \u00b6 Let Bx = set of tokens generated for string x Let By = set of tokens generated for string y returns the number of common tokens \\( \\(O(x, y) = |B_x \\cap B_y |\\) \\) E.g., x = dave, y = dav, considering 2-grams $$ B_x = {#d, da, av, ve, e# }$$ \\[ B_y = \\{\\#d,da, av, v\\# \\}$$ $$ O(x, y) = 3 \\] def token ( word : str , max_token_len = 2 ): sets = [] new_word = f \"#{word}#\" length = len ( new_word ) for i in range ( length - 1 ): w = new_word [ i : i + 2 ] sets . append ( w ) return set ( sets ) def overlap ( word1 , word2 , max_token_len = 2 ): set1 = token ( word1 , max_token_len ) set2 = token ( word2 , max_token_len ) return set1 . intersection ( set2 ) overlap(\"dave\", \"dav\") {'#d', 'av', 'da'} Jaccard Measure \u00b6 Let Bx = set of tokens generated for string x Let By = set of tokens generated for string y returns the number of common tokens \\( \\(J(x, y) = |B_x \\cap B_y | / |B_x \\cup B_y |\\) \\) E.g., x = dave, y = dav, considering 2-grams Bx = {#d, da, av, ve, e#}, By = {#d, da, av, v#} J(x; y) = 3 / 6 def jaccard ( word1 , word2 , max_token_len = 2 ): set1 = token ( word1 , max_token_len ) set2 = token ( word2 , max_token_len ) print ( f \"Union: {set1.union(set2)}\" ) print ( f \"Intersection: {set1.intersection(set2)}\" ) return len ( set1 . intersection ( set2 )) / len ( set1 . union ( set2 )) jaccard(\"dave\", \"dav\") Union: {'#d', 'e#', 've', 'da', 'v#', 'av'} Intersection: {'#d', 'da', 'av'} 0.5","title":"Lecture6"},{"location":"MSBD5001/Lecture6/#similarity-and-dissimilarity","text":"Similarity is the numerical measure of how alike two data objects are. Similarity is important. It is the basic component of many data processing techniques, such as - data integration - data mining: classi cation, clustering, recommendation, anomaly detection Dissimilarity is the numerical measure of how two objects are different. The term distance is frequently used as a synonym for dissimilarity.","title":"Similarity and Dissimilarity"},{"location":"MSBD5001/Lecture6/#attibute-type","text":"Norminal (Categorical) Ordinal Interval or Ratio","title":"Attibute Type"},{"location":"MSBD5001/Lecture6/#string-matching","text":"Matching strings often appear quite di erently - Typing and OCR errors: David Smith vs. Davod Smith - Di erent formatting convertions: 10/8 vs Oct 8 - Custom abbreviation, shortening, or omission: Daniel Walker Herbert Smith vs. Dan W. Smith - Di erent names, nick names: William Smith vs. Bill Smith - Shu\u000fing parts of strings: Dept. of Computer Science, UST vs. Computer Science Dept., UST namea = \"Dave Smith\" nameb = 'David D. Smith'","title":"String Matching:"},{"location":"MSBD5001/Lecture6/#edit-distance","text":"\\[min \\begin{cases}d(i-1, j) + 1\\\\ d(i, j-1)+1\\\\ d(i-1, j-1) +1\\ if x_1 \\neq y_j \\\\ d(i-1,j-1)\\ if x_1 =y_1 \\end{cases}\\] from pprint import pprint def minDistance ( word1 : str , word2 : str ) -> int : # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) min_edit_dist = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] # initialization for top row for x in range ( 1 , w ): min_edit_dist [ 0 ][ x ] = x # initialization for left-most column for y in range ( 1 , h ): min_edit_dist [ y ][ 0 ] = y # compute minimum edit distance with optimal substructure for y in range ( 1 , h ): for x in range ( 1 , w ): if word_1 [ y ] == word_2 [ x ]: # current character match, no need to edit min_edit_dist [ y ][ x ] = min_edit_dist [ y - 1 ][ x - 1 ] else : # current character mismatch, choose the method of lowest cost, among character replacement, character addition, or character deletion min_edit_dist [ y ][ x ] = min ( min_edit_dist [ y ][ x - 1 ], min_edit_dist [ y - 1 ][ x ], min_edit_dist [ y - 1 ][ x - 1 ]) + 1 pprint ( min_edit_dist ) return min_edit_dist [ - 1 ][ - 1 ] minDistance(namea, nameb) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], [3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [4, 3, 2, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [5, 4, 3, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10], [6, 5, 4, 3, 3, 3, 3, 3, 4, 5, 5, 6, 7, 8, 9], [7, 6, 5, 4, 4, 4, 4, 4, 4, 5, 6, 5, 6, 7, 8], [8, 7, 6, 5, 4, 5, 5, 5, 5, 5, 6, 6, 5, 6, 7], [9, 8, 7, 6, 5, 5, 6, 6, 6, 6, 6, 7, 6, 5, 6], [10, 9, 8, 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 6, 5]] 5","title":"Edit Distance"},{"location":"MSBD5001/Lecture6/#needleman-wunch-measure","text":"initialize matrix of size (n + 1)x(m + 1) where s(a; b) is the element at the a\udbc0\udc00th row and b\udbc0\udc00th column. fill matrix: \\(s(i,0) = -i*c_g, s(0,j)=-j*c_g\\) \\[s(i, j) = max \\begin{cases} s(u - 1, j) - c_g\\\\ s(i, j-1)-c_g\\\\ s(i-1,j-1)=c(x_i,y_j) \\end{cases}\\] from pprint import pprint def find_match ( word1 : str , word2 : str , cg , c , cm ): if word1 == word2 : return c elif word1 == ' ' or word2 == ' ' : return - cg else : return - cm def needle_man ( word1 : str , word2 : str , cg = 1 , c = 1 , cm = 1 ) -> int : \"\"\" cg: gap_penalty c: match award cm: mismatch penalty \"\"\" # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) s = [ [ 0 for _ in range ( w ) ] for _ in range ( h ) ] # initialization for top row for j in range ( 1 , w ): s [ 0 ][ j ] = - j * cg # initialization for left-most column for i in range ( 1 , h ): s [ i ][ 0 ] = - i * cg for i in range ( 1 , h ): for j in range ( 1 , w ): s [ i ][ j ] = max ( s [ i - 1 ][ j ] - cg , s [ i ][ j - 1 ] - cg , s [ i - 1 ][ j - 1 ] + find_match ( word_1 [ i ], word_2 [ j ], cg , c , cm )) pprint ( s ) return s [ - 1 ][ - 1 ] needle_man(\"dva\", \"deeve\", c=2) [[0, -1, -2, -3, -4, -5], [-1, 2, 1, 0, -1, -2], [-2, 1, 1, 0, 2, 1], [-3, 0, 0, 0, 1, 1]] 1","title":"Needleman wunch measure"},{"location":"MSBD5001/Lecture6/#affine-gap-measure","text":"Define x = \\(x_1x_2...x_n\\) ; y = \\(y_1y_2..y_m\\) where xi and yj are the i-th and j-th prefixes of x and y Initialization: \\(M(0, 0) = 0, l_x(0,0)=-c_o, l_u(0,0)=-c_o\\) \\(l_x(i,0)=-c_o - c_r * (i - 1)\\) - \\(l_y(0, j) = -c_o - c_r * (j - 1)\\) Other cells in top row and leftmost column = \\(-\\infty\\) \\[M(i, j) = max \\begin{cases} M(i -1, j-1)+c(x_i,y_i)\\\\ l_x(i - 1, j -1) + c(x_i,y_i)\\\\ l_y(u - 1, j-1)+c(x_i, y_i) \\end{cases} \\] \\[ l_x(i, j) = max\\begin{cases} M(i - 1, j) - c_o \\\\ l_x(i - 1, j) - c_r \\end{cases} \\] \\[ l_y(i, j) = max\\begin{cases} M(i , j - 1) - c_o \\\\ l_y(i, j - 1) - c_r \\end{cases} \\] where \\(c_o\\) is the cost of opening a gap, \\(c_r\\) is the cost of continuing a gap, \\((x_i, y_j)\\) is the score for correspoding character \\(x_i\\) with \\(y_j\\) in the score matrix. Score: max(m, ix, iy) from math import inf def find_match ( word1 , word2 , reward , penalty ): if word1 == word2 : return reward else : return - penalty def affine_gap ( word1 : str , word2 : str , co = 1 , cr = 1 , cg = 1 , c = 1 , cm = 1 ) -> int : \"\"\" co: cost of opening a gap cm: cost of continuing the gap cg: gap_penalty c: match award cm: mismatch penalty \"\"\" # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) m = [ [ - inf for _ in range ( w ) ] for _ in range ( h ) ] i_x = [ [ - inf for _ in range ( w ) ] for _ in range ( h ) ] i_y = [ [ - inf for _ in range ( w ) ] for _ in range ( h ) ] m [ 0 ][ 0 ] = 0 i_x [ 0 ][ 0 ] = - co i_y [ 0 ][ 0 ] = - co # initialization for top row for j in range ( 1 , w ): i_y [ 0 ][ j ] = - co - cr * ( j - 1 ) # initialization for left-most column for i in range ( 1 , h ): i_x [ i ][ 0 ] = - co - cr * ( i - 1 ) for i in range ( 1 , h ): for j in range ( 1 , w ): match_reward = find_match ( word_1 [ i ], word_2 [ j ], reward = c , penalty = cm ) m [ i ][ j ] = max ( m [ i - 1 ][ j - 1 ] + match_reward , i_x [ i - 1 ][ j - 1 ] + match_reward , i_y [ i - 1 ][ j - 1 ] + match_reward ) i_x [ i ][ j ] = max ( m [ i - 1 ][ j ] - co , i_x [ i - 1 ][ j ] - cr ) i_y [ i ][ j ] = max ( m [ i ][ j - 1 ] - co , i_y [ i ][ j - 1 ] - cr ) print ( \"m: \" ) pprint ( m ) print ( \"i_x: \" ) pprint ( i_x ) print ( \"i_y: \" ) pprint ( i_y ) return max ( m [ - 1 ][ - 1 ], i_x [ - 1 ][ - 1 ], i_y [ - 1 ][ - 1 ]) affine_gap(\"AAT\", \"ACACT\", c=1, co=4, cr=1) m: [[0, -inf, -inf, -inf, -inf, -inf], [-inf, 1, -5, -4, -7, -8], [-inf, -3, 0, -2, -5, -6], [-inf, -6, -4, -1, -3, -4]] i_x: [[-4, -inf, -inf, -inf, -inf, -inf], [-4, -inf, -inf, -inf, -inf, -inf], [-5, -3, -9, -8, -11, -12], [-6, -4, -4, -6, -9, -10]] i_y: [[-4, -4, -5, -6, -7, -8], [-inf, -inf, -3, -4, -5, -6], [-inf, -inf, -7, -4, -5, -6], [-inf, -inf, -10, -8, -5, -6]] -4","title":"Affine gap measure"},{"location":"MSBD5001/Lecture6/#smith-waterman-measure","text":"Initialization: - initialize matrix of size (n + 1)x(m + 1) where s(a; b) is the element at the a-th row and b-th column. - fill matrix: s(i ; 0) = 0, s(0; j) = 0 \\[s(i, j) = max= \\begin {cases} 0 \\\\ s_i - 1, j)-c_g\\\\ s(i, j-1)-c_g\\\\ s(i-1,j-1)+c(x_i,y_i) \\end{cases}\\] def smith_waterman ( word1 : str , word2 : str , cm = 1 , c = 1 , cg = 1 ) -> int : \"\"\" cg: gap_penalty c: match award cm: mismatch penalty \"\"\" # padding one whitespace for empty string representation word_1 = ' ' + word1 word_2 = ' ' + word2 h , w = len ( word_1 ), len ( word_2 ) s = [ [ 0 for _ in range (w ) ] for _ in range ( h ) ] # initialization for top row for j in range ( 1 , w ) : s [ 0 ][ j ] = 0 # initialization for left - most column for i in range ( 1 , h ) : s [ i ][ 0 ] = 0 for i in range ( 1 , h ) : for j in range ( 1 , w ) : match_reward = find_match ( word_1 [ i ] , word_2 [ j ] , reward = c , penalty = cg ) s [ i ][ j ] = max ( 0 , s [ i - 1 ][ j ] - cg , s [ i ][ j - 1 ] - cg , s [ i - 1 ][ j - 1 ] + match_reward ) pprint ( s ) return s [ -1 ][ -1 ] smith_waterman(\" avd\", \"dave\") [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 2, 1], [0, 1, 0, 1, 1]] 1","title":"Smith-Waterman Measure"},{"location":"MSBD5001/Lecture6/#set-base","text":"View strings as sets or multi-sets of tokens Common methods to generate tokens words delimited by space e.g. for the string \\david smith\", the tokens are \\david\" and \\smith\" stem the words if necessary remove stop words (e.g. the, and of) I q-grams, substrings of length q e.g. for the string \\david smith\", the set of 3-grams are ##d, #da, dav, avi, ..., h## special character # to handle the start and end of string fkccecia,","title":"Set base"},{"location":"MSBD5001/Lecture6/#overlap-measure","text":"Let Bx = set of tokens generated for string x Let By = set of tokens generated for string y returns the number of common tokens \\( \\(O(x, y) = |B_x \\cap B_y |\\) \\) E.g., x = dave, y = dav, considering 2-grams $$ B_x = {#d, da, av, ve, e# }$$ \\[ B_y = \\{\\#d,da, av, v\\# \\}$$ $$ O(x, y) = 3 \\] def token ( word : str , max_token_len = 2 ): sets = [] new_word = f \"#{word}#\" length = len ( new_word ) for i in range ( length - 1 ): w = new_word [ i : i + 2 ] sets . append ( w ) return set ( sets ) def overlap ( word1 , word2 , max_token_len = 2 ): set1 = token ( word1 , max_token_len ) set2 = token ( word2 , max_token_len ) return set1 . intersection ( set2 ) overlap(\"dave\", \"dav\") {'#d', 'av', 'da'}","title":"Overlap Measure"},{"location":"MSBD5001/Lecture6/#jaccard-measure","text":"Let Bx = set of tokens generated for string x Let By = set of tokens generated for string y returns the number of common tokens \\( \\(J(x, y) = |B_x \\cap B_y | / |B_x \\cup B_y |\\) \\) E.g., x = dave, y = dav, considering 2-grams Bx = {#d, da, av, ve, e#}, By = {#d, da, av, v#} J(x; y) = 3 / 6 def jaccard ( word1 , word2 , max_token_len = 2 ): set1 = token ( word1 , max_token_len ) set2 = token ( word2 , max_token_len ) print ( f \"Union: {set1.union(set2)}\" ) print ( f \"Intersection: {set1.intersection(set2)}\" ) return len ( set1 . intersection ( set2 )) / len ( set1 . union ( set2 )) jaccard(\"dave\", \"dav\") Union: {'#d', 'e#', 've', 'da', 'v#', 'av'} Intersection: {'#d', 'da', 'av'} 0.5","title":"Jaccard Measure"},{"location":"MSBD5001/project/Group%20Project/","text":"import pandas as pd from sklearn.preprocessing import MinMaxScaler import requests from datetime import datetime import tensorflow as tf import seaborn as sns import matplotlib.pyplot as plt from sklearn.pipeline import Pipeline from sklearn.preprocessing import LabelBinarizer , OneHotEncoder , StandardScaler from sklearn.compose import ColumnTransformer from sklearn.model_selection import train_test_split from sklearn.model_selection import TimeSeriesSplit from sklearn.model_selection import GridSearchCV from sklearn import svm from xgboost import XGBRegressor from sklearn.ensemble import RandomForestRegressor import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers from tensorflow.keras.metrics import MeanSquaredError from tensorflow.keras import regularizers import numpy as np from sklearn.metrics import mean_squared_error Preprocess Data \u00b6 train = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/group project/disney_shanghai.csv' , parse_dates = [ 'Time' ]) test = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/group project/disney_shanghai_test.csv' , names = [ 'Time' , 'Facility ID' , 'Name' , 'Wait time' , 'Ride yype' , 'Temperature' , 'Max temperature' , 'Min temperature' , 'Humidity' , 'Pressure' , 'Wind degree' , 'Wind speed' , 'Cloud' , 'Weather' , 'Weather description' ], parse_dates = [ 'Time' ]) print ( train . info ()) print ( test . info ()) <class 'pandas.core.frame.DataFrame'> RangeIndex: 32024 entries, 0 to 32023 Data columns (total 17 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Name 32024 non-null object 1 Ride type 32024 non-null object 2 Time 32024 non-null datetime64[ns, pytz.FixedOffset(480)] 3 Fastpass-avaliable 32024 non-null bool 4 Status 32024 non-null object 5 Wait time 14621 non-null float64 6 Weather 32024 non-null object 7 Weather description 32024 non-null object 8 Temperature 32024 non-null float64 9 Max temperature 32024 non-null float64 10 Min temperature 32024 non-null float64 11 Pressure 32024 non-null int64 12 Humidity 32024 non-null int64 13 Wind degree 32024 non-null float64 14 Wind speed 32024 non-null float64 15 Cloud 32024 non-null int64 16 Visibility 32024 non-null int64 dtypes: bool(1), datetime64[ns, pytz.FixedOffset(480)](1), float64(6), int64(4), object(5) memory usage: 3.9+ MB None <class 'pandas.core.frame.DataFrame'> RangeIndex: 10449 entries, 0 to 10448 Data columns (total 15 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Time 10449 non-null datetime64[ns, UTC] 1 Facility ID 10449 non-null object 2 Name 10449 non-null object 3 Wait time 4016 non-null float64 4 Ride yype 10449 non-null object 5 Temperature 10449 non-null int64 6 Max temperature 10449 non-null float64 7 Min temperature 10449 non-null float64 8 Humidity 10449 non-null int64 9 Pressure 10449 non-null int64 10 Wind degree 10449 non-null int64 11 Wind speed 10449 non-null float64 12 Cloud 10449 non-null int64 13 Weather 10449 non-null object 14 Weather description 10449 non-null object dtypes: datetime64[ns, UTC](1), float64(4), int64(5), object(5) memory usage: 1.2+ MB None show data train = train[['Name', 'Time', 'Wait time', 'Weather', 'Temperature', 'Max temperature', 'Min temperature', 'Pressure', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud']] train.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud 0 Camp Discovery 2020-08-31 13:38:47.638019+08:00 0.0 Clouds 33.28 34.0 34.0 1009 66 110.0 5.0 75 1 Challenge Trails at Camp Discovery 2020-08-31 13:38:47.638035+08:00 10.0 Clouds 33.28 34.0 34.0 1009 66 110.0 5.0 75 show test test = test[['Name', 'Time', 'Wait time', 'Weather', 'Temperature', 'Max temperature', 'Min temperature', 'Pressure', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud']] test.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud 0 Challenge Trails at Camp Discovery 2020-11-14 10:07:34+00:00 30.0 Clouds 18 18.0 18.0 1026 68 70 3.0 20 1 Vista Trail at Camp Discovery 2020-11-14 10:07:34+00:00 0.0 Clouds 18 18.0 18.0 1026 68 70 3.0 20 Change name into values \u00b6 unique_names = train[['Name']].drop_duplicates() unique_names['id'] = range(len(unique_names)) train = train.merge(unique_names, on='Name') unique_names .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name id 0 Camp Discovery 0 1 Challenge Trails at Camp Discovery 1 2 Vista Trail at Camp Discovery 2 3 Soaring Over the Horizon 3 4 \u201cOnce Upon a Time\u201d Adventure 4 5 Alice in Wonderland Maze 5 6 Frozen: A Sing-Along Celebration 6 7 Hunny Pot Spin 7 8 Peter Pan\u2019s Flight 8 9 Seven Dwarfs Mine Train 9 10 The Many Adventures of Winnie the Pooh 10 11 Voyage to the Crystal Grotto 11 12 Dumbo the Flying Elephant 12 13 Fantasia Carousel 13 14 TRON Lightcycle Power Run \u2013 Presented by Chevr... 14 15 Stitch Encounter 15 16 Jet Packs 16 17 Buzz Lightyear Planet Rescue 17 18 Siren's Revenge 18 19 Shipwreck Shore 19 20 Pirates of the Caribbean Battle for the Sunken... 20 21 Explorer Canoes 21 22 Eye of the Storm: Captain Jack\u2019s Stunt Spectac... 22 23 Roaring Rapids 23 24 Ignite the Dream - A Nighttime Spectacular of ... 24 25 Mickey\u2019s Storybook Express 25 26 Golden Fairytale Fanfare 26 27 TRON Realm, Chevrolet Digital Challenge 27 28 Rex\u2019s Racer 28 29 Slinky Dog Spin 29 30 Woody\u2019s Roundup 30 31 Marvel Universe 31 32 Club Destin-E 32 33 Color Wall 33 34 Avengers Training Initiative 34 35 Wave Hello to Your Favorite Mickey Avenue Char... 35 36 Mickey Avenue Kiss Goodnight 36 37 Adventurous Friends Exploration 37 38 Catch a Glimpse of Jack Sparrow 38 39 Hundred Acre Wood Character Sighting 39 40 Princess Balcony Greetings 40 41 Avengers Assemble at the E-Stage 41 42 Woody\u2019s Rescue Patrol 42 Dropna \u00b6 train = train.dropna() test = test.dropna() Add busy label \u00b6 def is_busy(time: int): if time < 30: return [1, 0, 0] elif time >= 30 and time <= 70: return [0, 1, 0] else: return [0, 0, 1] Add weekend and public holiday \u00b6 def hour_modify ( x : datetime ) : Early_Morning = [ 4,5,6,7 ] Morning = [ 8,9,10,11 ] Afternoon = [ 12,13,14,15 ] Evening = [ 16,17,18,19 ] Night = [ 20,21,22,23 ] Late_Night = [ 0,1,2,3 ] if x . hour in Early_Morning : return 'Early_Morning' elif x . hour in Morning : return 'Morning' elif x . hour in Afternoon : return 'Afternoon' elif x . hour in Evening : return 'Evening' elif x . hour in Night : return 'Night' else : return 'Late_Night' def add_holiday_and_weekend ( df : pd . DataFrame , date_field_str = 'date' ) -> pd . DataFrame : \"\"\" Add holiday and weekend to the dataset \"\"\" new_df = df . copy () new_df [ 'IsWeekend' ] = new_df [ date_field_str ] . apply ( lambda x : 0 if x . weekday () in [ 0,1,2,3,4 ] else 1 ) new_df [ 'IsHoliday' ]= new_df [ date_field_str ] . apply ( lambda x : 1 if ( x . date (). strftime ( '%Y-%m-%d' ) in [ '2020-01-01', '2020-01-24', '2020-01-24', '2020-01-25', '2020-01-26', '2020-01-27', '2020-01-28', '2020-01-29', '2020-01-30', '2020-01-31', '2020-02-01', '2020-02-02', '2020-04-04', '2020-05-01', '2020-05-02', '2020-05-03', '2020-05-04', '2020-05-05', '2020-06-25', '2020-06-26', '2020-06-27', '2020-10-01', '2020-10-02', '2020-10-03', '2020-10-04', '2020-10-05', '2020-10-06', '2020-10-07', '2020-10-08', '2020-10-31' ] ) or ( x . weekday () in [ 6 ] ) else 0 ) return new_df convert time zone train [ 'Time' ] = train [ 'Time' ]. dt . tz_localize ( None ) print ( train [ 'Time' ]) 0 2020-08-31 13:38:47.638019 1 2020-08-31 14:09:47.630487 2 2020-08-31 14:26:10.487907 3 2020-08-31 14:29:48.273505 4 2020-08-31 15:09:11.331162 ... 23808 2020-10-24 15:23:47.123270 23809 2020-10-24 16:25:44.947592 23810 2020-10-24 17:23:16.431926 23816 2020-10-25 10:26:28.625480 23817 2020-10-25 11:24:10.125045 Name: Time, Length: 14621, dtype: datetime64[ns] test['Time'] = test['Time'].dt.tz_convert(\"Asia/Shanghai\").dt.tz_localize(None) print(test['Time']) 0 2020-11-14 18:07:34 1 2020-11-14 18:07:34 2 2020-11-14 18:07:34 3 2020-11-14 18:07:34 4 2020-11-14 18:07:34 ... 10340 2020-12-01 19:07:47 10348 2020-12-01 19:07:47 10349 2020-12-01 19:07:47 10350 2020-12-01 19:07:47 10351 2020-12-01 19:07:47 Name: Time, Length: 4016, dtype: datetime64[ns] Add public holidays train = add_holiday_and_weekend ( train , 'Time' ) test = add_holiday_and_weekend ( test , 'Time' ) train [ 'Hour modify' ] = train [ 'Time' ]. apply ( hour_modify ) test [ 'Hour modify' ] = test [ 'Time' ]. apply ( hour_modify ) train [ 'Is busy' ] = train [ 'Wait time' ]. apply ( is_busy ) train . head ( 3 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud id IsWeekend IsHoliday Hour modify Is busy 0 Camp Discovery 2020-08-31 13:38:47.638019 0.0 Clouds 33.28 34.00 34.00 1009 66 110.0 5.0 75 0 0 0 Afternoon [1, 0, 0] 1 Camp Discovery 2020-08-31 14:09:47.630487 0.0 Clouds 33.80 35.56 35.56 1008 70 110.0 5.0 75 0 0 0 Afternoon [1, 0, 0] 2 Camp Discovery 2020-08-31 14:26:10.487907 0.0 Clouds 34.11 35.56 35.56 1008 66 110.0 6.0 75 0 0 0 Afternoon [1, 0, 0] Plot Data \u00b6 plt.figure(figsize=(6,4)) sns.boxplot('Wait time',data=train,orient='h',palette=\"Set3\",linewidth=2.5) plt.show() /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variable as a keyword arg: x. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. FutureWarning train[['Wait time', 'Temperature', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud']].describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Wait time Temperature Humidity Wind degree Wind speed Cloud count 14621.000000 14621.000000 14621.000000 14621.000000 14621.000000 14621.000000 mean 23.616374 24.423189 64.933862 127.520347 5.352968 45.041174 std 26.388862 4.075267 14.270916 119.544200 1.962247 31.870902 min 0.000000 14.800000 33.000000 0.000000 0.450000 0.000000 25% 5.000000 21.570000 56.000000 30.000000 4.000000 20.000000 50% 15.000000 23.930000 61.000000 70.000000 5.000000 40.000000 75% 30.000000 26.900000 74.000000 180.000000 7.000000 75.000000 max 195.000000 35.050000 100.000000 360.000000 11.000000 100.000000 Train \u00b6 train.columns Index(['Name', 'Time', 'Wait time', 'Weather', 'Temperature', 'Max temperature', 'Min temperature', 'Pressure', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud', 'id', 'IsWeekend', 'IsHoliday', 'Hour modify', 'Is busy'], dtype='object') def plot_history ( history ) : hist = pd . DataFrame ( history . history ) hist [ 'epoch' ] = history . epoch plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Abs Error [MPG]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mae' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mae' ] , label = 'Val Error' ) plt . legend () plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Square Error [$MPG^2$]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mse' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mse' ] , label = 'Val Error' ) plt . legend () plt . show () def generate_training_data ( data : pd . DataFrame , prediction_label , cat_vars =[ 'id', 'IsWeekend','IsHoliday','Hour modify', 'Weather' ] , num_vars =[ 'Temperature', 'Pressure', 'Humidity', 'Cloud', 'Wind degree' ] , should_reshape = True ) : x = train . copy () y = x [ prediction_label ] . to_list () y = np . array ( y ) numeric_transformer = Pipeline ( steps =[ ('scaler', MinMaxScaler()) ] ) categorical_transformer = Pipeline ( steps =[ ('oneHot',OneHotEncoder(sparse=False)) ] ) preprocessor = ColumnTransformer ( transformers =[ ('num',numeric_transformer,num_vars), ('cat',categorical_transformer,cat_vars) ] ) data_transformed = preprocessor . fit_transform ( x ) if should_reshape : y = y . reshape ( - 1 , 1 ) scaler = MinMaxScaler () scaled_y = scaler . fit_transform ( y ) return train_test_split ( data_transformed , scaled_y , test_size = 0.02 , random_state = 42 ), scaler else : return train_test_split ( data_transformed , y , test_size = 0.02 , random_state = 42 ) data, scaler=generate_training_data(train, 'Wait time') X_train,X_test,y_train,y_test = data print(y_train.shape) print(X_train.shape) (14328, 1) (14328, 44) Training by using DNN \u00b6 early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 512 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 256 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 128 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( y_train . shape [ 1 ] ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 001 ) model . compile ( loss = 'mean_squared_error' , optimizer = opt , metrics = [ 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 1000 , callbacks =[ early_stop ] , validation_split = 0.2 ) plot_history ( history ) Epoch 1/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0114 - mae: 0.0738 - mse: 0.0114 - val_loss: 0.0060 - val_mae: 0.0532 - val_mse: 0.0060 Epoch 2/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0068 - mae: 0.0551 - mse: 0.0068 - val_loss: 0.0057 - val_mae: 0.0503 - val_mse: 0.0057 Epoch 3/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0061 - mae: 0.0510 - mse: 0.0061 - val_loss: 0.0053 - val_mae: 0.0492 - val_mse: 0.0053 Epoch 4/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0058 - mae: 0.0494 - mse: 0.0058 - val_loss: 0.0054 - val_mae: 0.0512 - val_mse: 0.0054 Epoch 5/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0053 - mae: 0.0473 - mse: 0.0053 - val_loss: 0.0049 - val_mae: 0.0488 - val_mse: 0.0049 Epoch 6/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0053 - mae: 0.0469 - mse: 0.0053 - val_loss: 0.0056 - val_mae: 0.0509 - val_mse: 0.0056 Epoch 7/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0053 - mae: 0.0469 - mse: 0.0053 - val_loss: 0.0053 - val_mae: 0.0501 - val_mse: 0.0053 Epoch 8/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0051 - mae: 0.0460 - mse: 0.0051 - val_loss: 0.0052 - val_mae: 0.0515 - val_mse: 0.0052 Epoch 9/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0050 - mae: 0.0455 - mse: 0.0050 - val_loss: 0.0047 - val_mae: 0.0452 - val_mse: 0.0047 Epoch 10/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0048 - mae: 0.0449 - mse: 0.0048 - val_loss: 0.0058 - val_mae: 0.0512 - val_mse: 0.0058 Epoch 11/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0046 - mae: 0.0437 - mse: 0.0046 - val_loss: 0.0049 - val_mae: 0.0480 - val_mse: 0.0049 Epoch 12/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0046 - mae: 0.0435 - mse: 0.0046 - val_loss: 0.0049 - val_mae: 0.0471 - val_mse: 0.0049 Epoch 13/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0044 - mae: 0.0431 - mse: 0.0044 - val_loss: 0.0050 - val_mae: 0.0473 - val_mse: 0.0050 Epoch 14/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0045 - mae: 0.0432 - mse: 0.0045 - val_loss: 0.0046 - val_mae: 0.0453 - val_mse: 0.0046 Epoch 15/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0043 - mae: 0.0426 - mse: 0.0043 - val_loss: 0.0047 - val_mae: 0.0454 - val_mse: 0.0047 Epoch 16/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0043 - mae: 0.0422 - mse: 0.0043 - val_loss: 0.0049 - val_mae: 0.0444 - val_mse: 0.0049 Epoch 17/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0042 - mae: 0.0418 - mse: 0.0042 - val_loss: 0.0042 - val_mae: 0.0436 - val_mse: 0.0042 Epoch 18/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0041 - mae: 0.0408 - mse: 0.0041 - val_loss: 0.0047 - val_mae: 0.0460 - val_mse: 0.0047 Epoch 19/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0041 - mae: 0.0409 - mse: 0.0041 - val_loss: 0.0044 - val_mae: 0.0442 - val_mse: 0.0044 Epoch 20/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0040 - mae: 0.0409 - mse: 0.0040 - val_loss: 0.0044 - val_mae: 0.0461 - val_mse: 0.0044 Epoch 21/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0040 - mae: 0.0407 - mse: 0.0040 - val_loss: 0.0046 - val_mae: 0.0443 - val_mse: 0.0046 Epoch 22/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0038 - mae: 0.0398 - mse: 0.0038 - val_loss: 0.0044 - val_mae: 0.0436 - val_mse: 0.0044 Epoch 23/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0038 - mae: 0.0399 - mse: 0.0038 - val_loss: 0.0047 - val_mae: 0.0458 - val_mse: 0.0047 Epoch 24/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0037 - mae: 0.0398 - mse: 0.0037 - val_loss: 0.0042 - val_mae: 0.0428 - val_mse: 0.0042 Epoch 25/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0038 - mae: 0.0401 - mse: 0.0038 - val_loss: 0.0043 - val_mae: 0.0424 - val_mse: 0.0043 Epoch 26/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0036 - mae: 0.0393 - mse: 0.0036 - val_loss: 0.0041 - val_mae: 0.0437 - val_mse: 0.0041 Epoch 27/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0037 - mae: 0.0397 - mse: 0.0037 - val_loss: 0.0044 - val_mae: 0.0466 - val_mse: 0.0044 Epoch 28/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0035 - mae: 0.0388 - mse: 0.0035 - val_loss: 0.0046 - val_mae: 0.0464 - val_mse: 0.0046 Epoch 29/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0037 - mae: 0.0393 - mse: 0.0037 - val_loss: 0.0041 - val_mae: 0.0443 - val_mse: 0.0041 Epoch 30/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0036 - mae: 0.0394 - mse: 0.0036 - val_loss: 0.0042 - val_mae: 0.0448 - val_mse: 0.0042 Epoch 31/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0035 - mae: 0.0382 - mse: 0.0035 - val_loss: 0.0044 - val_mae: 0.0474 - val_mse: 0.0044 Epoch 32/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0034 - mae: 0.0381 - mse: 0.0034 - val_loss: 0.0043 - val_mae: 0.0454 - val_mse: 0.0043 Epoch 33/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0034 - mae: 0.0382 - mse: 0.0034 - val_loss: 0.0042 - val_mae: 0.0429 - val_mse: 0.0042 Epoch 34/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0035 - mae: 0.0383 - mse: 0.0035 - val_loss: 0.0044 - val_mae: 0.0468 - val_mse: 0.0044 Epoch 35/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0375 - mse: 0.0033 - val_loss: 0.0046 - val_mae: 0.0484 - val_mse: 0.0046 Epoch 36/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0375 - mse: 0.0033 - val_loss: 0.0043 - val_mae: 0.0474 - val_mse: 0.0043 Epoch 37/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0377 - mse: 0.0033 - val_loss: 0.0043 - val_mae: 0.0454 - val_mse: 0.0043 Epoch 38/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0375 - mse: 0.0033 - val_loss: 0.0045 - val_mae: 0.0487 - val_mse: 0.0045 Epoch 39/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0376 - mse: 0.0033 - val_loss: 0.0044 - val_mae: 0.0500 - val_mse: 0.0044 Epoch 40/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0032 - mae: 0.0369 - mse: 0.0032 - val_loss: 0.0045 - val_mae: 0.0497 - val_mse: 0.0045 Epoch 41/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0032 - mae: 0.0367 - mse: 0.0032 - val_loss: 0.0044 - val_mae: 0.0476 - val_mse: 0.0044 Epoch 42/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0031 - mae: 0.0367 - mse: 0.0031 - val_loss: 0.0041 - val_mae: 0.0453 - val_mse: 0.0041 Epoch 43/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0362 - mse: 0.0030 - val_loss: 0.0043 - val_mae: 0.0481 - val_mse: 0.0043 Epoch 44/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0032 - mae: 0.0364 - mse: 0.0032 - val_loss: 0.0045 - val_mae: 0.0497 - val_mse: 0.0045 Epoch 45/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0031 - mae: 0.0368 - mse: 0.0031 - val_loss: 0.0043 - val_mae: 0.0490 - val_mse: 0.0043 Epoch 46/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0362 - mse: 0.0030 - val_loss: 0.0042 - val_mae: 0.0469 - val_mse: 0.0042 Epoch 47/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0361 - mse: 0.0030 - val_loss: 0.0044 - val_mae: 0.0457 - val_mse: 0.0044 Epoch 48/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0031 - mae: 0.0361 - mse: 0.0031 - val_loss: 0.0046 - val_mae: 0.0503 - val_mse: 0.0046 Epoch 49/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0357 - mse: 0.0030 - val_loss: 0.0048 - val_mae: 0.0494 - val_mse: 0.0048 Epoch 50/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0359 - mse: 0.0030 - val_loss: 0.0043 - val_mae: 0.0480 - val_mse: 0.0043 Epoch 51/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0357 - mse: 0.0029 - val_loss: 0.0042 - val_mae: 0.0477 - val_mse: 0.0042 Epoch 52/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0350 - mse: 0.0028 - val_loss: 0.0044 - val_mae: 0.0485 - val_mse: 0.0044 Epoch 53/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0354 - mse: 0.0029 - val_loss: 0.0044 - val_mae: 0.0494 - val_mse: 0.0044 Epoch 54/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0352 - mse: 0.0029 - val_loss: 0.0043 - val_mae: 0.0487 - val_mse: 0.0043 Epoch 55/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0353 - mse: 0.0029 - val_loss: 0.0043 - val_mae: 0.0490 - val_mse: 0.0043 Epoch 56/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0351 - mse: 0.0028 - val_loss: 0.0045 - val_mae: 0.0482 - val_mse: 0.0045 Epoch 57/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0349 - mse: 0.0028 - val_loss: 0.0043 - val_mae: 0.0472 - val_mse: 0.0043 Epoch 58/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0342 - mse: 0.0028 - val_loss: 0.0044 - val_mae: 0.0492 - val_mse: 0.0044 Epoch 59/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0347 - mse: 0.0028 - val_loss: 0.0043 - val_mae: 0.0478 - val_mse: 0.0043 Epoch 60/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0347 - mse: 0.0028 - val_loss: 0.0047 - val_mae: 0.0490 - val_mse: 0.0047 Epoch 61/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0027 - mae: 0.0344 - mse: 0.0027 - val_loss: 0.0046 - val_mae: 0.0498 - val_mse: 0.0046 Epoch 62/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0027 - mae: 0.0344 - mse: 0.0027 - val_loss: 0.0042 - val_mae: 0.0453 - val_mse: 0.0042 y_pred = model.predict(X_test) err=mean_squared_error(y_pred,y_test) y_pred_ori = scaler.inverse_transform(y_pred) y_test_ori = scaler.inverse_transform(y_test) print(err) print(y_pred_ori[:10]) print(y_test_ori[:10]) 0.0034494638191476575 [[13.511538] [33.44774 ] [ 7.324512] [14.62247 ] [34.36278 ] [10.200519] [10.059496] [48.480953] [19.146278] [39.977325]] [[10.] [30.] [ 0.] [15.] [15.] [ 5.] [ 5.] [60.] [10.] [50.]] diff = y_test_ori - y_pred_ori plt.figure(figsize=(20, 10)) plt.plot(y_pred_ori, label=\"Prediction\") plt.plot(y_test_ori, label=\"True\") plt.plot(diff, label=\"Difference\") plt.legend() <matplotlib.legend.Legend at 0x7fc556415c50> Training on category \u00b6 in this case, we will pre-process the wait time into 3 different categories. [1, 0, 0]: Wait time < 30 mins [0, 1, 0]: Wait time >= 30 and <= 70 cat_vars = [ 'Name' , 'IsWeekend' , 'IsHoliday' , 'Hour modify' , 'Weather' ] num_vars = [ 'Temperature' , 'Pressure' , 'Humidity' , 'Cloud' , 'Wind degree' , ] X_train , X_test , y_train , y_test = generate_training_data ( train , 'Is busy' , cat_vars = cat_vars , num_vars = num_vars , should_reshape = False ) print ( y_train . shape ) print ( X_train . shape ) (14328, 3) (14328, 44) early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 512 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 256 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 128 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( y_train . shape [ 1 ], activation = 'softmax' ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 001 ) model . compile ( loss = 'categorical_crossentropy' , optimizer = opt , metrics = [ 'acc' , 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 1000 , callbacks =[ early_stop ] , validation_split = 0.2 ) plot_history ( history ) Epoch 1/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.5546 - acc: 0.7431 - mae: 0.2245 - mse: 0.1133 - val_loss: 0.4317 - val_acc: 0.7994 - val_mae: 0.1869 - val_mse: 0.0900 Epoch 2/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4437 - acc: 0.7988 - mae: 0.1824 - mse: 0.0921 - val_loss: 0.4212 - val_acc: 0.8022 - val_mae: 0.1744 - val_mse: 0.0887 Epoch 3/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4240 - acc: 0.8028 - mae: 0.1760 - mse: 0.0882 - val_loss: 0.4124 - val_acc: 0.8043 - val_mae: 0.1713 - val_mse: 0.0864 Epoch 4/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4135 - acc: 0.8074 - mae: 0.1714 - mse: 0.0863 - val_loss: 0.4075 - val_acc: 0.8105 - val_mae: 0.1645 - val_mse: 0.0852 Epoch 5/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4013 - acc: 0.8148 - mae: 0.1660 - mse: 0.0833 - val_loss: 0.4032 - val_acc: 0.8109 - val_mae: 0.1682 - val_mse: 0.0848 Epoch 6/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3940 - acc: 0.8207 - mae: 0.1639 - mse: 0.0822 - val_loss: 0.4187 - val_acc: 0.8088 - val_mae: 0.1786 - val_mse: 0.0875 Epoch 7/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3903 - acc: 0.8204 - mae: 0.1624 - mse: 0.0817 - val_loss: 0.3959 - val_acc: 0.8203 - val_mae: 0.1701 - val_mse: 0.0831 Epoch 8/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3835 - acc: 0.8234 - mae: 0.1600 - mse: 0.0802 - val_loss: 0.3960 - val_acc: 0.8193 - val_mae: 0.1700 - val_mse: 0.0826 Epoch 9/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3747 - acc: 0.8313 - mae: 0.1562 - mse: 0.0780 - val_loss: 0.3955 - val_acc: 0.8186 - val_mae: 0.1559 - val_mse: 0.0823 Epoch 10/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3755 - acc: 0.8276 - mae: 0.1563 - mse: 0.0786 - val_loss: 0.4090 - val_acc: 0.8095 - val_mae: 0.1621 - val_mse: 0.0848 Epoch 11/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3718 - acc: 0.8296 - mae: 0.1546 - mse: 0.0774 - val_loss: 0.3961 - val_acc: 0.8196 - val_mae: 0.1669 - val_mse: 0.0825 Epoch 12/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3659 - acc: 0.8309 - mae: 0.1536 - mse: 0.0767 - val_loss: 0.4028 - val_acc: 0.8217 - val_mae: 0.1540 - val_mse: 0.0824 Epoch 13/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3647 - acc: 0.8346 - mae: 0.1514 - mse: 0.0759 - val_loss: 0.3960 - val_acc: 0.8193 - val_mae: 0.1619 - val_mse: 0.0823 Epoch 14/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3583 - acc: 0.8377 - mae: 0.1489 - mse: 0.0747 - val_loss: 0.3950 - val_acc: 0.8147 - val_mae: 0.1618 - val_mse: 0.0821 Epoch 15/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3503 - acc: 0.8415 - mae: 0.1468 - mse: 0.0736 - val_loss: 0.4019 - val_acc: 0.8130 - val_mae: 0.1606 - val_mse: 0.0837 Epoch 16/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3512 - acc: 0.8398 - mae: 0.1465 - mse: 0.0736 - val_loss: 0.4124 - val_acc: 0.8112 - val_mae: 0.1595 - val_mse: 0.0842 Epoch 17/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3488 - acc: 0.8405 - mae: 0.1454 - mse: 0.0729 - val_loss: 0.4066 - val_acc: 0.8207 - val_mae: 0.1532 - val_mse: 0.0823 Epoch 18/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3427 - acc: 0.8445 - mae: 0.1431 - mse: 0.0718 - val_loss: 0.4032 - val_acc: 0.8203 - val_mae: 0.1567 - val_mse: 0.0825 Epoch 19/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3442 - acc: 0.8423 - mae: 0.1444 - mse: 0.0723 - val_loss: 0.4005 - val_acc: 0.8234 - val_mae: 0.1513 - val_mse: 0.0812 Epoch 20/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3360 - acc: 0.8475 - mae: 0.1403 - mse: 0.0703 - val_loss: 0.3930 - val_acc: 0.8182 - val_mae: 0.1561 - val_mse: 0.0808 Epoch 21/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3348 - acc: 0.8470 - mae: 0.1406 - mse: 0.0703 - val_loss: 0.3984 - val_acc: 0.8182 - val_mae: 0.1537 - val_mse: 0.0812 Epoch 22/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3310 - acc: 0.8518 - mae: 0.1389 - mse: 0.0692 - val_loss: 0.4146 - val_acc: 0.8238 - val_mae: 0.1465 - val_mse: 0.0832 Epoch 23/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3246 - acc: 0.8514 - mae: 0.1357 - mse: 0.0681 - val_loss: 0.3981 - val_acc: 0.8308 - val_mae: 0.1478 - val_mse: 0.0800 Epoch 24/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3264 - acc: 0.8516 - mae: 0.1363 - mse: 0.0682 - val_loss: 0.4086 - val_acc: 0.8179 - val_mae: 0.1469 - val_mse: 0.0821 Epoch 25/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3223 - acc: 0.8563 - mae: 0.1347 - mse: 0.0674 - val_loss: 0.4071 - val_acc: 0.8224 - val_mae: 0.1457 - val_mse: 0.0822 Epoch 26/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3190 - acc: 0.8553 - mae: 0.1328 - mse: 0.0667 - val_loss: 0.4065 - val_acc: 0.8290 - val_mae: 0.1471 - val_mse: 0.0809 Epoch 27/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3205 - acc: 0.8533 - mae: 0.1340 - mse: 0.0670 - val_loss: 0.3998 - val_acc: 0.8364 - val_mae: 0.1466 - val_mse: 0.0800 Epoch 28/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3160 - acc: 0.8546 - mae: 0.1320 - mse: 0.0659 - val_loss: 0.4039 - val_acc: 0.8276 - val_mae: 0.1434 - val_mse: 0.0807 Epoch 29/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3099 - acc: 0.8619 - mae: 0.1297 - mse: 0.0649 - val_loss: 0.3998 - val_acc: 0.8280 - val_mae: 0.1435 - val_mse: 0.0797 Epoch 30/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3078 - acc: 0.8604 - mae: 0.1285 - mse: 0.0646 - val_loss: 0.4172 - val_acc: 0.8266 - val_mae: 0.1434 - val_mse: 0.0810 Epoch 31/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3057 - acc: 0.8630 - mae: 0.1274 - mse: 0.0637 - val_loss: 0.4027 - val_acc: 0.8276 - val_mae: 0.1420 - val_mse: 0.0794 Epoch 32/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3005 - acc: 0.8640 - mae: 0.1253 - mse: 0.0630 - val_loss: 0.3986 - val_acc: 0.8266 - val_mae: 0.1465 - val_mse: 0.0790 Epoch 33/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2978 - acc: 0.8642 - mae: 0.1249 - mse: 0.0625 - val_loss: 0.4192 - val_acc: 0.8234 - val_mae: 0.1469 - val_mse: 0.0817 Epoch 34/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2943 - acc: 0.8639 - mae: 0.1235 - mse: 0.0617 - val_loss: 0.4238 - val_acc: 0.8290 - val_mae: 0.1377 - val_mse: 0.0801 Epoch 35/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2938 - acc: 0.8657 - mae: 0.1230 - mse: 0.0618 - val_loss: 0.4144 - val_acc: 0.8283 - val_mae: 0.1441 - val_mse: 0.0796 Epoch 36/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2919 - acc: 0.8666 - mae: 0.1227 - mse: 0.0613 - val_loss: 0.4113 - val_acc: 0.8346 - val_mae: 0.1364 - val_mse: 0.0773 Epoch 37/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2833 - acc: 0.8712 - mae: 0.1184 - mse: 0.0592 - val_loss: 0.4232 - val_acc: 0.8266 - val_mae: 0.1421 - val_mse: 0.0793 Epoch 38/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.2881 - acc: 0.8700 - mae: 0.1211 - mse: 0.0605 - val_loss: 0.4121 - val_acc: 0.8308 - val_mae: 0.1391 - val_mse: 0.0784 Epoch 39/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.2818 - acc: 0.8725 - mae: 0.1175 - mse: 0.0590 - val_loss: 0.4214 - val_acc: 0.8276 - val_mae: 0.1374 - val_mse: 0.0793 Epoch 40/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.2823 - acc: 0.8699 - mae: 0.1183 - mse: 0.0595 - val_loss: 0.4076 - val_acc: 0.8301 - val_mae: 0.1427 - val_mse: 0.0791 y_pred = model . predict ( X_test ) def print_acc ( pred , true ) : right = 0 for i in range ( len ( pred )) : p = np . argmax ( pred [ i ] ) t = np . argmax ( true [ i ] ) if p == t : right += 1 print ( f \"acc: {right}/{len(pred)}, {right/len(pred)}\" ) print_acc ( y_pred , y_test ) acc: 242/293, 0.825938566552901 Training by using category \u00b6 In this example, we will use average-wait-time to compute their waiting time's category If wait-time is less than the average-wait time of that facility, then it is not busy. If wait-time is around average wait-time, then it is in a normal situation If wait-time is above average-wait-time, then it is busy. In this model, we are basically assume facilities are different. Some will have more popularity than others. And we will use the model to predict whether a model is above its average or not. def is_busy_2 ( row ): if row [ 3 ] < row [ 1 ] - 5 : return [ 1 , 0 , 0 ] elif row [ 3 ] >= row [ 1 ] - 5 and row [ 3 ] <= row [ 1 ] + 5 : return [ 0 , 1 , 0 ] else : return [ 0 , 0 , 1 ] def calculate_average_wait_time ( df : pd . DataFrame ) -> pd . DataFrame : new_df = df . copy () new_df2 = df . copy () new_df [ 'tmp_date' ] = new_df [ 'Time' ]. apply ( lambda x : x . date ()) new_df = new_df [[ 'tmp_date' , 'Wait time' , 'Name' ]] new_df = new_df . groupby ([ 'Name' ]). mean () new_df = new_df . rename ( columns = { 'Wait time' : 'Average wait time' } ) new_df = new_df . merge ( new_df2 , on = 'Name' , how = 'right' ) return new_df average_sampled_train = calculate_average_wait_time ( train ) average_sampled_train [ 'Is busy' ] = average_sampled_train . apply ( is_busy_2 , axis = 1 ) average_sampled_train . sample ( 20 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Average wait time Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud id IsWeekend IsHoliday Hour modify Is busy 13204 Slinky Dog Spin 24.613601 2020-09-27 15:19:38.869181 40.0 Clouds 24.82 26.11 26.11 1015 78 40.0 5.0 75 29 1 1 Afternoon [0, 0, 1] 3335 Hunny Pot Spin 9.258114 2020-10-09 13:20:34.934157 10.0 Clouds 24.59 25.00 25.00 1020 44 20.0 5.0 16 7 0 0 Afternoon [0, 1, 0] 10658 Shipwreck Shore 5.008681 2020-10-17 11:22:39.121594 5.0 Clear 20.34 21.00 21.00 1024 56 360.0 6.0 0 19 1 0 Morning [0, 1, 0] 2160 \u201cOnce Upon a Time\u201d Adventure 7.246127 2020-10-11 11:21:48.801419 5.0 Clouds 23.34 23.89 23.89 1016 56 40.0 4.0 40 4 1 1 Morning [0, 1, 0] 11860 Roaring Rapids 31.629555 2020-09-10 10:20:16.261789 20.0 Clouds 31.39 32.78 32.78 1008 62 160.0 4.0 76 23 0 0 Morning [1, 0, 0] 2992 Hunny Pot Spin 9.258114 2020-09-11 15:18:17.428365 5.0 Clouds 23.95 25.00 25.00 1008 83 110.0 4.0 90 7 0 0 Afternoon [0, 1, 0] 11075 Pirates of the Caribbean Battle for the Sunken... 20.969055 2020-10-02 10:22:38.662643 40.0 Clouds 26.25 26.67 26.67 1014 65 140.0 4.0 20 20 0 1 Morning [0, 0, 1] 11169 Pirates of the Caribbean Battle for the Sunken... 20.969055 2020-10-09 12:24:19.516068 15.0 Clouds 24.09 25.00 25.00 1021 47 360.0 6.0 20 20 0 0 Afternoon [1, 0, 0] 8079 Stitch Encounter 15.070565 2020-10-03 17:19:47.471647 15.0 Clouds 23.73 24.00 24.00 1012 78 90.0 6.0 75 15 1 1 Evening [0, 1, 0] 2482 Alice in Wonderland Maze 5.017730 2020-09-18 09:25:01.995252 5.0 Rain 19.62 20.00 20.00 1018 82 330.0 4.0 100 5 0 0 Morning [0, 1, 0] 5505 Voyage to the Crystal Grotto 17.301459 2020-09-15 15:18:48.496307 10.0 Rain 23.03 23.33 23.33 1010 94 150.0 3.0 40 11 0 0 Afternoon [1, 0, 0] 8430 Jet Packs 34.943639 2020-09-14 18:19:06.567386 40.0 Rain 22.65 23.00 23.00 1013 94 220.0 3.0 75 16 0 0 Evening [0, 0, 1] 11374 Explorer Canoes 26.490385 2020-09-05 09:33:30.360833 5.0 Clear 31.06 34.44 34.44 1011 58 90.0 2.0 0 21 1 0 Morning [1, 0, 0] 9856 Siren's Revenge 5.000000 2020-10-01 09:33:02.313813 5.0 Clouds 25.68 28.89 28.89 1015 69 20.0 4.0 17 18 0 1 Morning [0, 1, 0] 6244 Dumbo the Flying Elephant 24.476950 2020-09-28 12:21:14.161007 5.0 Clouds 26.75 27.22 27.22 1015 61 100.0 5.0 40 12 0 0 Afternoon [1, 0, 0] 12970 Slinky Dog Spin 24.613601 2020-09-07 13:17:55.833556 30.0 Clouds 33.90 36.11 36.11 1005 41 310.0 8.0 20 29 0 0 Afternoon [0, 0, 1] 10944 Pirates of the Caribbean Battle for the Sunken... 20.969055 2020-09-21 15:19:21.264789 50.0 Clouds 27.00 27.78 27.78 1015 50 120.0 4.0 100 20 0 0 Afternoon [0, 0, 1] 9653 Siren's Revenge 5.000000 2020-09-14 12:20:05.878090 5.0 Clouds 27.49 29.44 29.44 1014 69 80.0 3.0 40 18 0 0 Afternoon [0, 1, 0] 13795 Woody\u2019s Roundup 17.469040 2020-09-23 08:54:36.402435 5.0 Rain 21.58 22.00 22.00 1014 78 70.0 3.0 20 30 0 0 Morning [1, 0, 0] 4720 The Many Adventures of Winnie the Pooh 21.727129 2020-09-01 15:18:22.137361 25.0 Clouds 31.26 33.33 33.33 1003 79 20.0 8.0 40 10 0 0 Afternoon [0, 1, 0] cat_vars = [ 'Name' , 'IsWeekend' , 'IsHoliday' , 'Hour modify' , 'Weather' ] num_vars = [ 'Temperature' , 'Pressure' , 'Humidity' , 'Cloud' , 'Wind degree' , ] X_train , X_test , y_train , y_test = generate_training_data ( average_sampled_train , 'Is busy' , cat_vars = cat_vars , num_vars = num_vars , should_reshape = False ) early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 512 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 256 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), # layers . Dense ( 512 , activation = \"relu\" , # input_shape = ( X_train . shape [ 1 ],),), # layers . Dropout ( 0 . 5 ), # layers . Dense ( 512 , activation = \"relu\" , # input_shape = ( X_train . shape [ 1 ],),), # layers . Dropout ( 0 . 5 ), # layers . Dense ( 256 , activation = \"relu\" , # input_shape = ( X_train . shape [ 1 ],),), # layers . Dropout ( 0 . 5 ), layers . Dense ( 128 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( y_train . shape [ 1 ], activation = 'softmax' ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 001 ) model . compile ( loss = 'categorical_crossentropy' , optimizer = opt , metrics = [ 'acc' , 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 1000 , callbacks =[ early_stop ] , validation_split = 0.2 ) plot_history ( history ) Epoch 1/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.5560 - acc: 0.7499 - mae: 0.2245 - mse: 0.1130 - val_loss: 0.4329 - val_acc: 0.8015 - val_mae: 0.1843 - val_mse: 0.0902 Epoch 2/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4433 - acc: 0.7959 - mae: 0.1820 - mse: 0.0920 - val_loss: 0.4151 - val_acc: 0.8067 - val_mae: 0.1757 - val_mse: 0.0866 Epoch 3/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4232 - acc: 0.8022 - mae: 0.1752 - mse: 0.0880 - val_loss: 0.4095 - val_acc: 0.8109 - val_mae: 0.1765 - val_mse: 0.0859 Epoch 4/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4081 - acc: 0.8121 - mae: 0.1698 - mse: 0.0854 - val_loss: 0.4097 - val_acc: 0.8088 - val_mae: 0.1752 - val_mse: 0.0867 Epoch 5/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4027 - acc: 0.8150 - mae: 0.1678 - mse: 0.0841 - val_loss: 0.4027 - val_acc: 0.8088 - val_mae: 0.1684 - val_mse: 0.0848 Epoch 6/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3913 - acc: 0.8211 - mae: 0.1625 - mse: 0.0814 - val_loss: 0.4224 - val_acc: 0.8060 - val_mae: 0.1577 - val_mse: 0.0876 Epoch 7/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3868 - acc: 0.8226 - mae: 0.1601 - mse: 0.0804 - val_loss: 0.4104 - val_acc: 0.8095 - val_mae: 0.1632 - val_mse: 0.0859 Epoch 8/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3827 - acc: 0.8282 - mae: 0.1591 - mse: 0.0798 - val_loss: 0.3976 - val_acc: 0.8189 - val_mae: 0.1629 - val_mse: 0.0830 Epoch 9/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3804 - acc: 0.8265 - mae: 0.1573 - mse: 0.0790 - val_loss: 0.4111 - val_acc: 0.8161 - val_mae: 0.1724 - val_mse: 0.0856 Epoch 10/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3731 - acc: 0.8307 - mae: 0.1562 - mse: 0.0778 - val_loss: 0.3961 - val_acc: 0.8196 - val_mae: 0.1573 - val_mse: 0.0822 Epoch 11/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3666 - acc: 0.8340 - mae: 0.1528 - mse: 0.0766 - val_loss: 0.3932 - val_acc: 0.8255 - val_mae: 0.1613 - val_mse: 0.0819 Epoch 12/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3592 - acc: 0.8368 - mae: 0.1504 - mse: 0.0753 - val_loss: 0.3989 - val_acc: 0.8214 - val_mae: 0.1580 - val_mse: 0.0827 Epoch 13/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3579 - acc: 0.8361 - mae: 0.1497 - mse: 0.0750 - val_loss: 0.3955 - val_acc: 0.8116 - val_mae: 0.1612 - val_mse: 0.0824 Epoch 14/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3529 - acc: 0.8394 - mae: 0.1473 - mse: 0.0736 - val_loss: 0.3990 - val_acc: 0.8231 - val_mae: 0.1555 - val_mse: 0.0819 Epoch 15/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3467 - acc: 0.8395 - mae: 0.1454 - mse: 0.0728 - val_loss: 0.3990 - val_acc: 0.8214 - val_mae: 0.1546 - val_mse: 0.0816 Epoch 16/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3441 - acc: 0.8411 - mae: 0.1444 - mse: 0.0723 - val_loss: 0.4026 - val_acc: 0.8259 - val_mae: 0.1527 - val_mse: 0.0826 Epoch 17/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3388 - acc: 0.8431 - mae: 0.1415 - mse: 0.0711 - val_loss: 0.3967 - val_acc: 0.8280 - val_mae: 0.1520 - val_mse: 0.0811 Epoch 18/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3365 - acc: 0.8462 - mae: 0.1407 - mse: 0.0706 - val_loss: 0.3928 - val_acc: 0.8276 - val_mae: 0.1513 - val_mse: 0.0803 Epoch 19/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3321 - acc: 0.8478 - mae: 0.1398 - mse: 0.0699 - val_loss: 0.3967 - val_acc: 0.8294 - val_mae: 0.1477 - val_mse: 0.0793 Epoch 20/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3280 - acc: 0.8515 - mae: 0.1375 - mse: 0.0688 - val_loss: 0.3941 - val_acc: 0.8224 - val_mae: 0.1525 - val_mse: 0.0806 Epoch 21/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3300 - acc: 0.8522 - mae: 0.1374 - mse: 0.0688 - val_loss: 0.4066 - val_acc: 0.8172 - val_mae: 0.1503 - val_mse: 0.0821 Epoch 22/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3231 - acc: 0.8524 - mae: 0.1357 - mse: 0.0680 - val_loss: 0.4023 - val_acc: 0.8276 - val_mae: 0.1472 - val_mse: 0.0798 Epoch 23/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3166 - acc: 0.8556 - mae: 0.1323 - mse: 0.0665 - val_loss: 0.4084 - val_acc: 0.8273 - val_mae: 0.1496 - val_mse: 0.0812 Epoch 24/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3175 - acc: 0.8540 - mae: 0.1329 - mse: 0.0663 - val_loss: 0.3956 - val_acc: 0.8297 - val_mae: 0.1491 - val_mse: 0.0797 Epoch 25/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3123 - acc: 0.8586 - mae: 0.1305 - mse: 0.0655 - val_loss: 0.4043 - val_acc: 0.8276 - val_mae: 0.1482 - val_mse: 0.0795 Epoch 26/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3091 - acc: 0.8573 - mae: 0.1297 - mse: 0.0649 - val_loss: 0.3939 - val_acc: 0.8241 - val_mae: 0.1483 - val_mse: 0.0792 Epoch 27/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3100 - acc: 0.8585 - mae: 0.1301 - mse: 0.0653 - val_loss: 0.4059 - val_acc: 0.8294 - val_mae: 0.1441 - val_mse: 0.0791 Epoch 28/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3055 - acc: 0.8619 - mae: 0.1278 - mse: 0.0640 - val_loss: 0.3913 - val_acc: 0.8343 - val_mae: 0.1512 - val_mse: 0.0786 Epoch 29/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3037 - acc: 0.8611 - mae: 0.1271 - mse: 0.0638 - val_loss: 0.4044 - val_acc: 0.8255 - val_mae: 0.1527 - val_mse: 0.0803 Epoch 30/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2993 - acc: 0.8638 - mae: 0.1255 - mse: 0.0629 - val_loss: 0.4006 - val_acc: 0.8332 - val_mae: 0.1471 - val_mse: 0.0788 Epoch 31/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2965 - acc: 0.8647 - mae: 0.1250 - mse: 0.0625 - val_loss: 0.4140 - val_acc: 0.8294 - val_mae: 0.1467 - val_mse: 0.0794 Epoch 32/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2930 - acc: 0.8647 - mae: 0.1241 - mse: 0.0619 - val_loss: 0.4159 - val_acc: 0.8308 - val_mae: 0.1399 - val_mse: 0.0788 Epoch 33/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2914 - acc: 0.8653 - mae: 0.1220 - mse: 0.0612 - val_loss: 0.4206 - val_acc: 0.8297 - val_mae: 0.1385 - val_mse: 0.0798 Epoch 34/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2868 - acc: 0.8706 - mae: 0.1204 - mse: 0.0604 - val_loss: 0.4048 - val_acc: 0.8276 - val_mae: 0.1444 - val_mse: 0.0785 Epoch 35/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2856 - acc: 0.8694 - mae: 0.1195 - mse: 0.0600 - val_loss: 0.4113 - val_acc: 0.8283 - val_mae: 0.1472 - val_mse: 0.0804 Epoch 36/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2861 - acc: 0.8684 - mae: 0.1204 - mse: 0.0600 - val_loss: 0.4227 - val_acc: 0.8262 - val_mae: 0.1464 - val_mse: 0.0812 Epoch 37/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2850 - acc: 0.8706 - mae: 0.1189 - mse: 0.0598 - val_loss: 0.4118 - val_acc: 0.8308 - val_mae: 0.1438 - val_mse: 0.0796 Epoch 38/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2803 - acc: 0.8720 - mae: 0.1183 - mse: 0.0590 - val_loss: 0.4339 - val_acc: 0.8308 - val_mae: 0.1367 - val_mse: 0.0813 Epoch 39/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2796 - acc: 0.8711 - mae: 0.1172 - mse: 0.0587 - val_loss: 0.4278 - val_acc: 0.8308 - val_mae: 0.1429 - val_mse: 0.0805 Epoch 40/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2711 - acc: 0.8744 - mae: 0.1147 - mse: 0.0575 - val_loss: 0.4283 - val_acc: 0.8276 - val_mae: 0.1402 - val_mse: 0.0801 Epoch 41/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2711 - acc: 0.8772 - mae: 0.1143 - mse: 0.0573 - val_loss: 0.4336 - val_acc: 0.8322 - val_mae: 0.1364 - val_mse: 0.0795 Epoch 42/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2716 - acc: 0.8778 - mae: 0.1139 - mse: 0.0570 - val_loss: 0.4327 - val_acc: 0.8252 - val_mae: 0.1399 - val_mse: 0.0813 Epoch 43/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2719 - acc: 0.8727 - mae: 0.1145 - mse: 0.0575 - val_loss: 0.4356 - val_acc: 0.8238 - val_mae: 0.1374 - val_mse: 0.0810 Epoch 44/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2691 - acc: 0.8774 - mae: 0.1129 - mse: 0.0567 - val_loss: 0.4334 - val_acc: 0.8304 - val_mae: 0.1400 - val_mse: 0.0800 Epoch 45/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2631 - acc: 0.8764 - mae: 0.1111 - mse: 0.0556 - val_loss: 0.4259 - val_acc: 0.8339 - val_mae: 0.1392 - val_mse: 0.0792 Epoch 46/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2641 - acc: 0.8791 - mae: 0.1112 - mse: 0.0558 - val_loss: 0.4243 - val_acc: 0.8318 - val_mae: 0.1392 - val_mse: 0.0791 Epoch 47/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2581 - acc: 0.8801 - mae: 0.1085 - mse: 0.0543 - val_loss: 0.4502 - val_acc: 0.8301 - val_mae: 0.1344 - val_mse: 0.0787 Epoch 48/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2622 - acc: 0.8815 - mae: 0.1098 - mse: 0.0551 - val_loss: 0.4314 - val_acc: 0.8371 - val_mae: 0.1367 - val_mse: 0.0779 y_pred = model . predict ( X_test ) print_acc ( y_pred , y_test ) acc: 243/293, 0.8293515358361775 LSTM Training \u00b6 Window generator \u00b6 To make a single prediction 24h into the future, given 24h of history you might define a window like this: class WindowGenerator () : def __init__ ( self , input_width , offset , data , train_split ) : self . data = data self . input_width = input_width self . offset = offset self . train_split = train_split def to_sequences ( self ) : \"\"\" Return both data and label \"\"\" data_len = len ( self . data ) ret = [] ret_label = [] for i in range ( data_len - self . offset - self . input_width + 1 ) : tmp = self . data [ i : i + self . input_width ] tmp_label = self . data [ i + self . input_width + self . offset - 1 ] ret . append ( tmp ) ret_label . append ([ tmp_label ]) return np . array ( ret ), np . array ( ret_label ) def split ( self ) : x , y = self . to_sequences () num_train = int ( self . train_split * x . shape [ 0 ]) X_train = x [ : num_train ] y_train = y [ : num_train ] X_test = x [ num_train :] y_test = y [ num_train :] return X_train , y_train , X_test , y_test # [1, 2, 3] wg = WindowGenerator(data=np.array(range(100)), input_width=4, offset=0, train_split=0.1) X_train, y_train, X_test, y_test = wg.split() [[ 0 1 2 3] [ 1 2 3 4] [ 2 3 4 5] [ 3 4 5 6] [ 4 5 6 7] [ 5 6 7 8] [ 6 7 8 9] [ 7 8 9 10] [ 8 9 10 11]] [[ 3] [ 4] [ 5] [ 6] [ 7] [ 8] [ 9] [10] [11]]","title":"Group project"},{"location":"MSBD5001/project/Group%20Project/#preprocess-data","text":"train = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/group project/disney_shanghai.csv' , parse_dates = [ 'Time' ]) test = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/group project/disney_shanghai_test.csv' , names = [ 'Time' , 'Facility ID' , 'Name' , 'Wait time' , 'Ride yype' , 'Temperature' , 'Max temperature' , 'Min temperature' , 'Humidity' , 'Pressure' , 'Wind degree' , 'Wind speed' , 'Cloud' , 'Weather' , 'Weather description' ], parse_dates = [ 'Time' ]) print ( train . info ()) print ( test . info ()) <class 'pandas.core.frame.DataFrame'> RangeIndex: 32024 entries, 0 to 32023 Data columns (total 17 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Name 32024 non-null object 1 Ride type 32024 non-null object 2 Time 32024 non-null datetime64[ns, pytz.FixedOffset(480)] 3 Fastpass-avaliable 32024 non-null bool 4 Status 32024 non-null object 5 Wait time 14621 non-null float64 6 Weather 32024 non-null object 7 Weather description 32024 non-null object 8 Temperature 32024 non-null float64 9 Max temperature 32024 non-null float64 10 Min temperature 32024 non-null float64 11 Pressure 32024 non-null int64 12 Humidity 32024 non-null int64 13 Wind degree 32024 non-null float64 14 Wind speed 32024 non-null float64 15 Cloud 32024 non-null int64 16 Visibility 32024 non-null int64 dtypes: bool(1), datetime64[ns, pytz.FixedOffset(480)](1), float64(6), int64(4), object(5) memory usage: 3.9+ MB None <class 'pandas.core.frame.DataFrame'> RangeIndex: 10449 entries, 0 to 10448 Data columns (total 15 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Time 10449 non-null datetime64[ns, UTC] 1 Facility ID 10449 non-null object 2 Name 10449 non-null object 3 Wait time 4016 non-null float64 4 Ride yype 10449 non-null object 5 Temperature 10449 non-null int64 6 Max temperature 10449 non-null float64 7 Min temperature 10449 non-null float64 8 Humidity 10449 non-null int64 9 Pressure 10449 non-null int64 10 Wind degree 10449 non-null int64 11 Wind speed 10449 non-null float64 12 Cloud 10449 non-null int64 13 Weather 10449 non-null object 14 Weather description 10449 non-null object dtypes: datetime64[ns, UTC](1), float64(4), int64(5), object(5) memory usage: 1.2+ MB None show data train = train[['Name', 'Time', 'Wait time', 'Weather', 'Temperature', 'Max temperature', 'Min temperature', 'Pressure', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud']] train.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud 0 Camp Discovery 2020-08-31 13:38:47.638019+08:00 0.0 Clouds 33.28 34.0 34.0 1009 66 110.0 5.0 75 1 Challenge Trails at Camp Discovery 2020-08-31 13:38:47.638035+08:00 10.0 Clouds 33.28 34.0 34.0 1009 66 110.0 5.0 75 show test test = test[['Name', 'Time', 'Wait time', 'Weather', 'Temperature', 'Max temperature', 'Min temperature', 'Pressure', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud']] test.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud 0 Challenge Trails at Camp Discovery 2020-11-14 10:07:34+00:00 30.0 Clouds 18 18.0 18.0 1026 68 70 3.0 20 1 Vista Trail at Camp Discovery 2020-11-14 10:07:34+00:00 0.0 Clouds 18 18.0 18.0 1026 68 70 3.0 20","title":"Preprocess Data"},{"location":"MSBD5001/project/Group%20Project/#change-name-into-values","text":"unique_names = train[['Name']].drop_duplicates() unique_names['id'] = range(len(unique_names)) train = train.merge(unique_names, on='Name') unique_names .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name id 0 Camp Discovery 0 1 Challenge Trails at Camp Discovery 1 2 Vista Trail at Camp Discovery 2 3 Soaring Over the Horizon 3 4 \u201cOnce Upon a Time\u201d Adventure 4 5 Alice in Wonderland Maze 5 6 Frozen: A Sing-Along Celebration 6 7 Hunny Pot Spin 7 8 Peter Pan\u2019s Flight 8 9 Seven Dwarfs Mine Train 9 10 The Many Adventures of Winnie the Pooh 10 11 Voyage to the Crystal Grotto 11 12 Dumbo the Flying Elephant 12 13 Fantasia Carousel 13 14 TRON Lightcycle Power Run \u2013 Presented by Chevr... 14 15 Stitch Encounter 15 16 Jet Packs 16 17 Buzz Lightyear Planet Rescue 17 18 Siren's Revenge 18 19 Shipwreck Shore 19 20 Pirates of the Caribbean Battle for the Sunken... 20 21 Explorer Canoes 21 22 Eye of the Storm: Captain Jack\u2019s Stunt Spectac... 22 23 Roaring Rapids 23 24 Ignite the Dream - A Nighttime Spectacular of ... 24 25 Mickey\u2019s Storybook Express 25 26 Golden Fairytale Fanfare 26 27 TRON Realm, Chevrolet Digital Challenge 27 28 Rex\u2019s Racer 28 29 Slinky Dog Spin 29 30 Woody\u2019s Roundup 30 31 Marvel Universe 31 32 Club Destin-E 32 33 Color Wall 33 34 Avengers Training Initiative 34 35 Wave Hello to Your Favorite Mickey Avenue Char... 35 36 Mickey Avenue Kiss Goodnight 36 37 Adventurous Friends Exploration 37 38 Catch a Glimpse of Jack Sparrow 38 39 Hundred Acre Wood Character Sighting 39 40 Princess Balcony Greetings 40 41 Avengers Assemble at the E-Stage 41 42 Woody\u2019s Rescue Patrol 42","title":"Change name into values"},{"location":"MSBD5001/project/Group%20Project/#dropna","text":"train = train.dropna() test = test.dropna()","title":"Dropna"},{"location":"MSBD5001/project/Group%20Project/#add-busy-label","text":"def is_busy(time: int): if time < 30: return [1, 0, 0] elif time >= 30 and time <= 70: return [0, 1, 0] else: return [0, 0, 1]","title":"Add busy label"},{"location":"MSBD5001/project/Group%20Project/#add-weekend-and-public-holiday","text":"def hour_modify ( x : datetime ) : Early_Morning = [ 4,5,6,7 ] Morning = [ 8,9,10,11 ] Afternoon = [ 12,13,14,15 ] Evening = [ 16,17,18,19 ] Night = [ 20,21,22,23 ] Late_Night = [ 0,1,2,3 ] if x . hour in Early_Morning : return 'Early_Morning' elif x . hour in Morning : return 'Morning' elif x . hour in Afternoon : return 'Afternoon' elif x . hour in Evening : return 'Evening' elif x . hour in Night : return 'Night' else : return 'Late_Night' def add_holiday_and_weekend ( df : pd . DataFrame , date_field_str = 'date' ) -> pd . DataFrame : \"\"\" Add holiday and weekend to the dataset \"\"\" new_df = df . copy () new_df [ 'IsWeekend' ] = new_df [ date_field_str ] . apply ( lambda x : 0 if x . weekday () in [ 0,1,2,3,4 ] else 1 ) new_df [ 'IsHoliday' ]= new_df [ date_field_str ] . apply ( lambda x : 1 if ( x . date (). strftime ( '%Y-%m-%d' ) in [ '2020-01-01', '2020-01-24', '2020-01-24', '2020-01-25', '2020-01-26', '2020-01-27', '2020-01-28', '2020-01-29', '2020-01-30', '2020-01-31', '2020-02-01', '2020-02-02', '2020-04-04', '2020-05-01', '2020-05-02', '2020-05-03', '2020-05-04', '2020-05-05', '2020-06-25', '2020-06-26', '2020-06-27', '2020-10-01', '2020-10-02', '2020-10-03', '2020-10-04', '2020-10-05', '2020-10-06', '2020-10-07', '2020-10-08', '2020-10-31' ] ) or ( x . weekday () in [ 6 ] ) else 0 ) return new_df convert time zone train [ 'Time' ] = train [ 'Time' ]. dt . tz_localize ( None ) print ( train [ 'Time' ]) 0 2020-08-31 13:38:47.638019 1 2020-08-31 14:09:47.630487 2 2020-08-31 14:26:10.487907 3 2020-08-31 14:29:48.273505 4 2020-08-31 15:09:11.331162 ... 23808 2020-10-24 15:23:47.123270 23809 2020-10-24 16:25:44.947592 23810 2020-10-24 17:23:16.431926 23816 2020-10-25 10:26:28.625480 23817 2020-10-25 11:24:10.125045 Name: Time, Length: 14621, dtype: datetime64[ns] test['Time'] = test['Time'].dt.tz_convert(\"Asia/Shanghai\").dt.tz_localize(None) print(test['Time']) 0 2020-11-14 18:07:34 1 2020-11-14 18:07:34 2 2020-11-14 18:07:34 3 2020-11-14 18:07:34 4 2020-11-14 18:07:34 ... 10340 2020-12-01 19:07:47 10348 2020-12-01 19:07:47 10349 2020-12-01 19:07:47 10350 2020-12-01 19:07:47 10351 2020-12-01 19:07:47 Name: Time, Length: 4016, dtype: datetime64[ns] Add public holidays train = add_holiday_and_weekend ( train , 'Time' ) test = add_holiday_and_weekend ( test , 'Time' ) train [ 'Hour modify' ] = train [ 'Time' ]. apply ( hour_modify ) test [ 'Hour modify' ] = test [ 'Time' ]. apply ( hour_modify ) train [ 'Is busy' ] = train [ 'Wait time' ]. apply ( is_busy ) train . head ( 3 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud id IsWeekend IsHoliday Hour modify Is busy 0 Camp Discovery 2020-08-31 13:38:47.638019 0.0 Clouds 33.28 34.00 34.00 1009 66 110.0 5.0 75 0 0 0 Afternoon [1, 0, 0] 1 Camp Discovery 2020-08-31 14:09:47.630487 0.0 Clouds 33.80 35.56 35.56 1008 70 110.0 5.0 75 0 0 0 Afternoon [1, 0, 0] 2 Camp Discovery 2020-08-31 14:26:10.487907 0.0 Clouds 34.11 35.56 35.56 1008 66 110.0 6.0 75 0 0 0 Afternoon [1, 0, 0]","title":"Add weekend and public holiday"},{"location":"MSBD5001/project/Group%20Project/#plot-data","text":"plt.figure(figsize=(6,4)) sns.boxplot('Wait time',data=train,orient='h',palette=\"Set3\",linewidth=2.5) plt.show() /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variable as a keyword arg: x. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. FutureWarning train[['Wait time', 'Temperature', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud']].describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Wait time Temperature Humidity Wind degree Wind speed Cloud count 14621.000000 14621.000000 14621.000000 14621.000000 14621.000000 14621.000000 mean 23.616374 24.423189 64.933862 127.520347 5.352968 45.041174 std 26.388862 4.075267 14.270916 119.544200 1.962247 31.870902 min 0.000000 14.800000 33.000000 0.000000 0.450000 0.000000 25% 5.000000 21.570000 56.000000 30.000000 4.000000 20.000000 50% 15.000000 23.930000 61.000000 70.000000 5.000000 40.000000 75% 30.000000 26.900000 74.000000 180.000000 7.000000 75.000000 max 195.000000 35.050000 100.000000 360.000000 11.000000 100.000000","title":"Plot Data"},{"location":"MSBD5001/project/Group%20Project/#train","text":"train.columns Index(['Name', 'Time', 'Wait time', 'Weather', 'Temperature', 'Max temperature', 'Min temperature', 'Pressure', 'Humidity', 'Wind degree', 'Wind speed', 'Cloud', 'id', 'IsWeekend', 'IsHoliday', 'Hour modify', 'Is busy'], dtype='object') def plot_history ( history ) : hist = pd . DataFrame ( history . history ) hist [ 'epoch' ] = history . epoch plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Abs Error [MPG]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mae' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mae' ] , label = 'Val Error' ) plt . legend () plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Square Error [$MPG^2$]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mse' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mse' ] , label = 'Val Error' ) plt . legend () plt . show () def generate_training_data ( data : pd . DataFrame , prediction_label , cat_vars =[ 'id', 'IsWeekend','IsHoliday','Hour modify', 'Weather' ] , num_vars =[ 'Temperature', 'Pressure', 'Humidity', 'Cloud', 'Wind degree' ] , should_reshape = True ) : x = train . copy () y = x [ prediction_label ] . to_list () y = np . array ( y ) numeric_transformer = Pipeline ( steps =[ ('scaler', MinMaxScaler()) ] ) categorical_transformer = Pipeline ( steps =[ ('oneHot',OneHotEncoder(sparse=False)) ] ) preprocessor = ColumnTransformer ( transformers =[ ('num',numeric_transformer,num_vars), ('cat',categorical_transformer,cat_vars) ] ) data_transformed = preprocessor . fit_transform ( x ) if should_reshape : y = y . reshape ( - 1 , 1 ) scaler = MinMaxScaler () scaled_y = scaler . fit_transform ( y ) return train_test_split ( data_transformed , scaled_y , test_size = 0.02 , random_state = 42 ), scaler else : return train_test_split ( data_transformed , y , test_size = 0.02 , random_state = 42 ) data, scaler=generate_training_data(train, 'Wait time') X_train,X_test,y_train,y_test = data print(y_train.shape) print(X_train.shape) (14328, 1) (14328, 44)","title":"Train"},{"location":"MSBD5001/project/Group%20Project/#training-by-using-dnn","text":"early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 512 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 256 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 128 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( y_train . shape [ 1 ] ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 001 ) model . compile ( loss = 'mean_squared_error' , optimizer = opt , metrics = [ 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 1000 , callbacks =[ early_stop ] , validation_split = 0.2 ) plot_history ( history ) Epoch 1/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0114 - mae: 0.0738 - mse: 0.0114 - val_loss: 0.0060 - val_mae: 0.0532 - val_mse: 0.0060 Epoch 2/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0068 - mae: 0.0551 - mse: 0.0068 - val_loss: 0.0057 - val_mae: 0.0503 - val_mse: 0.0057 Epoch 3/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0061 - mae: 0.0510 - mse: 0.0061 - val_loss: 0.0053 - val_mae: 0.0492 - val_mse: 0.0053 Epoch 4/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0058 - mae: 0.0494 - mse: 0.0058 - val_loss: 0.0054 - val_mae: 0.0512 - val_mse: 0.0054 Epoch 5/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0053 - mae: 0.0473 - mse: 0.0053 - val_loss: 0.0049 - val_mae: 0.0488 - val_mse: 0.0049 Epoch 6/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0053 - mae: 0.0469 - mse: 0.0053 - val_loss: 0.0056 - val_mae: 0.0509 - val_mse: 0.0056 Epoch 7/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0053 - mae: 0.0469 - mse: 0.0053 - val_loss: 0.0053 - val_mae: 0.0501 - val_mse: 0.0053 Epoch 8/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0051 - mae: 0.0460 - mse: 0.0051 - val_loss: 0.0052 - val_mae: 0.0515 - val_mse: 0.0052 Epoch 9/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0050 - mae: 0.0455 - mse: 0.0050 - val_loss: 0.0047 - val_mae: 0.0452 - val_mse: 0.0047 Epoch 10/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0048 - mae: 0.0449 - mse: 0.0048 - val_loss: 0.0058 - val_mae: 0.0512 - val_mse: 0.0058 Epoch 11/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0046 - mae: 0.0437 - mse: 0.0046 - val_loss: 0.0049 - val_mae: 0.0480 - val_mse: 0.0049 Epoch 12/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0046 - mae: 0.0435 - mse: 0.0046 - val_loss: 0.0049 - val_mae: 0.0471 - val_mse: 0.0049 Epoch 13/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0044 - mae: 0.0431 - mse: 0.0044 - val_loss: 0.0050 - val_mae: 0.0473 - val_mse: 0.0050 Epoch 14/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0045 - mae: 0.0432 - mse: 0.0045 - val_loss: 0.0046 - val_mae: 0.0453 - val_mse: 0.0046 Epoch 15/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0043 - mae: 0.0426 - mse: 0.0043 - val_loss: 0.0047 - val_mae: 0.0454 - val_mse: 0.0047 Epoch 16/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0043 - mae: 0.0422 - mse: 0.0043 - val_loss: 0.0049 - val_mae: 0.0444 - val_mse: 0.0049 Epoch 17/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0042 - mae: 0.0418 - mse: 0.0042 - val_loss: 0.0042 - val_mae: 0.0436 - val_mse: 0.0042 Epoch 18/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0041 - mae: 0.0408 - mse: 0.0041 - val_loss: 0.0047 - val_mae: 0.0460 - val_mse: 0.0047 Epoch 19/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0041 - mae: 0.0409 - mse: 0.0041 - val_loss: 0.0044 - val_mae: 0.0442 - val_mse: 0.0044 Epoch 20/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0040 - mae: 0.0409 - mse: 0.0040 - val_loss: 0.0044 - val_mae: 0.0461 - val_mse: 0.0044 Epoch 21/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0040 - mae: 0.0407 - mse: 0.0040 - val_loss: 0.0046 - val_mae: 0.0443 - val_mse: 0.0046 Epoch 22/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0038 - mae: 0.0398 - mse: 0.0038 - val_loss: 0.0044 - val_mae: 0.0436 - val_mse: 0.0044 Epoch 23/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0038 - mae: 0.0399 - mse: 0.0038 - val_loss: 0.0047 - val_mae: 0.0458 - val_mse: 0.0047 Epoch 24/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0037 - mae: 0.0398 - mse: 0.0037 - val_loss: 0.0042 - val_mae: 0.0428 - val_mse: 0.0042 Epoch 25/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0038 - mae: 0.0401 - mse: 0.0038 - val_loss: 0.0043 - val_mae: 0.0424 - val_mse: 0.0043 Epoch 26/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0036 - mae: 0.0393 - mse: 0.0036 - val_loss: 0.0041 - val_mae: 0.0437 - val_mse: 0.0041 Epoch 27/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0037 - mae: 0.0397 - mse: 0.0037 - val_loss: 0.0044 - val_mae: 0.0466 - val_mse: 0.0044 Epoch 28/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0035 - mae: 0.0388 - mse: 0.0035 - val_loss: 0.0046 - val_mae: 0.0464 - val_mse: 0.0046 Epoch 29/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0037 - mae: 0.0393 - mse: 0.0037 - val_loss: 0.0041 - val_mae: 0.0443 - val_mse: 0.0041 Epoch 30/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0036 - mae: 0.0394 - mse: 0.0036 - val_loss: 0.0042 - val_mae: 0.0448 - val_mse: 0.0042 Epoch 31/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0035 - mae: 0.0382 - mse: 0.0035 - val_loss: 0.0044 - val_mae: 0.0474 - val_mse: 0.0044 Epoch 32/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0034 - mae: 0.0381 - mse: 0.0034 - val_loss: 0.0043 - val_mae: 0.0454 - val_mse: 0.0043 Epoch 33/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0034 - mae: 0.0382 - mse: 0.0034 - val_loss: 0.0042 - val_mae: 0.0429 - val_mse: 0.0042 Epoch 34/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0035 - mae: 0.0383 - mse: 0.0035 - val_loss: 0.0044 - val_mae: 0.0468 - val_mse: 0.0044 Epoch 35/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0375 - mse: 0.0033 - val_loss: 0.0046 - val_mae: 0.0484 - val_mse: 0.0046 Epoch 36/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0375 - mse: 0.0033 - val_loss: 0.0043 - val_mae: 0.0474 - val_mse: 0.0043 Epoch 37/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0377 - mse: 0.0033 - val_loss: 0.0043 - val_mae: 0.0454 - val_mse: 0.0043 Epoch 38/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0375 - mse: 0.0033 - val_loss: 0.0045 - val_mae: 0.0487 - val_mse: 0.0045 Epoch 39/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0033 - mae: 0.0376 - mse: 0.0033 - val_loss: 0.0044 - val_mae: 0.0500 - val_mse: 0.0044 Epoch 40/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0032 - mae: 0.0369 - mse: 0.0032 - val_loss: 0.0045 - val_mae: 0.0497 - val_mse: 0.0045 Epoch 41/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0032 - mae: 0.0367 - mse: 0.0032 - val_loss: 0.0044 - val_mae: 0.0476 - val_mse: 0.0044 Epoch 42/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0031 - mae: 0.0367 - mse: 0.0031 - val_loss: 0.0041 - val_mae: 0.0453 - val_mse: 0.0041 Epoch 43/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0362 - mse: 0.0030 - val_loss: 0.0043 - val_mae: 0.0481 - val_mse: 0.0043 Epoch 44/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0032 - mae: 0.0364 - mse: 0.0032 - val_loss: 0.0045 - val_mae: 0.0497 - val_mse: 0.0045 Epoch 45/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0031 - mae: 0.0368 - mse: 0.0031 - val_loss: 0.0043 - val_mae: 0.0490 - val_mse: 0.0043 Epoch 46/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0362 - mse: 0.0030 - val_loss: 0.0042 - val_mae: 0.0469 - val_mse: 0.0042 Epoch 47/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0361 - mse: 0.0030 - val_loss: 0.0044 - val_mae: 0.0457 - val_mse: 0.0044 Epoch 48/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0031 - mae: 0.0361 - mse: 0.0031 - val_loss: 0.0046 - val_mae: 0.0503 - val_mse: 0.0046 Epoch 49/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0357 - mse: 0.0030 - val_loss: 0.0048 - val_mae: 0.0494 - val_mse: 0.0048 Epoch 50/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0030 - mae: 0.0359 - mse: 0.0030 - val_loss: 0.0043 - val_mae: 0.0480 - val_mse: 0.0043 Epoch 51/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0357 - mse: 0.0029 - val_loss: 0.0042 - val_mae: 0.0477 - val_mse: 0.0042 Epoch 52/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0350 - mse: 0.0028 - val_loss: 0.0044 - val_mae: 0.0485 - val_mse: 0.0044 Epoch 53/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0354 - mse: 0.0029 - val_loss: 0.0044 - val_mae: 0.0494 - val_mse: 0.0044 Epoch 54/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0352 - mse: 0.0029 - val_loss: 0.0043 - val_mae: 0.0487 - val_mse: 0.0043 Epoch 55/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0029 - mae: 0.0353 - mse: 0.0029 - val_loss: 0.0043 - val_mae: 0.0490 - val_mse: 0.0043 Epoch 56/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0351 - mse: 0.0028 - val_loss: 0.0045 - val_mae: 0.0482 - val_mse: 0.0045 Epoch 57/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0349 - mse: 0.0028 - val_loss: 0.0043 - val_mae: 0.0472 - val_mse: 0.0043 Epoch 58/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0342 - mse: 0.0028 - val_loss: 0.0044 - val_mae: 0.0492 - val_mse: 0.0044 Epoch 59/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0347 - mse: 0.0028 - val_loss: 0.0043 - val_mae: 0.0478 - val_mse: 0.0043 Epoch 60/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0028 - mae: 0.0347 - mse: 0.0028 - val_loss: 0.0047 - val_mae: 0.0490 - val_mse: 0.0047 Epoch 61/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0027 - mae: 0.0344 - mse: 0.0027 - val_loss: 0.0046 - val_mae: 0.0498 - val_mse: 0.0046 Epoch 62/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.0027 - mae: 0.0344 - mse: 0.0027 - val_loss: 0.0042 - val_mae: 0.0453 - val_mse: 0.0042 y_pred = model.predict(X_test) err=mean_squared_error(y_pred,y_test) y_pred_ori = scaler.inverse_transform(y_pred) y_test_ori = scaler.inverse_transform(y_test) print(err) print(y_pred_ori[:10]) print(y_test_ori[:10]) 0.0034494638191476575 [[13.511538] [33.44774 ] [ 7.324512] [14.62247 ] [34.36278 ] [10.200519] [10.059496] [48.480953] [19.146278] [39.977325]] [[10.] [30.] [ 0.] [15.] [15.] [ 5.] [ 5.] [60.] [10.] [50.]] diff = y_test_ori - y_pred_ori plt.figure(figsize=(20, 10)) plt.plot(y_pred_ori, label=\"Prediction\") plt.plot(y_test_ori, label=\"True\") plt.plot(diff, label=\"Difference\") plt.legend() <matplotlib.legend.Legend at 0x7fc556415c50>","title":"Training by using DNN"},{"location":"MSBD5001/project/Group%20Project/#training-on-category","text":"in this case, we will pre-process the wait time into 3 different categories. [1, 0, 0]: Wait time < 30 mins [0, 1, 0]: Wait time >= 30 and <= 70 cat_vars = [ 'Name' , 'IsWeekend' , 'IsHoliday' , 'Hour modify' , 'Weather' ] num_vars = [ 'Temperature' , 'Pressure' , 'Humidity' , 'Cloud' , 'Wind degree' , ] X_train , X_test , y_train , y_test = generate_training_data ( train , 'Is busy' , cat_vars = cat_vars , num_vars = num_vars , should_reshape = False ) print ( y_train . shape ) print ( X_train . shape ) (14328, 3) (14328, 44) early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 512 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 256 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 128 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( y_train . shape [ 1 ], activation = 'softmax' ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 001 ) model . compile ( loss = 'categorical_crossentropy' , optimizer = opt , metrics = [ 'acc' , 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 1000 , callbacks =[ early_stop ] , validation_split = 0.2 ) plot_history ( history ) Epoch 1/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.5546 - acc: 0.7431 - mae: 0.2245 - mse: 0.1133 - val_loss: 0.4317 - val_acc: 0.7994 - val_mae: 0.1869 - val_mse: 0.0900 Epoch 2/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4437 - acc: 0.7988 - mae: 0.1824 - mse: 0.0921 - val_loss: 0.4212 - val_acc: 0.8022 - val_mae: 0.1744 - val_mse: 0.0887 Epoch 3/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4240 - acc: 0.8028 - mae: 0.1760 - mse: 0.0882 - val_loss: 0.4124 - val_acc: 0.8043 - val_mae: 0.1713 - val_mse: 0.0864 Epoch 4/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4135 - acc: 0.8074 - mae: 0.1714 - mse: 0.0863 - val_loss: 0.4075 - val_acc: 0.8105 - val_mae: 0.1645 - val_mse: 0.0852 Epoch 5/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4013 - acc: 0.8148 - mae: 0.1660 - mse: 0.0833 - val_loss: 0.4032 - val_acc: 0.8109 - val_mae: 0.1682 - val_mse: 0.0848 Epoch 6/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3940 - acc: 0.8207 - mae: 0.1639 - mse: 0.0822 - val_loss: 0.4187 - val_acc: 0.8088 - val_mae: 0.1786 - val_mse: 0.0875 Epoch 7/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3903 - acc: 0.8204 - mae: 0.1624 - mse: 0.0817 - val_loss: 0.3959 - val_acc: 0.8203 - val_mae: 0.1701 - val_mse: 0.0831 Epoch 8/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3835 - acc: 0.8234 - mae: 0.1600 - mse: 0.0802 - val_loss: 0.3960 - val_acc: 0.8193 - val_mae: 0.1700 - val_mse: 0.0826 Epoch 9/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3747 - acc: 0.8313 - mae: 0.1562 - mse: 0.0780 - val_loss: 0.3955 - val_acc: 0.8186 - val_mae: 0.1559 - val_mse: 0.0823 Epoch 10/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3755 - acc: 0.8276 - mae: 0.1563 - mse: 0.0786 - val_loss: 0.4090 - val_acc: 0.8095 - val_mae: 0.1621 - val_mse: 0.0848 Epoch 11/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3718 - acc: 0.8296 - mae: 0.1546 - mse: 0.0774 - val_loss: 0.3961 - val_acc: 0.8196 - val_mae: 0.1669 - val_mse: 0.0825 Epoch 12/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3659 - acc: 0.8309 - mae: 0.1536 - mse: 0.0767 - val_loss: 0.4028 - val_acc: 0.8217 - val_mae: 0.1540 - val_mse: 0.0824 Epoch 13/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3647 - acc: 0.8346 - mae: 0.1514 - mse: 0.0759 - val_loss: 0.3960 - val_acc: 0.8193 - val_mae: 0.1619 - val_mse: 0.0823 Epoch 14/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3583 - acc: 0.8377 - mae: 0.1489 - mse: 0.0747 - val_loss: 0.3950 - val_acc: 0.8147 - val_mae: 0.1618 - val_mse: 0.0821 Epoch 15/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3503 - acc: 0.8415 - mae: 0.1468 - mse: 0.0736 - val_loss: 0.4019 - val_acc: 0.8130 - val_mae: 0.1606 - val_mse: 0.0837 Epoch 16/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3512 - acc: 0.8398 - mae: 0.1465 - mse: 0.0736 - val_loss: 0.4124 - val_acc: 0.8112 - val_mae: 0.1595 - val_mse: 0.0842 Epoch 17/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3488 - acc: 0.8405 - mae: 0.1454 - mse: 0.0729 - val_loss: 0.4066 - val_acc: 0.8207 - val_mae: 0.1532 - val_mse: 0.0823 Epoch 18/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3427 - acc: 0.8445 - mae: 0.1431 - mse: 0.0718 - val_loss: 0.4032 - val_acc: 0.8203 - val_mae: 0.1567 - val_mse: 0.0825 Epoch 19/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3442 - acc: 0.8423 - mae: 0.1444 - mse: 0.0723 - val_loss: 0.4005 - val_acc: 0.8234 - val_mae: 0.1513 - val_mse: 0.0812 Epoch 20/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3360 - acc: 0.8475 - mae: 0.1403 - mse: 0.0703 - val_loss: 0.3930 - val_acc: 0.8182 - val_mae: 0.1561 - val_mse: 0.0808 Epoch 21/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3348 - acc: 0.8470 - mae: 0.1406 - mse: 0.0703 - val_loss: 0.3984 - val_acc: 0.8182 - val_mae: 0.1537 - val_mse: 0.0812 Epoch 22/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3310 - acc: 0.8518 - mae: 0.1389 - mse: 0.0692 - val_loss: 0.4146 - val_acc: 0.8238 - val_mae: 0.1465 - val_mse: 0.0832 Epoch 23/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3246 - acc: 0.8514 - mae: 0.1357 - mse: 0.0681 - val_loss: 0.3981 - val_acc: 0.8308 - val_mae: 0.1478 - val_mse: 0.0800 Epoch 24/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3264 - acc: 0.8516 - mae: 0.1363 - mse: 0.0682 - val_loss: 0.4086 - val_acc: 0.8179 - val_mae: 0.1469 - val_mse: 0.0821 Epoch 25/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3223 - acc: 0.8563 - mae: 0.1347 - mse: 0.0674 - val_loss: 0.4071 - val_acc: 0.8224 - val_mae: 0.1457 - val_mse: 0.0822 Epoch 26/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3190 - acc: 0.8553 - mae: 0.1328 - mse: 0.0667 - val_loss: 0.4065 - val_acc: 0.8290 - val_mae: 0.1471 - val_mse: 0.0809 Epoch 27/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3205 - acc: 0.8533 - mae: 0.1340 - mse: 0.0670 - val_loss: 0.3998 - val_acc: 0.8364 - val_mae: 0.1466 - val_mse: 0.0800 Epoch 28/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3160 - acc: 0.8546 - mae: 0.1320 - mse: 0.0659 - val_loss: 0.4039 - val_acc: 0.8276 - val_mae: 0.1434 - val_mse: 0.0807 Epoch 29/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3099 - acc: 0.8619 - mae: 0.1297 - mse: 0.0649 - val_loss: 0.3998 - val_acc: 0.8280 - val_mae: 0.1435 - val_mse: 0.0797 Epoch 30/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3078 - acc: 0.8604 - mae: 0.1285 - mse: 0.0646 - val_loss: 0.4172 - val_acc: 0.8266 - val_mae: 0.1434 - val_mse: 0.0810 Epoch 31/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3057 - acc: 0.8630 - mae: 0.1274 - mse: 0.0637 - val_loss: 0.4027 - val_acc: 0.8276 - val_mae: 0.1420 - val_mse: 0.0794 Epoch 32/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3005 - acc: 0.8640 - mae: 0.1253 - mse: 0.0630 - val_loss: 0.3986 - val_acc: 0.8266 - val_mae: 0.1465 - val_mse: 0.0790 Epoch 33/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2978 - acc: 0.8642 - mae: 0.1249 - mse: 0.0625 - val_loss: 0.4192 - val_acc: 0.8234 - val_mae: 0.1469 - val_mse: 0.0817 Epoch 34/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2943 - acc: 0.8639 - mae: 0.1235 - mse: 0.0617 - val_loss: 0.4238 - val_acc: 0.8290 - val_mae: 0.1377 - val_mse: 0.0801 Epoch 35/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2938 - acc: 0.8657 - mae: 0.1230 - mse: 0.0618 - val_loss: 0.4144 - val_acc: 0.8283 - val_mae: 0.1441 - val_mse: 0.0796 Epoch 36/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2919 - acc: 0.8666 - mae: 0.1227 - mse: 0.0613 - val_loss: 0.4113 - val_acc: 0.8346 - val_mae: 0.1364 - val_mse: 0.0773 Epoch 37/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2833 - acc: 0.8712 - mae: 0.1184 - mse: 0.0592 - val_loss: 0.4232 - val_acc: 0.8266 - val_mae: 0.1421 - val_mse: 0.0793 Epoch 38/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.2881 - acc: 0.8700 - mae: 0.1211 - mse: 0.0605 - val_loss: 0.4121 - val_acc: 0.8308 - val_mae: 0.1391 - val_mse: 0.0784 Epoch 39/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.2818 - acc: 0.8725 - mae: 0.1175 - mse: 0.0590 - val_loss: 0.4214 - val_acc: 0.8276 - val_mae: 0.1374 - val_mse: 0.0793 Epoch 40/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.2823 - acc: 0.8699 - mae: 0.1183 - mse: 0.0595 - val_loss: 0.4076 - val_acc: 0.8301 - val_mae: 0.1427 - val_mse: 0.0791 y_pred = model . predict ( X_test ) def print_acc ( pred , true ) : right = 0 for i in range ( len ( pred )) : p = np . argmax ( pred [ i ] ) t = np . argmax ( true [ i ] ) if p == t : right += 1 print ( f \"acc: {right}/{len(pred)}, {right/len(pred)}\" ) print_acc ( y_pred , y_test ) acc: 242/293, 0.825938566552901","title":"Training on category"},{"location":"MSBD5001/project/Group%20Project/#training-by-using-category","text":"In this example, we will use average-wait-time to compute their waiting time's category If wait-time is less than the average-wait time of that facility, then it is not busy. If wait-time is around average wait-time, then it is in a normal situation If wait-time is above average-wait-time, then it is busy. In this model, we are basically assume facilities are different. Some will have more popularity than others. And we will use the model to predict whether a model is above its average or not. def is_busy_2 ( row ): if row [ 3 ] < row [ 1 ] - 5 : return [ 1 , 0 , 0 ] elif row [ 3 ] >= row [ 1 ] - 5 and row [ 3 ] <= row [ 1 ] + 5 : return [ 0 , 1 , 0 ] else : return [ 0 , 0 , 1 ] def calculate_average_wait_time ( df : pd . DataFrame ) -> pd . DataFrame : new_df = df . copy () new_df2 = df . copy () new_df [ 'tmp_date' ] = new_df [ 'Time' ]. apply ( lambda x : x . date ()) new_df = new_df [[ 'tmp_date' , 'Wait time' , 'Name' ]] new_df = new_df . groupby ([ 'Name' ]). mean () new_df = new_df . rename ( columns = { 'Wait time' : 'Average wait time' } ) new_df = new_df . merge ( new_df2 , on = 'Name' , how = 'right' ) return new_df average_sampled_train = calculate_average_wait_time ( train ) average_sampled_train [ 'Is busy' ] = average_sampled_train . apply ( is_busy_2 , axis = 1 ) average_sampled_train . sample ( 20 ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Name Average wait time Time Wait time Weather Temperature Max temperature Min temperature Pressure Humidity Wind degree Wind speed Cloud id IsWeekend IsHoliday Hour modify Is busy 13204 Slinky Dog Spin 24.613601 2020-09-27 15:19:38.869181 40.0 Clouds 24.82 26.11 26.11 1015 78 40.0 5.0 75 29 1 1 Afternoon [0, 0, 1] 3335 Hunny Pot Spin 9.258114 2020-10-09 13:20:34.934157 10.0 Clouds 24.59 25.00 25.00 1020 44 20.0 5.0 16 7 0 0 Afternoon [0, 1, 0] 10658 Shipwreck Shore 5.008681 2020-10-17 11:22:39.121594 5.0 Clear 20.34 21.00 21.00 1024 56 360.0 6.0 0 19 1 0 Morning [0, 1, 0] 2160 \u201cOnce Upon a Time\u201d Adventure 7.246127 2020-10-11 11:21:48.801419 5.0 Clouds 23.34 23.89 23.89 1016 56 40.0 4.0 40 4 1 1 Morning [0, 1, 0] 11860 Roaring Rapids 31.629555 2020-09-10 10:20:16.261789 20.0 Clouds 31.39 32.78 32.78 1008 62 160.0 4.0 76 23 0 0 Morning [1, 0, 0] 2992 Hunny Pot Spin 9.258114 2020-09-11 15:18:17.428365 5.0 Clouds 23.95 25.00 25.00 1008 83 110.0 4.0 90 7 0 0 Afternoon [0, 1, 0] 11075 Pirates of the Caribbean Battle for the Sunken... 20.969055 2020-10-02 10:22:38.662643 40.0 Clouds 26.25 26.67 26.67 1014 65 140.0 4.0 20 20 0 1 Morning [0, 0, 1] 11169 Pirates of the Caribbean Battle for the Sunken... 20.969055 2020-10-09 12:24:19.516068 15.0 Clouds 24.09 25.00 25.00 1021 47 360.0 6.0 20 20 0 0 Afternoon [1, 0, 0] 8079 Stitch Encounter 15.070565 2020-10-03 17:19:47.471647 15.0 Clouds 23.73 24.00 24.00 1012 78 90.0 6.0 75 15 1 1 Evening [0, 1, 0] 2482 Alice in Wonderland Maze 5.017730 2020-09-18 09:25:01.995252 5.0 Rain 19.62 20.00 20.00 1018 82 330.0 4.0 100 5 0 0 Morning [0, 1, 0] 5505 Voyage to the Crystal Grotto 17.301459 2020-09-15 15:18:48.496307 10.0 Rain 23.03 23.33 23.33 1010 94 150.0 3.0 40 11 0 0 Afternoon [1, 0, 0] 8430 Jet Packs 34.943639 2020-09-14 18:19:06.567386 40.0 Rain 22.65 23.00 23.00 1013 94 220.0 3.0 75 16 0 0 Evening [0, 0, 1] 11374 Explorer Canoes 26.490385 2020-09-05 09:33:30.360833 5.0 Clear 31.06 34.44 34.44 1011 58 90.0 2.0 0 21 1 0 Morning [1, 0, 0] 9856 Siren's Revenge 5.000000 2020-10-01 09:33:02.313813 5.0 Clouds 25.68 28.89 28.89 1015 69 20.0 4.0 17 18 0 1 Morning [0, 1, 0] 6244 Dumbo the Flying Elephant 24.476950 2020-09-28 12:21:14.161007 5.0 Clouds 26.75 27.22 27.22 1015 61 100.0 5.0 40 12 0 0 Afternoon [1, 0, 0] 12970 Slinky Dog Spin 24.613601 2020-09-07 13:17:55.833556 30.0 Clouds 33.90 36.11 36.11 1005 41 310.0 8.0 20 29 0 0 Afternoon [0, 0, 1] 10944 Pirates of the Caribbean Battle for the Sunken... 20.969055 2020-09-21 15:19:21.264789 50.0 Clouds 27.00 27.78 27.78 1015 50 120.0 4.0 100 20 0 0 Afternoon [0, 0, 1] 9653 Siren's Revenge 5.000000 2020-09-14 12:20:05.878090 5.0 Clouds 27.49 29.44 29.44 1014 69 80.0 3.0 40 18 0 0 Afternoon [0, 1, 0] 13795 Woody\u2019s Roundup 17.469040 2020-09-23 08:54:36.402435 5.0 Rain 21.58 22.00 22.00 1014 78 70.0 3.0 20 30 0 0 Morning [1, 0, 0] 4720 The Many Adventures of Winnie the Pooh 21.727129 2020-09-01 15:18:22.137361 25.0 Clouds 31.26 33.33 33.33 1003 79 20.0 8.0 40 10 0 0 Afternoon [0, 1, 0] cat_vars = [ 'Name' , 'IsWeekend' , 'IsHoliday' , 'Hour modify' , 'Weather' ] num_vars = [ 'Temperature' , 'Pressure' , 'Humidity' , 'Cloud' , 'Wind degree' , ] X_train , X_test , y_train , y_test = generate_training_data ( average_sampled_train , 'Is busy' , cat_vars = cat_vars , num_vars = num_vars , should_reshape = False ) early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 512 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), layers . Dense ( 256 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dropout ( 0 . 5 ), # layers . Dense ( 512 , activation = \"relu\" , # input_shape = ( X_train . shape [ 1 ],),), # layers . Dropout ( 0 . 5 ), # layers . Dense ( 512 , activation = \"relu\" , # input_shape = ( X_train . shape [ 1 ],),), # layers . Dropout ( 0 . 5 ), # layers . Dense ( 256 , activation = \"relu\" , # input_shape = ( X_train . shape [ 1 ],),), # layers . Dropout ( 0 . 5 ), layers . Dense ( 128 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( y_train . shape [ 1 ], activation = 'softmax' ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 001 ) model . compile ( loss = 'categorical_crossentropy' , optimizer = opt , metrics = [ 'acc' , 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 1000 , callbacks =[ early_stop ] , validation_split = 0.2 ) plot_history ( history ) Epoch 1/1000 359/359 [==============================] - 1s 4ms/step - loss: 0.5560 - acc: 0.7499 - mae: 0.2245 - mse: 0.1130 - val_loss: 0.4329 - val_acc: 0.8015 - val_mae: 0.1843 - val_mse: 0.0902 Epoch 2/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4433 - acc: 0.7959 - mae: 0.1820 - mse: 0.0920 - val_loss: 0.4151 - val_acc: 0.8067 - val_mae: 0.1757 - val_mse: 0.0866 Epoch 3/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4232 - acc: 0.8022 - mae: 0.1752 - mse: 0.0880 - val_loss: 0.4095 - val_acc: 0.8109 - val_mae: 0.1765 - val_mse: 0.0859 Epoch 4/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4081 - acc: 0.8121 - mae: 0.1698 - mse: 0.0854 - val_loss: 0.4097 - val_acc: 0.8088 - val_mae: 0.1752 - val_mse: 0.0867 Epoch 5/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.4027 - acc: 0.8150 - mae: 0.1678 - mse: 0.0841 - val_loss: 0.4027 - val_acc: 0.8088 - val_mae: 0.1684 - val_mse: 0.0848 Epoch 6/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3913 - acc: 0.8211 - mae: 0.1625 - mse: 0.0814 - val_loss: 0.4224 - val_acc: 0.8060 - val_mae: 0.1577 - val_mse: 0.0876 Epoch 7/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3868 - acc: 0.8226 - mae: 0.1601 - mse: 0.0804 - val_loss: 0.4104 - val_acc: 0.8095 - val_mae: 0.1632 - val_mse: 0.0859 Epoch 8/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3827 - acc: 0.8282 - mae: 0.1591 - mse: 0.0798 - val_loss: 0.3976 - val_acc: 0.8189 - val_mae: 0.1629 - val_mse: 0.0830 Epoch 9/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3804 - acc: 0.8265 - mae: 0.1573 - mse: 0.0790 - val_loss: 0.4111 - val_acc: 0.8161 - val_mae: 0.1724 - val_mse: 0.0856 Epoch 10/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3731 - acc: 0.8307 - mae: 0.1562 - mse: 0.0778 - val_loss: 0.3961 - val_acc: 0.8196 - val_mae: 0.1573 - val_mse: 0.0822 Epoch 11/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3666 - acc: 0.8340 - mae: 0.1528 - mse: 0.0766 - val_loss: 0.3932 - val_acc: 0.8255 - val_mae: 0.1613 - val_mse: 0.0819 Epoch 12/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3592 - acc: 0.8368 - mae: 0.1504 - mse: 0.0753 - val_loss: 0.3989 - val_acc: 0.8214 - val_mae: 0.1580 - val_mse: 0.0827 Epoch 13/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3579 - acc: 0.8361 - mae: 0.1497 - mse: 0.0750 - val_loss: 0.3955 - val_acc: 0.8116 - val_mae: 0.1612 - val_mse: 0.0824 Epoch 14/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3529 - acc: 0.8394 - mae: 0.1473 - mse: 0.0736 - val_loss: 0.3990 - val_acc: 0.8231 - val_mae: 0.1555 - val_mse: 0.0819 Epoch 15/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3467 - acc: 0.8395 - mae: 0.1454 - mse: 0.0728 - val_loss: 0.3990 - val_acc: 0.8214 - val_mae: 0.1546 - val_mse: 0.0816 Epoch 16/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3441 - acc: 0.8411 - mae: 0.1444 - mse: 0.0723 - val_loss: 0.4026 - val_acc: 0.8259 - val_mae: 0.1527 - val_mse: 0.0826 Epoch 17/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3388 - acc: 0.8431 - mae: 0.1415 - mse: 0.0711 - val_loss: 0.3967 - val_acc: 0.8280 - val_mae: 0.1520 - val_mse: 0.0811 Epoch 18/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3365 - acc: 0.8462 - mae: 0.1407 - mse: 0.0706 - val_loss: 0.3928 - val_acc: 0.8276 - val_mae: 0.1513 - val_mse: 0.0803 Epoch 19/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3321 - acc: 0.8478 - mae: 0.1398 - mse: 0.0699 - val_loss: 0.3967 - val_acc: 0.8294 - val_mae: 0.1477 - val_mse: 0.0793 Epoch 20/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3280 - acc: 0.8515 - mae: 0.1375 - mse: 0.0688 - val_loss: 0.3941 - val_acc: 0.8224 - val_mae: 0.1525 - val_mse: 0.0806 Epoch 21/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3300 - acc: 0.8522 - mae: 0.1374 - mse: 0.0688 - val_loss: 0.4066 - val_acc: 0.8172 - val_mae: 0.1503 - val_mse: 0.0821 Epoch 22/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3231 - acc: 0.8524 - mae: 0.1357 - mse: 0.0680 - val_loss: 0.4023 - val_acc: 0.8276 - val_mae: 0.1472 - val_mse: 0.0798 Epoch 23/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3166 - acc: 0.8556 - mae: 0.1323 - mse: 0.0665 - val_loss: 0.4084 - val_acc: 0.8273 - val_mae: 0.1496 - val_mse: 0.0812 Epoch 24/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3175 - acc: 0.8540 - mae: 0.1329 - mse: 0.0663 - val_loss: 0.3956 - val_acc: 0.8297 - val_mae: 0.1491 - val_mse: 0.0797 Epoch 25/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3123 - acc: 0.8586 - mae: 0.1305 - mse: 0.0655 - val_loss: 0.4043 - val_acc: 0.8276 - val_mae: 0.1482 - val_mse: 0.0795 Epoch 26/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3091 - acc: 0.8573 - mae: 0.1297 - mse: 0.0649 - val_loss: 0.3939 - val_acc: 0.8241 - val_mae: 0.1483 - val_mse: 0.0792 Epoch 27/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3100 - acc: 0.8585 - mae: 0.1301 - mse: 0.0653 - val_loss: 0.4059 - val_acc: 0.8294 - val_mae: 0.1441 - val_mse: 0.0791 Epoch 28/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3055 - acc: 0.8619 - mae: 0.1278 - mse: 0.0640 - val_loss: 0.3913 - val_acc: 0.8343 - val_mae: 0.1512 - val_mse: 0.0786 Epoch 29/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.3037 - acc: 0.8611 - mae: 0.1271 - mse: 0.0638 - val_loss: 0.4044 - val_acc: 0.8255 - val_mae: 0.1527 - val_mse: 0.0803 Epoch 30/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2993 - acc: 0.8638 - mae: 0.1255 - mse: 0.0629 - val_loss: 0.4006 - val_acc: 0.8332 - val_mae: 0.1471 - val_mse: 0.0788 Epoch 31/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2965 - acc: 0.8647 - mae: 0.1250 - mse: 0.0625 - val_loss: 0.4140 - val_acc: 0.8294 - val_mae: 0.1467 - val_mse: 0.0794 Epoch 32/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2930 - acc: 0.8647 - mae: 0.1241 - mse: 0.0619 - val_loss: 0.4159 - val_acc: 0.8308 - val_mae: 0.1399 - val_mse: 0.0788 Epoch 33/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2914 - acc: 0.8653 - mae: 0.1220 - mse: 0.0612 - val_loss: 0.4206 - val_acc: 0.8297 - val_mae: 0.1385 - val_mse: 0.0798 Epoch 34/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2868 - acc: 0.8706 - mae: 0.1204 - mse: 0.0604 - val_loss: 0.4048 - val_acc: 0.8276 - val_mae: 0.1444 - val_mse: 0.0785 Epoch 35/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2856 - acc: 0.8694 - mae: 0.1195 - mse: 0.0600 - val_loss: 0.4113 - val_acc: 0.8283 - val_mae: 0.1472 - val_mse: 0.0804 Epoch 36/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2861 - acc: 0.8684 - mae: 0.1204 - mse: 0.0600 - val_loss: 0.4227 - val_acc: 0.8262 - val_mae: 0.1464 - val_mse: 0.0812 Epoch 37/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2850 - acc: 0.8706 - mae: 0.1189 - mse: 0.0598 - val_loss: 0.4118 - val_acc: 0.8308 - val_mae: 0.1438 - val_mse: 0.0796 Epoch 38/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2803 - acc: 0.8720 - mae: 0.1183 - mse: 0.0590 - val_loss: 0.4339 - val_acc: 0.8308 - val_mae: 0.1367 - val_mse: 0.0813 Epoch 39/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2796 - acc: 0.8711 - mae: 0.1172 - mse: 0.0587 - val_loss: 0.4278 - val_acc: 0.8308 - val_mae: 0.1429 - val_mse: 0.0805 Epoch 40/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2711 - acc: 0.8744 - mae: 0.1147 - mse: 0.0575 - val_loss: 0.4283 - val_acc: 0.8276 - val_mae: 0.1402 - val_mse: 0.0801 Epoch 41/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2711 - acc: 0.8772 - mae: 0.1143 - mse: 0.0573 - val_loss: 0.4336 - val_acc: 0.8322 - val_mae: 0.1364 - val_mse: 0.0795 Epoch 42/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2716 - acc: 0.8778 - mae: 0.1139 - mse: 0.0570 - val_loss: 0.4327 - val_acc: 0.8252 - val_mae: 0.1399 - val_mse: 0.0813 Epoch 43/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2719 - acc: 0.8727 - mae: 0.1145 - mse: 0.0575 - val_loss: 0.4356 - val_acc: 0.8238 - val_mae: 0.1374 - val_mse: 0.0810 Epoch 44/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2691 - acc: 0.8774 - mae: 0.1129 - mse: 0.0567 - val_loss: 0.4334 - val_acc: 0.8304 - val_mae: 0.1400 - val_mse: 0.0800 Epoch 45/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2631 - acc: 0.8764 - mae: 0.1111 - mse: 0.0556 - val_loss: 0.4259 - val_acc: 0.8339 - val_mae: 0.1392 - val_mse: 0.0792 Epoch 46/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2641 - acc: 0.8791 - mae: 0.1112 - mse: 0.0558 - val_loss: 0.4243 - val_acc: 0.8318 - val_mae: 0.1392 - val_mse: 0.0791 Epoch 47/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2581 - acc: 0.8801 - mae: 0.1085 - mse: 0.0543 - val_loss: 0.4502 - val_acc: 0.8301 - val_mae: 0.1344 - val_mse: 0.0787 Epoch 48/1000 359/359 [==============================] - 1s 3ms/step - loss: 0.2622 - acc: 0.8815 - mae: 0.1098 - mse: 0.0551 - val_loss: 0.4314 - val_acc: 0.8371 - val_mae: 0.1367 - val_mse: 0.0779 y_pred = model . predict ( X_test ) print_acc ( y_pred , y_test ) acc: 243/293, 0.8293515358361775","title":"Training by using category"},{"location":"MSBD5001/project/Group%20Project/#lstm-training","text":"","title":"LSTM Training"},{"location":"MSBD5001/project/Group%20Project/#window-generator","text":"To make a single prediction 24h into the future, given 24h of history you might define a window like this: class WindowGenerator () : def __init__ ( self , input_width , offset , data , train_split ) : self . data = data self . input_width = input_width self . offset = offset self . train_split = train_split def to_sequences ( self ) : \"\"\" Return both data and label \"\"\" data_len = len ( self . data ) ret = [] ret_label = [] for i in range ( data_len - self . offset - self . input_width + 1 ) : tmp = self . data [ i : i + self . input_width ] tmp_label = self . data [ i + self . input_width + self . offset - 1 ] ret . append ( tmp ) ret_label . append ([ tmp_label ]) return np . array ( ret ), np . array ( ret_label ) def split ( self ) : x , y = self . to_sequences () num_train = int ( self . train_split * x . shape [ 0 ]) X_train = x [ : num_train ] y_train = y [ : num_train ] X_test = x [ num_train :] y_test = y [ num_train :] return X_train , y_train , X_test , y_test # [1, 2, 3] wg = WindowGenerator(data=np.array(range(100)), input_width=4, offset=0, train_split=0.1) X_train, y_train, X_test, y_test = wg.split() [[ 0 1 2 3] [ 1 2 3 4] [ 2 3 4 5] [ 3 4 5 6] [ 4 5 6 7] [ 5 6 7 8] [ 6 7 8 9] [ 7 8 9 10] [ 8 9 10 11]] [[ 3] [ 4] [ 5] [ 6] [ 7] [ 8] [ 9] [10] [11]]","title":"Window generator"},{"location":"MSBD5001/project/Individual%20Project/","text":"Speed Prediction \u00b6 In this project, we will use weather data to predict average speed. we will use weather data from openweathermap.org which provides temperature, wind, humidity, and weather conditions This notebook will be running on Google Colab Install and import dependencies \u00b6 ! pip install pactools Collecting pactools \u001b[?25l Downloading https://files.pythonhosted.org/packages/17/14/4c4eba6e54408e536be27b9891cea68ea391d7d190936593aa71e5c6405e/pactools-0.3.1-py3-none-any.whl (82kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 6.1MB/s \u001b[?25hRequirement already satisfied: h5py in /usr/local/lib/python3.6/dist-packages (from pactools) (2.10.0) Collecting mne \u001b[?25l Downloading https://files.pythonhosted.org/packages/4d/0e/6448521738d3357c205795fd5846d023bd7935bb83ba93a1ba0f7124205e/mne-0.21.2-py3-none-any.whl (6.8MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6.8MB 17.1MB/s \u001b[?25hRequirement already satisfied: scipy in /usr/local/lib/python3.6/dist-packages (from pactools) (1.4.1) Requirement already satisfied: numpy in /usr/local/lib/python3.6/dist-packages (from pactools) (1.18.5) Requirement already satisfied: matplotlib in /usr/local/lib/python3.6/dist-packages (from pactools) (3.2.2) Requirement already satisfied: scikit-learn in /usr/local/lib/python3.6/dist-packages (from pactools) (0.22.2.post1) Requirement already satisfied: six in /usr/local/lib/python3.6/dist-packages (from h5py->pactools) (1.15.0) Requirement already satisfied: python-dateutil>=2.1 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (2.8.1) Requirement already satisfied: kiwisolver>=1.0.1 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (1.3.1) Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.1 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (2.4.7) Requirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (0.10.0) Requirement already satisfied: joblib>=0.11 in /usr/local/lib/python3.6/dist-packages (from scikit-learn->pactools) (0.17.0) Installing collected packages: mne, pactools Successfully installed mne-0.21.2 pactools-0.3.1 import pandas as pd from sklearn.preprocessing import MinMaxScaler import requests from bs4 import BeautifulSoup from datetime import datetime import tensorflow as tf import seaborn as sns import matplotlib.pyplot as plt from sklearn.pipeline import Pipeline from sklearn.preprocessing import LabelBinarizer , OneHotEncoder , StandardScaler from sklearn.compose import ColumnTransformer from sklearn.model_selection import train_test_split from pactools.grid_search import GridSearchCVProgressBar from sklearn.model_selection import TimeSeriesSplit from sklearn.model_selection import GridSearchCV from sklearn import svm from xgboost import XGBRegressor from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error /usr/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject return f(*args, **kwds) /usr/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject return f(*args, **kwds) import tensorflow as tf print ( \"Num GPUs Available: \" , len ( tf . config . experimental . list_physical_devices ( 'GPU' ))) Num GPUs Available: 1 Preprocess \u00b6 Asign Holiday to the table \u00b6 def hour_modify ( x : datetime ): Early_Morning = [ 4 , 5 , 6 , 7 ] Morning = [ 8 , 9 , 10 , 11 ] Afternoon = [ 12 , 13 , 14 , 15 ] Evening = [ 16 , 17 , 18 , 19 ] Night = [ 20 , 21 , 22 , 23 ] Late_Night = [ 0 , 1 , 2 , 3 ] if x . hour in Early_Morning : return 'Early_Morning' elif x . hour in Morning : return 'Morning' elif x . hour in Afternoon : return 'Afternoon' elif x . hour in Evening : return 'Evening' elif x . hour in Night : return 'Night' else : return 'Late_Night' def add_holiday_and_weekend ( df : pd . DataFrame ) -> pd . DataFrame : \"\"\" Add holiday and weekend to the dataset \"\"\" new_df = df . copy () new_df [ 'IsWeekend' ] = new_df [ 'date' ]. apply ( lambda x : 0 if x . weekday () in [ 0 , 1 , 2 , 3 , 4 ] else 1 ) new_df [ 'IsHoliday' ] = new_df [ 'date' ]. apply ( lambda x : 1 if ( x . date (). strftime ( '%Y-%m-%d' ) in [ '2017-01-02' , '2017-01-28' , '2017-01-30' , '2017-01-31' , '2017-04-04' , '2017-04-14' , '2017-04-15' , '2017-04-17' , '2017-05-01' , '2017-05-03' , '2017-05-30' , '2017-07-01' , '2017-10-02' , '2017-10-05' , '2017-10-28' , '2017-12-25' , '2017-12-26' , '2018-01-01' , '2018-02-16' , '2018-02-17' , '2018-02-19' , '2018-03-30' , '2018-03-31' , '2018-04-02' , '2018-04-05' , '2018-05-01' , '2018-05-22' , '2018-06-18' , '2018-07-02' , '2018-09-25' , '2018-10-01' , '2018-10-17' , '2018-12-25' , '2018-12-26' ]) or ( x . weekday () in [ 6 ]) else 0 ) return new_df I am using google drive to store all the data including the weather data. So please change this line to the your file paths. # change following two lines to your paths train = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/individual project/train.csv' ) test = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/individual project/test.csv' ) train = train . drop ( 'id' , axis = 1 ) train [ 'date' ] = pd . to_datetime ( train [ 'date' ]) train = add_holiday_and_weekend ( train ) train [ 'hour_modify' ] = train [ 'date' ]. apply ( hour_modify ) train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } date speed IsWeekend IsHoliday hour_modify 0 2017-01-01 00:00:00 43.002930 1 1 Late_Night 1 2017-01-01 01:00:00 46.118696 1 1 Late_Night 2 2017-01-01 02:00:00 44.294158 1 1 Late_Night 3 2017-01-01 03:00:00 41.067468 1 1 Late_Night 4 2017-01-01 04:00:00 46.448653 1 1 Early_Morning ... ... ... ... ... ... 14001 2018-12-31 12:00:00 19.865269 0 0 Afternoon 14002 2018-12-31 15:00:00 17.820375 0 0 Afternoon 14003 2018-12-31 16:00:00 12.501851 0 0 Evening 14004 2018-12-31 18:00:00 15.979319 0 0 Evening 14005 2018-12-31 20:00:00 40.594183 0 0 Night 14006 rows \u00d7 5 columns train.plot(x='date', y='speed', figsize=(20, 10)) <matplotlib.axes._subplots.AxesSubplot at 0x7f3ff03ae400> Merge weather \u00b6 Pre-process weather data \u00b6 from datetime import datetime def k_to_c ( x ): return x - 273.15 # Change this path to yours weather = pd . read_csv ( \"/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/individual project/hongkong_weather_1970-2020.csv\" ) weather [ 'dt_iso' ] = weather [ 'dt_iso' ] . apply ( lambda x : x . replace ( 'UTC' , '' )) weather [ 'date' ] = pd . to_datetime ( weather [ 'dt_iso' ] ). dt . tz_convert ( \"Asia/Hong_Kong\" ). dt . tz_localize ( None ) # Transform unit weather [ 'temp' ] = weather [ 'temp' ] . apply ( k_to_c ) weather [ 'feels_like' ] = weather [ 'feels_like' ] . apply ( k_to_c ) weather [ 'temp_min' ] = weather [ 'temp_min' ] . apply ( k_to_c ) weather [ 'temp_max' ] = weather [ 'temp_max' ] . apply ( k_to_c ) weather = weather . drop ( [ \"dt_iso\", \"dt\", \"weather_icon\", \"rain_1h\", \"rain_3h\", \"snow_1h\", \"snow_3h\", \"sea_level\", \"grnd_level\", \"timezone\", \"lat\", \"lon\" ] , axis = 1 ) mask = ( weather [ 'date' ] >= datetime ( 2017 , 1 , 1 )) & ( weather [ 'date' ] <= datetime ( 2019 , 1 , 1 )) weather = weather . loc [ mask ] weather .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } city_name temp feels_like temp_min temp_max pressure humidity wind_speed wind_deg clouds_all weather_id weather_main weather_description date 334235 Hong Kong 18.04 18.64 16.5 20.000 1022 83 1.5 99 7 800 Clear sky is clear 2017-01-01 00:00:00 334236 Hong Kong 17.92 18.22 16.0 20.000 1022 76 1.2 76 15 801 Clouds few clouds 2017-01-01 01:00:00 334237 Hong Kong 17.90 18.19 16.0 20.000 1022 76 1.2 76 20 801 Clouds few clouds 2017-01-01 02:00:00 334238 Hong Kong 17.79 18.05 16.0 19.526 1022 76 1.2 76 29 802 Clouds scattered clouds 2017-01-01 03:00:00 334239 Hong Kong 17.75 17.23 16.0 19.468 1021 75 2.2 53 19 801 Clouds few clouds 2017-01-01 04:00:00 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 351755 Hong Kong 10.91 7.88 9.0 13.273 1019 65 2.6 347 58 803 Clouds broken clouds 2018-12-31 20:00:00 351756 Hong Kong 10.68 7.61 9.0 13.255 1019 65 2.6 347 56 803 Clouds broken clouds 2018-12-31 21:00:00 351757 Hong Kong 10.52 7.51 9.0 13.279 1019 67 2.6 354 52 803 Clouds broken clouds 2018-12-31 22:00:00 351758 Hong Kong 10.32 7.27 9.0 13.289 1019 67 2.6 354 36 802 Clouds scattered clouds 2018-12-31 23:00:00 351759 Hong Kong 10.20 7.13 9.0 13.178 1018 67 2.6 354 52 803 Clouds broken clouds 2019-01-01 00:00:00 17525 rows \u00d7 14 columns Merge \u00b6 def merge_weather ( df : pd . DataFrame , weather : pd . DataFrame ) -> pd . DataFrame : ''' Merge weather with data. ''' new_df = df . copy () new_weather = weather . copy () new_df [ 'tmp_date' ] = new_df [ 'date' ] new_weather [ 'tmp_date' ] = new_weather [ 'date' ] new_training_data = new_df . merge ( new_weather , on = 'tmp_date' , how = 'left' ) new_training_data = new_training_data . drop ([ 'tmp_date' , 'date_y' ], axis = 1 ) new_training_data = new_training_data . rename ( columns = { 'date_x' : 'date' } ) return new_training_data new_training_data = merge_weather ( train , weather ) new_training_data .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } date speed IsWeekend IsHoliday hour_modify city_name temp feels_like temp_min temp_max pressure humidity wind_speed wind_deg clouds_all weather_id weather_main weather_description 0 2017-01-01 00:00:00 43.002930 1 1 Late_Night Hong Kong 18.04 18.64 16.50 20.000 1022 83 1.5 99 7 800 Clear sky is clear 1 2017-01-01 01:00:00 46.118696 1 1 Late_Night Hong Kong 17.92 18.22 16.00 20.000 1022 76 1.2 76 15 801 Clouds few clouds 2 2017-01-01 02:00:00 44.294158 1 1 Late_Night Hong Kong 17.90 18.19 16.00 20.000 1022 76 1.2 76 20 801 Clouds few clouds 3 2017-01-01 03:00:00 41.067468 1 1 Late_Night Hong Kong 17.79 18.05 16.00 19.526 1022 76 1.2 76 29 802 Clouds scattered clouds 4 2017-01-01 04:00:00 46.448653 1 1 Early_Morning Hong Kong 17.75 17.23 16.00 19.468 1021 75 2.2 53 19 801 Clouds few clouds ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 14004 2018-12-31 12:00:00 19.865269 0 0 Afternoon Hong Kong 11.71 7.88 10.70 13.500 1028 61 3.7 341 72 803 Clouds broken clouds 14005 2018-12-31 15:00:00 17.820375 0 0 Afternoon Hong Kong 12.36 9.75 10.56 15.560 1016 56 1.8 342 44 802 Clouds scattered clouds 14006 2018-12-31 16:00:00 12.501851 0 0 Evening Hong Kong 12.06 8.93 10.00 15.054 1016 58 2.6 349 39 802 Clouds scattered clouds 14007 2018-12-31 18:00:00 15.979319 0 0 Evening Hong Kong 11.70 8.51 10.00 13.890 1017 58 2.6 349 48 802 Clouds scattered clouds 14008 2018-12-31 20:00:00 40.594183 0 0 Night Hong Kong 10.91 7.88 9.00 13.273 1019 65 2.6 347 58 803 Clouds broken clouds 14009 rows \u00d7 18 columns Plot data \u00b6 Univariate analysis \u00b6 plt.figure(figsize=(6,4)) sns.boxplot('speed',data=new_training_data,orient='h',palette=\"Set3\",linewidth=2.5) plt.show() /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variable as a keyword arg: x. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. FutureWarning Traffic speed across months. \u00b6 data_plot = new_training_data data_plot['month'] = data_plot['date'].dt.month data_plot .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } date speed IsWeekend IsHoliday hour_modify city_name temp feels_like temp_min temp_max pressure humidity wind_speed wind_deg clouds_all weather_id weather_main weather_description month 0 2017-01-01 00:00:00 43.002930 1 1 Late_Night Hong Kong 18.04 18.64 16.50 20.000 1022 83 1.5 99 7 800 Clear sky is clear 1 1 2017-01-01 01:00:00 46.118696 1 1 Late_Night Hong Kong 17.92 18.22 16.00 20.000 1022 76 1.2 76 15 801 Clouds few clouds 1 2 2017-01-01 02:00:00 44.294158 1 1 Late_Night Hong Kong 17.90 18.19 16.00 20.000 1022 76 1.2 76 20 801 Clouds few clouds 1 3 2017-01-01 03:00:00 41.067468 1 1 Late_Night Hong Kong 17.79 18.05 16.00 19.526 1022 76 1.2 76 29 802 Clouds scattered clouds 1 4 2017-01-01 04:00:00 46.448653 1 1 Early_Morning Hong Kong 17.75 17.23 16.00 19.468 1021 75 2.2 53 19 801 Clouds few clouds 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 14004 2018-12-31 12:00:00 19.865269 0 0 Afternoon Hong Kong 11.71 7.88 10.70 13.500 1028 61 3.7 341 72 803 Clouds broken clouds 12 14005 2018-12-31 15:00:00 17.820375 0 0 Afternoon Hong Kong 12.36 9.75 10.56 15.560 1016 56 1.8 342 44 802 Clouds scattered clouds 12 14006 2018-12-31 16:00:00 12.501851 0 0 Evening Hong Kong 12.06 8.93 10.00 15.054 1016 58 2.6 349 39 802 Clouds scattered clouds 12 14007 2018-12-31 18:00:00 15.979319 0 0 Evening Hong Kong 11.70 8.51 10.00 13.890 1017 58 2.6 349 48 802 Clouds scattered clouds 12 14008 2018-12-31 20:00:00 40.594183 0 0 Night Hong Kong 10.91 7.88 9.00 13.273 1019 65 2.6 347 58 803 Clouds broken clouds 12 14009 rows \u00d7 19 columns tmp_data=new_training_data.groupby('month').aggregate({'speed':'mean'}) plt.figure(figsize=(8,6)) sns.lineplot(x=tmp_data.index,y=tmp_data.speed,data=tmp_data,palette=\"Set2\") plt.show() Count on different hour stage. \u00b6 plt.figure(figsize=(8,6)) sns.countplot(y='hour_modify',data=new_training_data,palette=[\"#7fcdbb\",\"#edf8b1\",\"#fc9272\",\"#fee0d2\",\"#bcbddc\",\"#efedf5\"]) plt.show() new_training_data.hist(bins=50,figsize=(20,15)) plt.show() num_vars = [ 'speed' , 'temp_max' , 'temp_min' , 'pressure' , 'humidity' , 'wind_speed' , 'wind_deg' ] from pandas.plotting import scatter_matrix scatter_matrix ( new_training_data [ num_vars ], figsize = ( 20 , 15 )) plt . show () plt . figure ( figsize = ( 10 , 8 )) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'temp_max' , data = new_training_data ) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'temp_min' , data = new_training_data ) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'pressure' , data = new_training_data ) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'wind_speed' , data = new_training_data ) plt . show () <Figure size 720x576 with 0 Axes> Train \u00b6 new_training_data.columns Index(['date', 'speed', 'IsWeekend', 'IsHoliday', 'hour_modify', 'city_name', 'temp', 'feels_like', 'temp_min', 'temp_max', 'pressure', 'humidity', 'wind_speed', 'wind_deg', 'clouds_all', 'weather_id', 'weather_main', 'weather_description', 'month'], dtype='object') target = [ 'speed' ] cat_vars = [ 'IsWeekend' , 'IsHoliday' , 'hour_modify' , 'weather_main' ] num_vars = [ 'temp' , 'pressure' , 'wind_speed' , 'humidity' ] Transform Data \u00b6 numeric_transformer = Pipeline ( steps = [ ( 'scaler' , MinMaxScaler ())]) categorical_transformer = Pipeline ( steps = [ ( 'oneHot' , OneHotEncoder ())]) preprocessor = ColumnTransformer ( transformers = [ ( 'num' , numeric_transformer , num_vars ), ( 'cat' , categorical_transformer , cat_vars )]) data_transformed = preprocessor . fit_transform ( new_training_data ) print ( data_transformed ) [[0.39633333 0.8627451 0.08557457 ... 0. 0. 0. ] [0.39233333 0.8627451 0.06723716 ... 0. 0. 0. ] [0.39166667 0.8627451 0.06723716 ... 0. 0. 0. ] ... [0.197 0.74509804 0.15281174 ... 0. 0. 0. ] [0.185 0.76470588 0.15281174 ... 0. 0. 0. ] [0.15866667 0.80392157 0.15281174 ... 0. 0. 0. ]] y = new_training_data['speed'] y = y.to_numpy() y = y.reshape(-1, 1) print(y.shape) print(y) (14009, 1) [[43.00293016] [46.11869568] [44.29415804] ... [12.50185109] [15.97931873] [40.59418269]] We want to scale the speed import numpy as np scaler = MinMaxScaler () scaler . fit ( y ) scaled_y = scaler . transform ( y ) print ( scaled_y ) [[0.79919383] [0.86078499] [0.82471829] ... [0.19626117] [0.2650023 ] [0.75157871]] Split data \u00b6 X_train,X_test,y_train,y_test=train_test_split(data_transformed,scaled_y,test_size=0.15,random_state=42) print(X_train) print(y_train) print(f\"Train x shape: {X_train.shape}\") print(f\"Train y shape: {y_train.shape}\") [[0.317 0.78431373 0.06723716 ... 0. 0. 0. ] [0.685 0.45098039 0.02444988 ... 0. 1. 0. ] [0.73766667 0.45098039 0.04278729 ... 0. 1. 0. ] ... [0.76433333 0.60784314 0.17114914 ... 0. 0. 0. ] [0.73666667 0.47058824 0.24449878 ... 0. 0. 0. ] [0.45066667 0.84313725 0.18948655 ... 0. 0. 0. ]] [[0.8790785 ] [0.81078519] [0.52453309] ... [0.81087369] [0.87076018] [0.33936164]] Train x shape: (11907, 21) Train y shape: (11907, 1) Training by using DNN \u00b6 import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers from tensorflow.keras.metrics import MeanSquaredError from tensorflow.keras import regularizers print ( X_train . shape ) (11907, 21) early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 1 ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 01 ) model . compile ( loss = 'mean_squared_error' , optimizer = opt , metrics = [ 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 200 , validation_split = 0.1 , callbacks =[ early_stop ] ,) Epoch 1/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0278 - mae: 0.1193 - mse: 0.0278 - val_loss: 0.0192 - val_mae: 0.0996 - val_mse: 0.0192 Epoch 2/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0214 - mae: 0.1076 - mse: 0.0214 - val_loss: 0.0187 - val_mae: 0.1035 - val_mse: 0.0187 Epoch 3/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0212 - mae: 0.1067 - mse: 0.0212 - val_loss: 0.0194 - val_mae: 0.1105 - val_mse: 0.0194 Epoch 4/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0212 - mae: 0.1071 - mse: 0.0212 - val_loss: 0.0177 - val_mae: 0.0987 - val_mse: 0.0177 Epoch 5/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0206 - mae: 0.1044 - mse: 0.0206 - val_loss: 0.0180 - val_mae: 0.1008 - val_mse: 0.0180 Epoch 6/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0209 - mae: 0.1060 - mse: 0.0209 - val_loss: 0.0185 - val_mae: 0.1064 - val_mse: 0.0185 Epoch 7/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1035 - mse: 0.0204 - val_loss: 0.0185 - val_mae: 0.1006 - val_mse: 0.0185 Epoch 8/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0209 - mae: 0.1062 - mse: 0.0209 - val_loss: 0.0182 - val_mae: 0.1005 - val_mse: 0.0182 Epoch 9/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0206 - mae: 0.1045 - mse: 0.0206 - val_loss: 0.0175 - val_mae: 0.0973 - val_mse: 0.0175 Epoch 10/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0205 - mae: 0.1042 - mse: 0.0205 - val_loss: 0.0181 - val_mae: 0.1021 - val_mse: 0.0181 Epoch 11/200 335/335 [==============================] - 1s 4ms/step - loss: 0.0205 - mae: 0.1040 - mse: 0.0205 - val_loss: 0.0176 - val_mae: 0.0945 - val_mse: 0.0176 Epoch 12/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0206 - mae: 0.1048 - mse: 0.0206 - val_loss: 0.0184 - val_mae: 0.1049 - val_mse: 0.0184 Epoch 13/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1039 - mse: 0.0204 - val_loss: 0.0184 - val_mae: 0.1031 - val_mse: 0.0184 Epoch 14/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1037 - mse: 0.0204 - val_loss: 0.0178 - val_mae: 0.1001 - val_mse: 0.0178 Epoch 15/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0203 - mae: 0.1036 - mse: 0.0203 - val_loss: 0.0174 - val_mae: 0.0962 - val_mse: 0.0174 Epoch 16/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0205 - mae: 0.1038 - mse: 0.0205 - val_loss: 0.0176 - val_mae: 0.0993 - val_mse: 0.0176 Epoch 17/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0203 - mae: 0.1033 - mse: 0.0203 - val_loss: 0.0181 - val_mae: 0.1031 - val_mse: 0.0181 Epoch 18/200 335/335 [==============================] - 1s 4ms/step - loss: 0.0202 - mae: 0.1032 - mse: 0.0202 - val_loss: 0.0179 - val_mae: 0.0978 - val_mse: 0.0179 Epoch 19/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1038 - mse: 0.0204 - val_loss: 0.0181 - val_mae: 0.1021 - val_mse: 0.0181 Epoch 20/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0205 - mae: 0.1045 - mse: 0.0205 - val_loss: 0.0182 - val_mae: 0.1014 - val_mse: 0.0182 Epoch 21/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0202 - mae: 0.1029 - mse: 0.0202 - val_loss: 0.0174 - val_mae: 0.0971 - val_mse: 0.0174 Epoch 22/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1017 - mse: 0.0200 - val_loss: 0.0175 - val_mae: 0.0974 - val_mse: 0.0175 Epoch 23/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0203 - mae: 0.1037 - mse: 0.0203 - val_loss: 0.0180 - val_mae: 0.1031 - val_mse: 0.0180 Epoch 24/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0201 - mae: 0.1025 - mse: 0.0201 - val_loss: 0.0178 - val_mae: 0.0992 - val_mse: 0.0178 Epoch 25/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0202 - mae: 0.1028 - mse: 0.0202 - val_loss: 0.0176 - val_mae: 0.0970 - val_mse: 0.0176 Epoch 26/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1020 - mse: 0.0200 - val_loss: 0.0174 - val_mae: 0.0986 - val_mse: 0.0174 Epoch 27/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0201 - mae: 0.1029 - mse: 0.0201 - val_loss: 0.0173 - val_mae: 0.0966 - val_mse: 0.0173 Epoch 28/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1023 - mse: 0.0200 - val_loss: 0.0178 - val_mae: 0.1007 - val_mse: 0.0178 Epoch 29/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1022 - mse: 0.0200 - val_loss: 0.0174 - val_mae: 0.0964 - val_mse: 0.0174 Epoch 30/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0201 - mae: 0.1025 - mse: 0.0201 - val_loss: 0.0172 - val_mae: 0.0940 - val_mse: 0.0172 Epoch 31/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1023 - mse: 0.0200 - val_loss: 0.0174 - val_mae: 0.0959 - val_mse: 0.0174 Epoch 32/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1019 - mse: 0.0200 - val_loss: 0.0180 - val_mae: 0.1017 - val_mse: 0.0180 Epoch 33/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0199 - mae: 0.1019 - mse: 0.0199 - val_loss: 0.0183 - val_mae: 0.0998 - val_mse: 0.0183 Epoch 34/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1023 - mse: 0.0200 - val_loss: 0.0180 - val_mae: 0.1003 - val_mse: 0.0180 Epoch 35/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1016 - mse: 0.0197 - val_loss: 0.0172 - val_mae: 0.0931 - val_mse: 0.0172 Epoch 36/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1017 - mse: 0.0198 - val_loss: 0.0178 - val_mae: 0.1011 - val_mse: 0.0178 Epoch 37/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0199 - mae: 0.1024 - mse: 0.0199 - val_loss: 0.0191 - val_mae: 0.1026 - val_mse: 0.0191 Epoch 38/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1018 - mse: 0.0198 - val_loss: 0.0174 - val_mae: 0.0971 - val_mse: 0.0174 Epoch 39/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1020 - mse: 0.0198 - val_loss: 0.0176 - val_mae: 0.0961 - val_mse: 0.0176 Epoch 40/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1031 - mse: 0.0200 - val_loss: 0.0184 - val_mae: 0.1042 - val_mse: 0.0184 Epoch 41/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1014 - mse: 0.0197 - val_loss: 0.0175 - val_mae: 0.0973 - val_mse: 0.0175 Epoch 42/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1013 - mse: 0.0198 - val_loss: 0.0179 - val_mae: 0.1025 - val_mse: 0.0179 Epoch 43/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1017 - mse: 0.0197 - val_loss: 0.0180 - val_mae: 0.0994 - val_mse: 0.0180 Epoch 44/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1019 - mse: 0.0197 - val_loss: 0.0172 - val_mae: 0.0935 - val_mse: 0.0172 Epoch 45/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1026 - mse: 0.0200 - val_loss: 0.0178 - val_mae: 0.0984 - val_mse: 0.0178 Epoch 46/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1013 - mse: 0.0197 - val_loss: 0.0180 - val_mae: 0.1028 - val_mse: 0.0180 Epoch 47/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1020 - mse: 0.0198 - val_loss: 0.0178 - val_mae: 0.0978 - val_mse: 0.0178 Epoch 48/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1017 - mse: 0.0198 - val_loss: 0.0172 - val_mae: 0.0952 - val_mse: 0.0172 Epoch 49/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1016 - mse: 0.0197 - val_loss: 0.0194 - val_mae: 0.1072 - val_mse: 0.0194 Epoch 50/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0196 - mae: 0.1008 - mse: 0.0196 - val_loss: 0.0176 - val_mae: 0.0965 - val_mse: 0.0176 plot def plot_history ( history ) : hist = pd . DataFrame ( history . history ) hist [ 'epoch' ] = history . epoch plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Abs Error [MPG]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mae' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mae' ] , label = 'Val Error' ) plt . legend () plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Square Error [$MPG^2$]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mse' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mse' ] , label = 'Val Error' ) plt . legend () plt . show () plot_history ( history ) Training by using Decision Tree \u00b6 from sklearn import tree tree_clf = tree.DecisionTreeRegressor() tree_clf.fit(X_train, y_train) DecisionTreeRegressor(ccp_alpha=0.0, criterion='mse', max_depth=None, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort='deprecated', random_state=None, splitter='best') Training by using Regression \u00b6 tscv = TimeSeriesSplit ( n_splits = 3 ) model1 = XGBRegressor () param_grid = {' nthread ' : [ 4 , 6 , 8 ], ' objective ' : [' reg : squarederror '], ' learning_rate ' : [ .03 , 0.05 , .07 ], ' max_depth ' : [ 5 , 6 , 7 ], ' min_child_weight ' : [ 4 ], ' subsample ' : [ 0.7 ], ' colsample_bytree ' : [ 0.7 ], ' n_estimators ' : [ 500 ]} GridSearch = GridSearchCV ( estimator = model1 , param_grid = param_grid , cv = tscv , n_jobs = 4 , verbose = 10 ) GridSearch . fit ( X_train , y_train ) Fitting 3 folds for each of 27 candidates, totalling 81 fits [Parallel(n_jobs=4)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=4)]: Done 5 tasks | elapsed: 25.8s [Parallel(n_jobs=4)]: Done 10 tasks | elapsed: 2.8min [Parallel(n_jobs=4)]: Done 17 tasks | elapsed: 5.8min [Parallel(n_jobs=4)]: Done 24 tasks | elapsed: 6.7min [Parallel(n_jobs=4)]: Done 33 tasks | elapsed: 9.8min [Parallel(n_jobs=4)]: Done 42 tasks | elapsed: 10.8min [Parallel(n_jobs=4)]: Done 53 tasks | elapsed: 16.7min [Parallel(n_jobs=4)]: Done 64 tasks | elapsed: 19.4min [Parallel(n_jobs=4)]: Done 81 out of 81 | elapsed: 22.1min finished /usr/local/lib/python3.6/dist-packages/xgboost/sklearn.py:242: DeprecationWarning: The nthread parameter is deprecated as of version .6.Please use n_jobs instead.nthread is deprecated. 'nthread is deprecated.', DeprecationWarning) GridSearchCV(cv=TimeSeriesSplit(max_train_size=None, n_splits=3), error_score=nan, estimator=XGBRegressor(base_score=0.5, booster='gbtree', colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1, gamma=0, importance_type='gain', learning_rate=0.1, max_delta_step=0, max_depth=3, min_child_weight=1, missing=None, n_estimators=100, n_jobs=1, nthread=None, objectiv... scale_pos_weight=1, seed=None, silent=None, subsample=1, verbosity=1), iid='deprecated', n_jobs=4, param_grid={'colsample_bytree': [0.7], 'learning_rate': [0.03, 0.05, 0.07], 'max_depth': [5, 6, 7], 'min_child_weight': [4], 'n_estimators': [500], 'nthread': [4, 6, 8], 'objective': ['reg:squarederror'], 'subsample': [0.7]}, pre_dispatch='2*n_jobs', refit=True, return_train_score=False, scoring=None, verbose=10) Training by using Ridge Regression \u00b6 from sklearn import linear_model reg = linear_model . Ridge ( alpha =. 5 ) reg . fit ( X_train , y_train ) Ridge(alpha=0.5, copy_X=True, fit_intercept=True, max_iter=None, normalize=False, random_state=None, solver='auto', tol=0.001) Training by using Random forest \u00b6 model2 = RandomForestRegressor () param_grid2 = { 'n_estimators' :[ 10 , 50 , 100 , 1000 ], 'max_features' :[ 1 , 2 , 3 ] } GridSearch2 = GridSearchCV ( estimator = model2 , param_grid = param_grid2 , cv = tscv , n_jobs = 10 , verbose = 10 ) GridSearch2 . fit ( X_train , y_train ) Fitting 3 folds for each of 12 candidates, totalling 36 fits [Parallel(n_jobs=10)]: Using backend LokyBackend with 10 concurrent workers. [Parallel(n_jobs=10)]: Done 5 tasks | elapsed: 3.1s [Parallel(n_jobs=10)]: Done 12 tasks | elapsed: 5.1s [Parallel(n_jobs=10)]: Done 21 out of 36 | elapsed: 7.8s remaining: 5.6s [Parallel(n_jobs=10)]: Done 25 out of 36 | elapsed: 9.5s remaining: 4.2s [Parallel(n_jobs=10)]: Done 29 out of 36 | elapsed: 21.6s remaining: 5.2s [Parallel(n_jobs=10)]: Done 33 out of 36 | elapsed: 31.1s remaining: 2.8s [Parallel(n_jobs=10)]: Done 36 out of 36 | elapsed: 35.9s finished /usr/local/lib/python3.6/dist-packages/sklearn/model_selection/_search.py:739: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples,), for example using ravel(). self.best_estimator_.fit(X, y, **fit_params) GridSearchCV(cv=TimeSeriesSplit(max_train_size=None, n_splits=3), error_score=nan, estimator=RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion='mse', max_depth=None, max_features='auto', max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False), iid='deprecated', n_jobs=10, param_grid={'max_features': [1, 2, 3], 'n_estimators': [10, 50, 100, 1000]}, pre_dispatch='2*n_jobs', refit=True, return_train_score=False, scoring=None, verbose=10) Training by using SVM \u00b6 model3 = svm . SVR () param_grid3 = { 'kernel' : [ 'rbf' ], 'gamma' : [ 1 e - 3 , 1 e - 4 ], 'C' : [ 1 , 10 , 100 , 1000 ] } GridSearch3 = GridSearchCV ( estimator = model3 , n_jobs = 10 , verbose = 10 , param_grid = param_grid3 ) GridSearch3 . fit ( X_train , y_train , ) Fitting 5 folds for each of 8 candidates, totalling 40 fits [Parallel(n_jobs=10)]: Using backend LokyBackend with 10 concurrent workers. [Parallel(n_jobs=10)]: Done 5 tasks | elapsed: 15.0s [Parallel(n_jobs=10)]: Done 12 tasks | elapsed: 24.1s [Parallel(n_jobs=10)]: Done 21 tasks | elapsed: 35.6s [Parallel(n_jobs=10)]: Done 26 out of 40 | elapsed: 43.0s remaining: 23.2s [Parallel(n_jobs=10)]: Done 31 out of 40 | elapsed: 50.7s remaining: 14.7s [Parallel(n_jobs=10)]: Done 36 out of 40 | elapsed: 54.0s remaining: 6.0s [Parallel(n_jobs=10)]: Done 40 out of 40 | elapsed: 54.9s finished /usr/local/lib/python3.6/dist-packages/sklearn/utils/validation.py:760: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True) GridSearchCV(cv=None, error_score=nan, estimator=SVR(C=1.0, cache_size=200, coef0=0.0, degree=3, epsilon=0.1, gamma='scale', kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False), iid='deprecated', n_jobs=10, param_grid={'C': [1, 10, 100, 1000], 'gamma': [0.001, 0.0001], 'kernel': ['rbf']}, pre_dispatch='2*n_jobs', refit=True, return_train_score=False, scoring=None, verbose=10) Training by using Neural network \u00b6 from sklearn.neural_network import MLPRegressor mlp_reg = MLPRegressor ( max_iter = 1000 ) mlp_reg . fit ( X_train , y_train ) /usr/local/lib/python3.6/dist-packages/sklearn/neural_network/_multilayer_perceptron.py:1342: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True) MLPRegressor(activation='relu', alpha=0.0001, batch_size='auto', beta_1=0.9, beta_2=0.999, early_stopping=False, epsilon=1e-08, hidden_layer_sizes=(100,), learning_rate='constant', learning_rate_init=0.001, max_fun=15000, max_iter=1000, momentum=0.9, n_iter_no_change=10, nesterovs_momentum=True, power_t=0.5, random_state=None, shuffle=True, solver='adam', tol=0.0001, validation_fraction=0.1, verbose=False, warm_start=False) Evaluation \u00b6 y_pred = model.predict(X_test) # print(scaler.inverse_transform(y_pred)) # print(scaler.inverse_transform(y_test)) y_pred2 = GridSearch.predict(X_test) y_pred3 = GridSearch2.predict(X_test) y_pred4 = GridSearch3.predict(X_test) y_pred5 = tree_clf.predict(X_test) y_pred6 = reg.predict(X_test) y_pred7 = mlp_reg.predict(X_test) MSE_DNN = mean_squared_error ( y_pred , y_test ) MSE_rg = mean_squared_error ( y_pred2 , y_test ) MSE_rf = mean_squared_error ( y_pred3 , y_test ) MSE_tree = mean_squared_error ( y_pred5 , y_test ) MSE_svr = mean_squared_error ( y_pred4 , y_test ) MSE_ridge = mean_squared_error ( y_pred6 , y_test ) MSE_mlp = mean_squared_error ( y_pred7 , y_test ) print ( 'MSE for XGBoost is ' + str ( MSE_rg )) print ( 'MSE for RandomForest is ' + str ( MSE_rf )) print ( f \"MSE for dnn is: {MSE_DNN}\" ) print ( f \"MSE for decision is: {MSE_tree}\" ) print ( f \"MSE for svr is: {MSE_svr}\" ) print ( f \"MSE for ridge is: {MSE_ridge}\" ) print ( f \"MSE for neural network is: {MSE_mlp}\" ) MSE for XGBoost is 0.01726006344884727 MSE for RandomForest is 0.015177183077877169 MSE for dnn is: 0.021906888345540523 MSE for decision is: 0.025013354977883036 MSE for svr is: 0.020732502038850405 MSE for ridge is: 0.02317702945371461 MSE for neural network is: 0.02032315238540893","title":"Individual project"},{"location":"MSBD5001/project/Individual%20Project/#speed-prediction","text":"In this project, we will use weather data to predict average speed. we will use weather data from openweathermap.org which provides temperature, wind, humidity, and weather conditions This notebook will be running on Google Colab","title":"Speed Prediction"},{"location":"MSBD5001/project/Individual%20Project/#install-and-import-dependencies","text":"! pip install pactools Collecting pactools \u001b[?25l Downloading https://files.pythonhosted.org/packages/17/14/4c4eba6e54408e536be27b9891cea68ea391d7d190936593aa71e5c6405e/pactools-0.3.1-py3-none-any.whl (82kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 92kB 6.1MB/s \u001b[?25hRequirement already satisfied: h5py in /usr/local/lib/python3.6/dist-packages (from pactools) (2.10.0) Collecting mne \u001b[?25l Downloading https://files.pythonhosted.org/packages/4d/0e/6448521738d3357c205795fd5846d023bd7935bb83ba93a1ba0f7124205e/mne-0.21.2-py3-none-any.whl (6.8MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6.8MB 17.1MB/s \u001b[?25hRequirement already satisfied: scipy in /usr/local/lib/python3.6/dist-packages (from pactools) (1.4.1) Requirement already satisfied: numpy in /usr/local/lib/python3.6/dist-packages (from pactools) (1.18.5) Requirement already satisfied: matplotlib in /usr/local/lib/python3.6/dist-packages (from pactools) (3.2.2) Requirement already satisfied: scikit-learn in /usr/local/lib/python3.6/dist-packages (from pactools) (0.22.2.post1) Requirement already satisfied: six in /usr/local/lib/python3.6/dist-packages (from h5py->pactools) (1.15.0) Requirement already satisfied: python-dateutil>=2.1 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (2.8.1) Requirement already satisfied: kiwisolver>=1.0.1 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (1.3.1) Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.1 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (2.4.7) Requirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.6/dist-packages (from matplotlib->pactools) (0.10.0) Requirement already satisfied: joblib>=0.11 in /usr/local/lib/python3.6/dist-packages (from scikit-learn->pactools) (0.17.0) Installing collected packages: mne, pactools Successfully installed mne-0.21.2 pactools-0.3.1 import pandas as pd from sklearn.preprocessing import MinMaxScaler import requests from bs4 import BeautifulSoup from datetime import datetime import tensorflow as tf import seaborn as sns import matplotlib.pyplot as plt from sklearn.pipeline import Pipeline from sklearn.preprocessing import LabelBinarizer , OneHotEncoder , StandardScaler from sklearn.compose import ColumnTransformer from sklearn.model_selection import train_test_split from pactools.grid_search import GridSearchCVProgressBar from sklearn.model_selection import TimeSeriesSplit from sklearn.model_selection import GridSearchCV from sklearn import svm from xgboost import XGBRegressor from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_squared_error /usr/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject return f(*args, **kwds) /usr/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: numpy.ufunc size changed, may indicate binary incompatibility. Expected 192 from C header, got 216 from PyObject return f(*args, **kwds) import tensorflow as tf print ( \"Num GPUs Available: \" , len ( tf . config . experimental . list_physical_devices ( 'GPU' ))) Num GPUs Available: 1","title":"Install and import dependencies"},{"location":"MSBD5001/project/Individual%20Project/#preprocess","text":"","title":"Preprocess"},{"location":"MSBD5001/project/Individual%20Project/#asign-holiday-to-the-table","text":"def hour_modify ( x : datetime ): Early_Morning = [ 4 , 5 , 6 , 7 ] Morning = [ 8 , 9 , 10 , 11 ] Afternoon = [ 12 , 13 , 14 , 15 ] Evening = [ 16 , 17 , 18 , 19 ] Night = [ 20 , 21 , 22 , 23 ] Late_Night = [ 0 , 1 , 2 , 3 ] if x . hour in Early_Morning : return 'Early_Morning' elif x . hour in Morning : return 'Morning' elif x . hour in Afternoon : return 'Afternoon' elif x . hour in Evening : return 'Evening' elif x . hour in Night : return 'Night' else : return 'Late_Night' def add_holiday_and_weekend ( df : pd . DataFrame ) -> pd . DataFrame : \"\"\" Add holiday and weekend to the dataset \"\"\" new_df = df . copy () new_df [ 'IsWeekend' ] = new_df [ 'date' ]. apply ( lambda x : 0 if x . weekday () in [ 0 , 1 , 2 , 3 , 4 ] else 1 ) new_df [ 'IsHoliday' ] = new_df [ 'date' ]. apply ( lambda x : 1 if ( x . date (). strftime ( '%Y-%m-%d' ) in [ '2017-01-02' , '2017-01-28' , '2017-01-30' , '2017-01-31' , '2017-04-04' , '2017-04-14' , '2017-04-15' , '2017-04-17' , '2017-05-01' , '2017-05-03' , '2017-05-30' , '2017-07-01' , '2017-10-02' , '2017-10-05' , '2017-10-28' , '2017-12-25' , '2017-12-26' , '2018-01-01' , '2018-02-16' , '2018-02-17' , '2018-02-19' , '2018-03-30' , '2018-03-31' , '2018-04-02' , '2018-04-05' , '2018-05-01' , '2018-05-22' , '2018-06-18' , '2018-07-02' , '2018-09-25' , '2018-10-01' , '2018-10-17' , '2018-12-25' , '2018-12-26' ]) or ( x . weekday () in [ 6 ]) else 0 ) return new_df I am using google drive to store all the data including the weather data. So please change this line to the your file paths. # change following two lines to your paths train = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/individual project/train.csv' ) test = pd . read_csv ( '/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/individual project/test.csv' ) train = train . drop ( 'id' , axis = 1 ) train [ 'date' ] = pd . to_datetime ( train [ 'date' ]) train = add_holiday_and_weekend ( train ) train [ 'hour_modify' ] = train [ 'date' ]. apply ( hour_modify ) train .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } date speed IsWeekend IsHoliday hour_modify 0 2017-01-01 00:00:00 43.002930 1 1 Late_Night 1 2017-01-01 01:00:00 46.118696 1 1 Late_Night 2 2017-01-01 02:00:00 44.294158 1 1 Late_Night 3 2017-01-01 03:00:00 41.067468 1 1 Late_Night 4 2017-01-01 04:00:00 46.448653 1 1 Early_Morning ... ... ... ... ... ... 14001 2018-12-31 12:00:00 19.865269 0 0 Afternoon 14002 2018-12-31 15:00:00 17.820375 0 0 Afternoon 14003 2018-12-31 16:00:00 12.501851 0 0 Evening 14004 2018-12-31 18:00:00 15.979319 0 0 Evening 14005 2018-12-31 20:00:00 40.594183 0 0 Night 14006 rows \u00d7 5 columns train.plot(x='date', y='speed', figsize=(20, 10)) <matplotlib.axes._subplots.AxesSubplot at 0x7f3ff03ae400>","title":"Asign Holiday to the table"},{"location":"MSBD5001/project/Individual%20Project/#merge-weather","text":"","title":"Merge weather"},{"location":"MSBD5001/project/Individual%20Project/#pre-process-weather-data","text":"from datetime import datetime def k_to_c ( x ): return x - 273.15 # Change this path to yours weather = pd . read_csv ( \"/content/drive/MyDrive/courses/HKUST/MSBD5001/project/data/individual project/hongkong_weather_1970-2020.csv\" ) weather [ 'dt_iso' ] = weather [ 'dt_iso' ] . apply ( lambda x : x . replace ( 'UTC' , '' )) weather [ 'date' ] = pd . to_datetime ( weather [ 'dt_iso' ] ). dt . tz_convert ( \"Asia/Hong_Kong\" ). dt . tz_localize ( None ) # Transform unit weather [ 'temp' ] = weather [ 'temp' ] . apply ( k_to_c ) weather [ 'feels_like' ] = weather [ 'feels_like' ] . apply ( k_to_c ) weather [ 'temp_min' ] = weather [ 'temp_min' ] . apply ( k_to_c ) weather [ 'temp_max' ] = weather [ 'temp_max' ] . apply ( k_to_c ) weather = weather . drop ( [ \"dt_iso\", \"dt\", \"weather_icon\", \"rain_1h\", \"rain_3h\", \"snow_1h\", \"snow_3h\", \"sea_level\", \"grnd_level\", \"timezone\", \"lat\", \"lon\" ] , axis = 1 ) mask = ( weather [ 'date' ] >= datetime ( 2017 , 1 , 1 )) & ( weather [ 'date' ] <= datetime ( 2019 , 1 , 1 )) weather = weather . loc [ mask ] weather .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } city_name temp feels_like temp_min temp_max pressure humidity wind_speed wind_deg clouds_all weather_id weather_main weather_description date 334235 Hong Kong 18.04 18.64 16.5 20.000 1022 83 1.5 99 7 800 Clear sky is clear 2017-01-01 00:00:00 334236 Hong Kong 17.92 18.22 16.0 20.000 1022 76 1.2 76 15 801 Clouds few clouds 2017-01-01 01:00:00 334237 Hong Kong 17.90 18.19 16.0 20.000 1022 76 1.2 76 20 801 Clouds few clouds 2017-01-01 02:00:00 334238 Hong Kong 17.79 18.05 16.0 19.526 1022 76 1.2 76 29 802 Clouds scattered clouds 2017-01-01 03:00:00 334239 Hong Kong 17.75 17.23 16.0 19.468 1021 75 2.2 53 19 801 Clouds few clouds 2017-01-01 04:00:00 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 351755 Hong Kong 10.91 7.88 9.0 13.273 1019 65 2.6 347 58 803 Clouds broken clouds 2018-12-31 20:00:00 351756 Hong Kong 10.68 7.61 9.0 13.255 1019 65 2.6 347 56 803 Clouds broken clouds 2018-12-31 21:00:00 351757 Hong Kong 10.52 7.51 9.0 13.279 1019 67 2.6 354 52 803 Clouds broken clouds 2018-12-31 22:00:00 351758 Hong Kong 10.32 7.27 9.0 13.289 1019 67 2.6 354 36 802 Clouds scattered clouds 2018-12-31 23:00:00 351759 Hong Kong 10.20 7.13 9.0 13.178 1018 67 2.6 354 52 803 Clouds broken clouds 2019-01-01 00:00:00 17525 rows \u00d7 14 columns","title":"Pre-process weather data"},{"location":"MSBD5001/project/Individual%20Project/#merge","text":"def merge_weather ( df : pd . DataFrame , weather : pd . DataFrame ) -> pd . DataFrame : ''' Merge weather with data. ''' new_df = df . copy () new_weather = weather . copy () new_df [ 'tmp_date' ] = new_df [ 'date' ] new_weather [ 'tmp_date' ] = new_weather [ 'date' ] new_training_data = new_df . merge ( new_weather , on = 'tmp_date' , how = 'left' ) new_training_data = new_training_data . drop ([ 'tmp_date' , 'date_y' ], axis = 1 ) new_training_data = new_training_data . rename ( columns = { 'date_x' : 'date' } ) return new_training_data new_training_data = merge_weather ( train , weather ) new_training_data .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } date speed IsWeekend IsHoliday hour_modify city_name temp feels_like temp_min temp_max pressure humidity wind_speed wind_deg clouds_all weather_id weather_main weather_description 0 2017-01-01 00:00:00 43.002930 1 1 Late_Night Hong Kong 18.04 18.64 16.50 20.000 1022 83 1.5 99 7 800 Clear sky is clear 1 2017-01-01 01:00:00 46.118696 1 1 Late_Night Hong Kong 17.92 18.22 16.00 20.000 1022 76 1.2 76 15 801 Clouds few clouds 2 2017-01-01 02:00:00 44.294158 1 1 Late_Night Hong Kong 17.90 18.19 16.00 20.000 1022 76 1.2 76 20 801 Clouds few clouds 3 2017-01-01 03:00:00 41.067468 1 1 Late_Night Hong Kong 17.79 18.05 16.00 19.526 1022 76 1.2 76 29 802 Clouds scattered clouds 4 2017-01-01 04:00:00 46.448653 1 1 Early_Morning Hong Kong 17.75 17.23 16.00 19.468 1021 75 2.2 53 19 801 Clouds few clouds ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 14004 2018-12-31 12:00:00 19.865269 0 0 Afternoon Hong Kong 11.71 7.88 10.70 13.500 1028 61 3.7 341 72 803 Clouds broken clouds 14005 2018-12-31 15:00:00 17.820375 0 0 Afternoon Hong Kong 12.36 9.75 10.56 15.560 1016 56 1.8 342 44 802 Clouds scattered clouds 14006 2018-12-31 16:00:00 12.501851 0 0 Evening Hong Kong 12.06 8.93 10.00 15.054 1016 58 2.6 349 39 802 Clouds scattered clouds 14007 2018-12-31 18:00:00 15.979319 0 0 Evening Hong Kong 11.70 8.51 10.00 13.890 1017 58 2.6 349 48 802 Clouds scattered clouds 14008 2018-12-31 20:00:00 40.594183 0 0 Night Hong Kong 10.91 7.88 9.00 13.273 1019 65 2.6 347 58 803 Clouds broken clouds 14009 rows \u00d7 18 columns","title":"Merge"},{"location":"MSBD5001/project/Individual%20Project/#plot-data","text":"","title":"Plot data"},{"location":"MSBD5001/project/Individual%20Project/#univariate-analysis","text":"plt.figure(figsize=(6,4)) sns.boxplot('speed',data=new_training_data,orient='h',palette=\"Set3\",linewidth=2.5) plt.show() /usr/local/lib/python3.6/dist-packages/seaborn/_decorators.py:43: FutureWarning: Pass the following variable as a keyword arg: x. From version 0.12, the only valid positional argument will be `data`, and passing other arguments without an explicit keyword will result in an error or misinterpretation. FutureWarning","title":"Univariate analysis"},{"location":"MSBD5001/project/Individual%20Project/#traffic-speed-across-months","text":"data_plot = new_training_data data_plot['month'] = data_plot['date'].dt.month data_plot .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } date speed IsWeekend IsHoliday hour_modify city_name temp feels_like temp_min temp_max pressure humidity wind_speed wind_deg clouds_all weather_id weather_main weather_description month 0 2017-01-01 00:00:00 43.002930 1 1 Late_Night Hong Kong 18.04 18.64 16.50 20.000 1022 83 1.5 99 7 800 Clear sky is clear 1 1 2017-01-01 01:00:00 46.118696 1 1 Late_Night Hong Kong 17.92 18.22 16.00 20.000 1022 76 1.2 76 15 801 Clouds few clouds 1 2 2017-01-01 02:00:00 44.294158 1 1 Late_Night Hong Kong 17.90 18.19 16.00 20.000 1022 76 1.2 76 20 801 Clouds few clouds 1 3 2017-01-01 03:00:00 41.067468 1 1 Late_Night Hong Kong 17.79 18.05 16.00 19.526 1022 76 1.2 76 29 802 Clouds scattered clouds 1 4 2017-01-01 04:00:00 46.448653 1 1 Early_Morning Hong Kong 17.75 17.23 16.00 19.468 1021 75 2.2 53 19 801 Clouds few clouds 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 14004 2018-12-31 12:00:00 19.865269 0 0 Afternoon Hong Kong 11.71 7.88 10.70 13.500 1028 61 3.7 341 72 803 Clouds broken clouds 12 14005 2018-12-31 15:00:00 17.820375 0 0 Afternoon Hong Kong 12.36 9.75 10.56 15.560 1016 56 1.8 342 44 802 Clouds scattered clouds 12 14006 2018-12-31 16:00:00 12.501851 0 0 Evening Hong Kong 12.06 8.93 10.00 15.054 1016 58 2.6 349 39 802 Clouds scattered clouds 12 14007 2018-12-31 18:00:00 15.979319 0 0 Evening Hong Kong 11.70 8.51 10.00 13.890 1017 58 2.6 349 48 802 Clouds scattered clouds 12 14008 2018-12-31 20:00:00 40.594183 0 0 Night Hong Kong 10.91 7.88 9.00 13.273 1019 65 2.6 347 58 803 Clouds broken clouds 12 14009 rows \u00d7 19 columns tmp_data=new_training_data.groupby('month').aggregate({'speed':'mean'}) plt.figure(figsize=(8,6)) sns.lineplot(x=tmp_data.index,y=tmp_data.speed,data=tmp_data,palette=\"Set2\") plt.show()","title":"Traffic speed across months."},{"location":"MSBD5001/project/Individual%20Project/#count-on-different-hour-stage","text":"plt.figure(figsize=(8,6)) sns.countplot(y='hour_modify',data=new_training_data,palette=[\"#7fcdbb\",\"#edf8b1\",\"#fc9272\",\"#fee0d2\",\"#bcbddc\",\"#efedf5\"]) plt.show() new_training_data.hist(bins=50,figsize=(20,15)) plt.show() num_vars = [ 'speed' , 'temp_max' , 'temp_min' , 'pressure' , 'humidity' , 'wind_speed' , 'wind_deg' ] from pandas.plotting import scatter_matrix scatter_matrix ( new_training_data [ num_vars ], figsize = ( 20 , 15 )) plt . show () plt . figure ( figsize = ( 10 , 8 )) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'temp_max' , data = new_training_data ) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'temp_min' , data = new_training_data ) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'pressure' , data = new_training_data ) sns . set_style ( 'darkgrid' ) sns . jointplot ( y = 'speed' , x = 'wind_speed' , data = new_training_data ) plt . show () <Figure size 720x576 with 0 Axes>","title":"Count on different hour stage."},{"location":"MSBD5001/project/Individual%20Project/#train","text":"new_training_data.columns Index(['date', 'speed', 'IsWeekend', 'IsHoliday', 'hour_modify', 'city_name', 'temp', 'feels_like', 'temp_min', 'temp_max', 'pressure', 'humidity', 'wind_speed', 'wind_deg', 'clouds_all', 'weather_id', 'weather_main', 'weather_description', 'month'], dtype='object') target = [ 'speed' ] cat_vars = [ 'IsWeekend' , 'IsHoliday' , 'hour_modify' , 'weather_main' ] num_vars = [ 'temp' , 'pressure' , 'wind_speed' , 'humidity' ]","title":"Train"},{"location":"MSBD5001/project/Individual%20Project/#transform-data","text":"numeric_transformer = Pipeline ( steps = [ ( 'scaler' , MinMaxScaler ())]) categorical_transformer = Pipeline ( steps = [ ( 'oneHot' , OneHotEncoder ())]) preprocessor = ColumnTransformer ( transformers = [ ( 'num' , numeric_transformer , num_vars ), ( 'cat' , categorical_transformer , cat_vars )]) data_transformed = preprocessor . fit_transform ( new_training_data ) print ( data_transformed ) [[0.39633333 0.8627451 0.08557457 ... 0. 0. 0. ] [0.39233333 0.8627451 0.06723716 ... 0. 0. 0. ] [0.39166667 0.8627451 0.06723716 ... 0. 0. 0. ] ... [0.197 0.74509804 0.15281174 ... 0. 0. 0. ] [0.185 0.76470588 0.15281174 ... 0. 0. 0. ] [0.15866667 0.80392157 0.15281174 ... 0. 0. 0. ]] y = new_training_data['speed'] y = y.to_numpy() y = y.reshape(-1, 1) print(y.shape) print(y) (14009, 1) [[43.00293016] [46.11869568] [44.29415804] ... [12.50185109] [15.97931873] [40.59418269]] We want to scale the speed import numpy as np scaler = MinMaxScaler () scaler . fit ( y ) scaled_y = scaler . transform ( y ) print ( scaled_y ) [[0.79919383] [0.86078499] [0.82471829] ... [0.19626117] [0.2650023 ] [0.75157871]]","title":"Transform Data"},{"location":"MSBD5001/project/Individual%20Project/#split-data","text":"X_train,X_test,y_train,y_test=train_test_split(data_transformed,scaled_y,test_size=0.15,random_state=42) print(X_train) print(y_train) print(f\"Train x shape: {X_train.shape}\") print(f\"Train y shape: {y_train.shape}\") [[0.317 0.78431373 0.06723716 ... 0. 0. 0. ] [0.685 0.45098039 0.02444988 ... 0. 1. 0. ] [0.73766667 0.45098039 0.04278729 ... 0. 1. 0. ] ... [0.76433333 0.60784314 0.17114914 ... 0. 0. 0. ] [0.73666667 0.47058824 0.24449878 ... 0. 0. 0. ] [0.45066667 0.84313725 0.18948655 ... 0. 0. 0. ]] [[0.8790785 ] [0.81078519] [0.52453309] ... [0.81087369] [0.87076018] [0.33936164]] Train x shape: (11907, 21) Train y shape: (11907, 1)","title":"Split data"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-dnn","text":"import tensorflow as tf from tensorflow import keras from tensorflow.keras import layers from tensorflow.keras.metrics import MeanSquaredError from tensorflow.keras import regularizers print ( X_train . shape ) (11907, 21) early_stop = keras . callbacks . EarlyStopping ( monitor = 'val_loss' , patience = 20 ) model = keras . Sequential ( [ layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 64 , activation = \"relu\" , input_shape = ( X_train . shape [ 1 ],),), layers . Dense ( 1 ), ] ) opt = keras . optimizers . Adam ( learning_rate = 0 . 01 ) model . compile ( loss = 'mean_squared_error' , optimizer = opt , metrics = [ 'mae' , 'mse' ]) history = model . fit ( X_train , y_train , epochs = 200 , validation_split = 0.1 , callbacks =[ early_stop ] ,) Epoch 1/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0278 - mae: 0.1193 - mse: 0.0278 - val_loss: 0.0192 - val_mae: 0.0996 - val_mse: 0.0192 Epoch 2/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0214 - mae: 0.1076 - mse: 0.0214 - val_loss: 0.0187 - val_mae: 0.1035 - val_mse: 0.0187 Epoch 3/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0212 - mae: 0.1067 - mse: 0.0212 - val_loss: 0.0194 - val_mae: 0.1105 - val_mse: 0.0194 Epoch 4/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0212 - mae: 0.1071 - mse: 0.0212 - val_loss: 0.0177 - val_mae: 0.0987 - val_mse: 0.0177 Epoch 5/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0206 - mae: 0.1044 - mse: 0.0206 - val_loss: 0.0180 - val_mae: 0.1008 - val_mse: 0.0180 Epoch 6/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0209 - mae: 0.1060 - mse: 0.0209 - val_loss: 0.0185 - val_mae: 0.1064 - val_mse: 0.0185 Epoch 7/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1035 - mse: 0.0204 - val_loss: 0.0185 - val_mae: 0.1006 - val_mse: 0.0185 Epoch 8/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0209 - mae: 0.1062 - mse: 0.0209 - val_loss: 0.0182 - val_mae: 0.1005 - val_mse: 0.0182 Epoch 9/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0206 - mae: 0.1045 - mse: 0.0206 - val_loss: 0.0175 - val_mae: 0.0973 - val_mse: 0.0175 Epoch 10/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0205 - mae: 0.1042 - mse: 0.0205 - val_loss: 0.0181 - val_mae: 0.1021 - val_mse: 0.0181 Epoch 11/200 335/335 [==============================] - 1s 4ms/step - loss: 0.0205 - mae: 0.1040 - mse: 0.0205 - val_loss: 0.0176 - val_mae: 0.0945 - val_mse: 0.0176 Epoch 12/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0206 - mae: 0.1048 - mse: 0.0206 - val_loss: 0.0184 - val_mae: 0.1049 - val_mse: 0.0184 Epoch 13/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1039 - mse: 0.0204 - val_loss: 0.0184 - val_mae: 0.1031 - val_mse: 0.0184 Epoch 14/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1037 - mse: 0.0204 - val_loss: 0.0178 - val_mae: 0.1001 - val_mse: 0.0178 Epoch 15/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0203 - mae: 0.1036 - mse: 0.0203 - val_loss: 0.0174 - val_mae: 0.0962 - val_mse: 0.0174 Epoch 16/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0205 - mae: 0.1038 - mse: 0.0205 - val_loss: 0.0176 - val_mae: 0.0993 - val_mse: 0.0176 Epoch 17/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0203 - mae: 0.1033 - mse: 0.0203 - val_loss: 0.0181 - val_mae: 0.1031 - val_mse: 0.0181 Epoch 18/200 335/335 [==============================] - 1s 4ms/step - loss: 0.0202 - mae: 0.1032 - mse: 0.0202 - val_loss: 0.0179 - val_mae: 0.0978 - val_mse: 0.0179 Epoch 19/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0204 - mae: 0.1038 - mse: 0.0204 - val_loss: 0.0181 - val_mae: 0.1021 - val_mse: 0.0181 Epoch 20/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0205 - mae: 0.1045 - mse: 0.0205 - val_loss: 0.0182 - val_mae: 0.1014 - val_mse: 0.0182 Epoch 21/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0202 - mae: 0.1029 - mse: 0.0202 - val_loss: 0.0174 - val_mae: 0.0971 - val_mse: 0.0174 Epoch 22/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1017 - mse: 0.0200 - val_loss: 0.0175 - val_mae: 0.0974 - val_mse: 0.0175 Epoch 23/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0203 - mae: 0.1037 - mse: 0.0203 - val_loss: 0.0180 - val_mae: 0.1031 - val_mse: 0.0180 Epoch 24/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0201 - mae: 0.1025 - mse: 0.0201 - val_loss: 0.0178 - val_mae: 0.0992 - val_mse: 0.0178 Epoch 25/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0202 - mae: 0.1028 - mse: 0.0202 - val_loss: 0.0176 - val_mae: 0.0970 - val_mse: 0.0176 Epoch 26/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1020 - mse: 0.0200 - val_loss: 0.0174 - val_mae: 0.0986 - val_mse: 0.0174 Epoch 27/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0201 - mae: 0.1029 - mse: 0.0201 - val_loss: 0.0173 - val_mae: 0.0966 - val_mse: 0.0173 Epoch 28/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1023 - mse: 0.0200 - val_loss: 0.0178 - val_mae: 0.1007 - val_mse: 0.0178 Epoch 29/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1022 - mse: 0.0200 - val_loss: 0.0174 - val_mae: 0.0964 - val_mse: 0.0174 Epoch 30/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0201 - mae: 0.1025 - mse: 0.0201 - val_loss: 0.0172 - val_mae: 0.0940 - val_mse: 0.0172 Epoch 31/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1023 - mse: 0.0200 - val_loss: 0.0174 - val_mae: 0.0959 - val_mse: 0.0174 Epoch 32/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1019 - mse: 0.0200 - val_loss: 0.0180 - val_mae: 0.1017 - val_mse: 0.0180 Epoch 33/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0199 - mae: 0.1019 - mse: 0.0199 - val_loss: 0.0183 - val_mae: 0.0998 - val_mse: 0.0183 Epoch 34/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1023 - mse: 0.0200 - val_loss: 0.0180 - val_mae: 0.1003 - val_mse: 0.0180 Epoch 35/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1016 - mse: 0.0197 - val_loss: 0.0172 - val_mae: 0.0931 - val_mse: 0.0172 Epoch 36/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1017 - mse: 0.0198 - val_loss: 0.0178 - val_mae: 0.1011 - val_mse: 0.0178 Epoch 37/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0199 - mae: 0.1024 - mse: 0.0199 - val_loss: 0.0191 - val_mae: 0.1026 - val_mse: 0.0191 Epoch 38/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1018 - mse: 0.0198 - val_loss: 0.0174 - val_mae: 0.0971 - val_mse: 0.0174 Epoch 39/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1020 - mse: 0.0198 - val_loss: 0.0176 - val_mae: 0.0961 - val_mse: 0.0176 Epoch 40/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1031 - mse: 0.0200 - val_loss: 0.0184 - val_mae: 0.1042 - val_mse: 0.0184 Epoch 41/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1014 - mse: 0.0197 - val_loss: 0.0175 - val_mae: 0.0973 - val_mse: 0.0175 Epoch 42/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1013 - mse: 0.0198 - val_loss: 0.0179 - val_mae: 0.1025 - val_mse: 0.0179 Epoch 43/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1017 - mse: 0.0197 - val_loss: 0.0180 - val_mae: 0.0994 - val_mse: 0.0180 Epoch 44/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1019 - mse: 0.0197 - val_loss: 0.0172 - val_mae: 0.0935 - val_mse: 0.0172 Epoch 45/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0200 - mae: 0.1026 - mse: 0.0200 - val_loss: 0.0178 - val_mae: 0.0984 - val_mse: 0.0178 Epoch 46/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1013 - mse: 0.0197 - val_loss: 0.0180 - val_mae: 0.1028 - val_mse: 0.0180 Epoch 47/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1020 - mse: 0.0198 - val_loss: 0.0178 - val_mae: 0.0978 - val_mse: 0.0178 Epoch 48/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0198 - mae: 0.1017 - mse: 0.0198 - val_loss: 0.0172 - val_mae: 0.0952 - val_mse: 0.0172 Epoch 49/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0197 - mae: 0.1016 - mse: 0.0197 - val_loss: 0.0194 - val_mae: 0.1072 - val_mse: 0.0194 Epoch 50/200 335/335 [==============================] - 1s 3ms/step - loss: 0.0196 - mae: 0.1008 - mse: 0.0196 - val_loss: 0.0176 - val_mae: 0.0965 - val_mse: 0.0176 plot def plot_history ( history ) : hist = pd . DataFrame ( history . history ) hist [ 'epoch' ] = history . epoch plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Abs Error [MPG]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mae' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mae' ] , label = 'Val Error' ) plt . legend () plt . figure () plt . xlabel ( 'Epoch' ) plt . ylabel ( 'Mean Square Error [$MPG^2$]' ) plt . plot ( hist [ 'epoch' ] , hist [ 'mse' ] , label = 'Train Error' ) plt . plot ( hist [ 'epoch' ] , hist [ 'val_mse' ] , label = 'Val Error' ) plt . legend () plt . show () plot_history ( history )","title":"Training by using DNN"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-decision-tree","text":"from sklearn import tree tree_clf = tree.DecisionTreeRegressor() tree_clf.fit(X_train, y_train) DecisionTreeRegressor(ccp_alpha=0.0, criterion='mse', max_depth=None, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort='deprecated', random_state=None, splitter='best')","title":"Training by using Decision Tree"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-regression","text":"tscv = TimeSeriesSplit ( n_splits = 3 ) model1 = XGBRegressor () param_grid = {' nthread ' : [ 4 , 6 , 8 ], ' objective ' : [' reg : squarederror '], ' learning_rate ' : [ .03 , 0.05 , .07 ], ' max_depth ' : [ 5 , 6 , 7 ], ' min_child_weight ' : [ 4 ], ' subsample ' : [ 0.7 ], ' colsample_bytree ' : [ 0.7 ], ' n_estimators ' : [ 500 ]} GridSearch = GridSearchCV ( estimator = model1 , param_grid = param_grid , cv = tscv , n_jobs = 4 , verbose = 10 ) GridSearch . fit ( X_train , y_train ) Fitting 3 folds for each of 27 candidates, totalling 81 fits [Parallel(n_jobs=4)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=4)]: Done 5 tasks | elapsed: 25.8s [Parallel(n_jobs=4)]: Done 10 tasks | elapsed: 2.8min [Parallel(n_jobs=4)]: Done 17 tasks | elapsed: 5.8min [Parallel(n_jobs=4)]: Done 24 tasks | elapsed: 6.7min [Parallel(n_jobs=4)]: Done 33 tasks | elapsed: 9.8min [Parallel(n_jobs=4)]: Done 42 tasks | elapsed: 10.8min [Parallel(n_jobs=4)]: Done 53 tasks | elapsed: 16.7min [Parallel(n_jobs=4)]: Done 64 tasks | elapsed: 19.4min [Parallel(n_jobs=4)]: Done 81 out of 81 | elapsed: 22.1min finished /usr/local/lib/python3.6/dist-packages/xgboost/sklearn.py:242: DeprecationWarning: The nthread parameter is deprecated as of version .6.Please use n_jobs instead.nthread is deprecated. 'nthread is deprecated.', DeprecationWarning) GridSearchCV(cv=TimeSeriesSplit(max_train_size=None, n_splits=3), error_score=nan, estimator=XGBRegressor(base_score=0.5, booster='gbtree', colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1, gamma=0, importance_type='gain', learning_rate=0.1, max_delta_step=0, max_depth=3, min_child_weight=1, missing=None, n_estimators=100, n_jobs=1, nthread=None, objectiv... scale_pos_weight=1, seed=None, silent=None, subsample=1, verbosity=1), iid='deprecated', n_jobs=4, param_grid={'colsample_bytree': [0.7], 'learning_rate': [0.03, 0.05, 0.07], 'max_depth': [5, 6, 7], 'min_child_weight': [4], 'n_estimators': [500], 'nthread': [4, 6, 8], 'objective': ['reg:squarederror'], 'subsample': [0.7]}, pre_dispatch='2*n_jobs', refit=True, return_train_score=False, scoring=None, verbose=10)","title":"Training by using Regression"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-ridge-regression","text":"from sklearn import linear_model reg = linear_model . Ridge ( alpha =. 5 ) reg . fit ( X_train , y_train ) Ridge(alpha=0.5, copy_X=True, fit_intercept=True, max_iter=None, normalize=False, random_state=None, solver='auto', tol=0.001)","title":"Training by using Ridge Regression"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-random-forest","text":"model2 = RandomForestRegressor () param_grid2 = { 'n_estimators' :[ 10 , 50 , 100 , 1000 ], 'max_features' :[ 1 , 2 , 3 ] } GridSearch2 = GridSearchCV ( estimator = model2 , param_grid = param_grid2 , cv = tscv , n_jobs = 10 , verbose = 10 ) GridSearch2 . fit ( X_train , y_train ) Fitting 3 folds for each of 12 candidates, totalling 36 fits [Parallel(n_jobs=10)]: Using backend LokyBackend with 10 concurrent workers. [Parallel(n_jobs=10)]: Done 5 tasks | elapsed: 3.1s [Parallel(n_jobs=10)]: Done 12 tasks | elapsed: 5.1s [Parallel(n_jobs=10)]: Done 21 out of 36 | elapsed: 7.8s remaining: 5.6s [Parallel(n_jobs=10)]: Done 25 out of 36 | elapsed: 9.5s remaining: 4.2s [Parallel(n_jobs=10)]: Done 29 out of 36 | elapsed: 21.6s remaining: 5.2s [Parallel(n_jobs=10)]: Done 33 out of 36 | elapsed: 31.1s remaining: 2.8s [Parallel(n_jobs=10)]: Done 36 out of 36 | elapsed: 35.9s finished /usr/local/lib/python3.6/dist-packages/sklearn/model_selection/_search.py:739: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples,), for example using ravel(). self.best_estimator_.fit(X, y, **fit_params) GridSearchCV(cv=TimeSeriesSplit(max_train_size=None, n_splits=3), error_score=nan, estimator=RandomForestRegressor(bootstrap=True, ccp_alpha=0.0, criterion='mse', max_depth=None, max_features='auto', max_leaf_nodes=None, max_samples=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=100, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False), iid='deprecated', n_jobs=10, param_grid={'max_features': [1, 2, 3], 'n_estimators': [10, 50, 100, 1000]}, pre_dispatch='2*n_jobs', refit=True, return_train_score=False, scoring=None, verbose=10)","title":"Training by using Random forest"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-svm","text":"model3 = svm . SVR () param_grid3 = { 'kernel' : [ 'rbf' ], 'gamma' : [ 1 e - 3 , 1 e - 4 ], 'C' : [ 1 , 10 , 100 , 1000 ] } GridSearch3 = GridSearchCV ( estimator = model3 , n_jobs = 10 , verbose = 10 , param_grid = param_grid3 ) GridSearch3 . fit ( X_train , y_train , ) Fitting 5 folds for each of 8 candidates, totalling 40 fits [Parallel(n_jobs=10)]: Using backend LokyBackend with 10 concurrent workers. [Parallel(n_jobs=10)]: Done 5 tasks | elapsed: 15.0s [Parallel(n_jobs=10)]: Done 12 tasks | elapsed: 24.1s [Parallel(n_jobs=10)]: Done 21 tasks | elapsed: 35.6s [Parallel(n_jobs=10)]: Done 26 out of 40 | elapsed: 43.0s remaining: 23.2s [Parallel(n_jobs=10)]: Done 31 out of 40 | elapsed: 50.7s remaining: 14.7s [Parallel(n_jobs=10)]: Done 36 out of 40 | elapsed: 54.0s remaining: 6.0s [Parallel(n_jobs=10)]: Done 40 out of 40 | elapsed: 54.9s finished /usr/local/lib/python3.6/dist-packages/sklearn/utils/validation.py:760: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True) GridSearchCV(cv=None, error_score=nan, estimator=SVR(C=1.0, cache_size=200, coef0=0.0, degree=3, epsilon=0.1, gamma='scale', kernel='rbf', max_iter=-1, shrinking=True, tol=0.001, verbose=False), iid='deprecated', n_jobs=10, param_grid={'C': [1, 10, 100, 1000], 'gamma': [0.001, 0.0001], 'kernel': ['rbf']}, pre_dispatch='2*n_jobs', refit=True, return_train_score=False, scoring=None, verbose=10)","title":"Training by using SVM"},{"location":"MSBD5001/project/Individual%20Project/#training-by-using-neural-network","text":"from sklearn.neural_network import MLPRegressor mlp_reg = MLPRegressor ( max_iter = 1000 ) mlp_reg . fit ( X_train , y_train ) /usr/local/lib/python3.6/dist-packages/sklearn/neural_network/_multilayer_perceptron.py:1342: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True) MLPRegressor(activation='relu', alpha=0.0001, batch_size='auto', beta_1=0.9, beta_2=0.999, early_stopping=False, epsilon=1e-08, hidden_layer_sizes=(100,), learning_rate='constant', learning_rate_init=0.001, max_fun=15000, max_iter=1000, momentum=0.9, n_iter_no_change=10, nesterovs_momentum=True, power_t=0.5, random_state=None, shuffle=True, solver='adam', tol=0.0001, validation_fraction=0.1, verbose=False, warm_start=False)","title":"Training by using Neural network"},{"location":"MSBD5001/project/Individual%20Project/#evaluation","text":"y_pred = model.predict(X_test) # print(scaler.inverse_transform(y_pred)) # print(scaler.inverse_transform(y_test)) y_pred2 = GridSearch.predict(X_test) y_pred3 = GridSearch2.predict(X_test) y_pred4 = GridSearch3.predict(X_test) y_pred5 = tree_clf.predict(X_test) y_pred6 = reg.predict(X_test) y_pred7 = mlp_reg.predict(X_test) MSE_DNN = mean_squared_error ( y_pred , y_test ) MSE_rg = mean_squared_error ( y_pred2 , y_test ) MSE_rf = mean_squared_error ( y_pred3 , y_test ) MSE_tree = mean_squared_error ( y_pred5 , y_test ) MSE_svr = mean_squared_error ( y_pred4 , y_test ) MSE_ridge = mean_squared_error ( y_pred6 , y_test ) MSE_mlp = mean_squared_error ( y_pred7 , y_test ) print ( 'MSE for XGBoost is ' + str ( MSE_rg )) print ( 'MSE for RandomForest is ' + str ( MSE_rf )) print ( f \"MSE for dnn is: {MSE_DNN}\" ) print ( f \"MSE for decision is: {MSE_tree}\" ) print ( f \"MSE for svr is: {MSE_svr}\" ) print ( f \"MSE for ridge is: {MSE_ridge}\" ) print ( f \"MSE for neural network is: {MSE_mlp}\" ) MSE for XGBoost is 0.01726006344884727 MSE for RandomForest is 0.015177183077877169 MSE for dnn is: 0.021906888345540523 MSE for decision is: 0.025013354977883036 MSE for svr is: 0.020732502038850405 MSE for ridge is: 0.02317702945371461 MSE for neural network is: 0.02032315238540893","title":"Evaluation"},{"location":"MSBD5001/project/LSTM/","text":"import requests import tensorflow as tf import pandas as pd import matplotlib.pyplot as plt from sklearn.preprocessing import MinMaxScaler from sklearn.metrics import mean_absolute_error , mean_squared_error import numpy as np from tensorflow import keras import os gpu_info = !nvidia-smi gpu_info = '\\n'.join(gpu_info) if gpu_info.find('failed') >= 0: print('Select the Runtime > \"Change runtime type\" menu to enable a GPU accelerator, ') print('and then re-execute this cell.') else: print(gpu_info) Fri Nov 27 12:39:37 2020 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 455.38 Driver Version: 418.67 CUDA Version: 10.1 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla V100-SXM2... Off | 00000000:00:04.0 Off | 0 | | N/A 33C P0 26W / 300W | 0MiB / 16130MiB | 0% Default | | | | ERR! | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ set up tpu resolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='grpc://' + os.environ['COLAB_TPU_ADDR']) tf.config.experimental_connect_to_cluster(resolver) # This is the TPU initialization code that has to be at the beginning. tf.tpu.experimental.initialize_tpu_system(resolver) print(\"All devices: \", tf.config.list_logical_devices('TPU')) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-3-b7c2a2ecd2b3> in <module>() ----> 1 resolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='grpc://' + os.environ['COLAB_TPU_ADDR']) 2 tf.config.experimental_connect_to_cluster(resolver) 3 # This is the TPU initialization code that has to be at the beginning. 4 tf.tpu.experimental.initialize_tpu_system(resolver) 5 print(\"All devices: \", tf.config.list_logical_devices('TPU')) /usr/lib/python3.6/os.py in __getitem__(self, key) 667 except KeyError: 668 # raise KeyError with the original key value --> 669 raise KeyError(key) from None 670 return self.decodevalue(value) 671 KeyError: 'COLAB_TPU_ADDR' Load data \u00b6 url = \"https://min-api.cryptocompare.com/data/histohour?fsym=BTC&tsym=USD&limit=2000\" f = requests.get(url) ipdata = f.json() btc = pd.read_csv('000001.SS.csv') btc['Date'] = pd.to_datetime(btc['Date']) btc.set_index('Date', inplace=True) btc.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Open High Low Close Adj Close Volume Date 2020-11-25 3417.514893 3423.485107 3362.326904 3362.326904 3362.326904 322100.0 2020-11-26 3360.061035 3371.454102 3344.281982 3369.732910 3369.732910 255900.0 plt.figure(figsize=(15, 5)) plt.plot(btc.Close) plt.xlabel ('Date_time') plt.ylabel ('Price (US$') Text(0, 0.5, 'Price (US$') Preprocess data \u00b6 scaler = MinMaxScaler () # min - max normalization and scale the features in the 0 - 1 range . close_price = btc [ 'Close' ]. values . reshape ( - 1 , 1 ) # The scaler expects the data to be shaped as ( x , y ) scaled_close = scaler . fit_transform ( close_price ) # removing NaNs ( if any ) scaled_close = scaled_close [ ~ np . isnan ( scaled_close )] # reshaping data after removing NaNs scaled_close = scaled_close . reshape ( - 1 , 1 ) print ( scaled_close . shape ) (5838, 1) SEQ_LEN = 150 # creating a sequence of 100 hours at position 0. def to_sequences ( data , seq_len ) : d = [] for index in range ( len ( data ) - seq_len ) : d . append ( data [ index : index + seq_len ]) return np . array ( d ) def preprocess ( data_raw , seq_len , train_split ) : data = to_sequences ( data_raw , seq_len ) num_train = int ( train_split * data . shape [ 0 ]) X_train = data [ :num_train , :- 1 , : ] y_train = data [ :num_train , - 1 , : ] X_test = data [ num_train: , :- 1 , : ] y_test = data [ num_train: , - 1 , : ] return X_train , y_train , X_test , y_test \"\"\"Walk forward validation: Initial SEQ_LEN is defined above, so, walk forward will be shifting one position to the right and create another sequence. The process is repeated until all possible positions are used.\"\"\" X_train , y_train , X_test , y_test = preprocess ( scaled_close , SEQ_LEN , train_split = 0.95 ) \"\"\"Our model will use 1805 sequences representing 99 hours of Bitcoin price changes each for training. We shall be predicting the price for 96 hours in the future\"\"\" print ( X_train . shape , X_test . shape ) (5403, 149, 1) (285, 149, 1) Training \u00b6 Build model \u00b6 from tensorflow.keras.layers import Bidirectional , Dropout , LSTM , Dense , Activation DROPOUT = 0.2 # 20% Dropout is used to control over-fitting during training WINDOW_SIZE = SEQ_LEN - 1 model = keras.Sequential() # Input layer model.add(Bidirectional(LSTM(WINDOW_SIZE, return_sequences=True), input_shape=(WINDOW_SIZE, X_train.shape[-1]))) \"\"\"Bidirectional RNNs allows to train on the sequence data in forward and backward direction.\"\"\" model.add(Dropout(rate=DROPOUT)) # 1st Hidden layer model.add(Bidirectional(LSTM((WINDOW_SIZE * 2), return_sequences = True))) model.add(Dropout(rate=DROPOUT)) # 2nd Hidden layer model.add(Bidirectional(LSTM(WINDOW_SIZE, return_sequences=False))) # output layer model.add(Dense(units=1)) model.add(Activation('linear')) \"\"\"Output layer has a single neuron (predicted Bitcoin price). We use Linear activation function which activation is proportional to the input.\"\"\" BATCH_SIZE = 64 model.compile(loss='mean_squared_error', optimizer='adam') model.summary() Model: \"sequential\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= bidirectional (Bidirectional (None, 149, 298) 179992 _________________________________________________________________ dropout (Dropout) (None, 149, 298) 0 _________________________________________________________________ bidirectional_1 (Bidirection (None, 149, 596) 1423248 _________________________________________________________________ dropout_1 (Dropout) (None, 149, 596) 0 _________________________________________________________________ bidirectional_2 (Bidirection (None, 298) 889232 _________________________________________________________________ dense (Dense) (None, 1) 299 _________________________________________________________________ activation (Activation) (None, 1) 0 ================================================================= Total params: 2,492,771 Trainable params: 2,492,771 Non-trainable params: 0 _________________________________________________________________ Train model \u00b6 history = model.fit(X_train, y_train, epochs=30, batch_size=BATCH_SIZE, shuffle=False, validation_split=0.1) Epoch 1/30 76/76 [==============================] - 8s 100ms/step - loss: 0.0042 - val_loss: 0.0054 Epoch 2/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0043 - val_loss: 0.0040 Epoch 3/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0058 - val_loss: 4.1895e-04 Epoch 4/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0082 - val_loss: 0.0062 Epoch 5/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0097 - val_loss: 3.5601e-04 Epoch 6/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0046 - val_loss: 0.0010 Epoch 7/30 76/76 [==============================] - 6s 78ms/step - loss: 4.8942e-04 - val_loss: 9.7077e-05 Epoch 8/30 76/76 [==============================] - 6s 78ms/step - loss: 4.0978e-04 - val_loss: 8.7487e-05 Epoch 9/30 76/76 [==============================] - 6s 78ms/step - loss: 2.6390e-04 - val_loss: 1.6159e-04 Epoch 10/30 76/76 [==============================] - 6s 78ms/step - loss: 2.0697e-04 - val_loss: 9.5372e-05 Epoch 11/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9897e-04 - val_loss: 1.6377e-04 Epoch 12/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9292e-04 - val_loss: 1.1390e-04 Epoch 13/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9810e-04 - val_loss: 9.2403e-05 Epoch 14/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9398e-04 - val_loss: 1.0540e-04 Epoch 15/30 76/76 [==============================] - 6s 78ms/step - loss: 1.8777e-04 - val_loss: 1.0370e-04 Epoch 16/30 76/76 [==============================] - 6s 78ms/step - loss: 2.1799e-04 - val_loss: 9.7871e-05 Epoch 17/30 76/76 [==============================] - 6s 78ms/step - loss: 2.4891e-04 - val_loss: 8.5473e-05 Epoch 18/30 76/76 [==============================] - 6s 78ms/step - loss: 2.2044e-04 - val_loss: 1.0333e-04 Epoch 19/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0013 - val_loss: 4.0906e-04 Epoch 20/30 76/76 [==============================] - 6s 78ms/step - loss: 3.4754e-04 - val_loss: 1.7922e-04 Epoch 21/30 76/76 [==============================] - 6s 78ms/step - loss: 3.6990e-04 - val_loss: 1.9532e-04 Epoch 22/30 76/76 [==============================] - 6s 78ms/step - loss: 3.0917e-04 - val_loss: 1.7043e-04 Epoch 23/30 76/76 [==============================] - 6s 78ms/step - loss: 4.0549e-04 - val_loss: 2.0193e-04 Epoch 24/30 76/76 [==============================] - 6s 78ms/step - loss: 3.7887e-04 - val_loss: 1.4705e-04 Epoch 25/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0020 - val_loss: 8.1100e-04 Epoch 26/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0035 - val_loss: 2.9418e-04 Epoch 27/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0035 - val_loss: 3.3067e-04 Epoch 28/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0017 - val_loss: 3.1639e-04 Epoch 29/30 76/76 [==============================] - 6s 79ms/step - loss: 0.0021 - val_loss: 0.0043 Epoch 30/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0025 - val_loss: 0.0042 Testing \u00b6 # prediction on test data y_pred = model.predict(X_test) # invert the test to original values y_test_inverse = pd.DataFrame(scaler.inverse_transform(y_test)) # assigning datetime y_test_inverse.index = btc.index[-len(y_test):] print('Test data:',) print(y_test_inverse.tail(3)); print(); # invert the prediction to understandable values y_pred_inverse = pd.DataFrame(scaler.inverse_transform(y_pred)) # assigning datetime y_pred_inverse.index = y_test_inverse.index print('Prediction data:',) print(y_pred_inverse.tail(3)) Test data: 0 Date 2020-11-24 3414.489990 2020-11-25 3402.822998 2020-11-26 3362.326904 Prediction data: 0 Date 2020-11-24 3691.941162 2020-11-25 3716.465576 2020-11-26 3723.725342 print(f'MAE {mean_absolute_error(y_test, y_pred)}') print(f'MSE {mean_squared_error(y_test, y_pred)}') print(f'RMSE {np.sqrt(mean_squared_error(y_test, y_pred))}') MAE 0.06316911917887182 MSE 0.0040649874216323045 RMSE 0.06375725387461653 plt.figure(figsize = (15,5)) plt.plot(y_test_inverse) plt.plot(y_pred_inverse) plt.title('Actual vs Prediction plot (Price prediction model)') plt.ylabel('price') plt.xlabel('date') plt.legend(['actual', 'prediction'], loc='upper left') plt.show() last_ten_days_data = to_sequences(scaled_close[-(SEQ_LEN + 10):], SEQ_LEN) y_pred = model.predict(last_ten_days_data) y_pred_inverse = pd.DataFrame(scaler.inverse_transform(y_pred)) print(y_pred_inverse) 0 0 3429.276855 1 3485.554443 2 3485.470215 3 3465.985352 4 3463.942383 5 3429.496338 6 3464.851318 7 3456.538086 8 3464.531006 9 3479.261719","title":"Lstm"},{"location":"MSBD5001/project/LSTM/#load-data","text":"url = \"https://min-api.cryptocompare.com/data/histohour?fsym=BTC&tsym=USD&limit=2000\" f = requests.get(url) ipdata = f.json() btc = pd.read_csv('000001.SS.csv') btc['Date'] = pd.to_datetime(btc['Date']) btc.set_index('Date', inplace=True) btc.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Open High Low Close Adj Close Volume Date 2020-11-25 3417.514893 3423.485107 3362.326904 3362.326904 3362.326904 322100.0 2020-11-26 3360.061035 3371.454102 3344.281982 3369.732910 3369.732910 255900.0 plt.figure(figsize=(15, 5)) plt.plot(btc.Close) plt.xlabel ('Date_time') plt.ylabel ('Price (US$') Text(0, 0.5, 'Price (US$')","title":"Load data"},{"location":"MSBD5001/project/LSTM/#preprocess-data","text":"scaler = MinMaxScaler () # min - max normalization and scale the features in the 0 - 1 range . close_price = btc [ 'Close' ]. values . reshape ( - 1 , 1 ) # The scaler expects the data to be shaped as ( x , y ) scaled_close = scaler . fit_transform ( close_price ) # removing NaNs ( if any ) scaled_close = scaled_close [ ~ np . isnan ( scaled_close )] # reshaping data after removing NaNs scaled_close = scaled_close . reshape ( - 1 , 1 ) print ( scaled_close . shape ) (5838, 1) SEQ_LEN = 150 # creating a sequence of 100 hours at position 0. def to_sequences ( data , seq_len ) : d = [] for index in range ( len ( data ) - seq_len ) : d . append ( data [ index : index + seq_len ]) return np . array ( d ) def preprocess ( data_raw , seq_len , train_split ) : data = to_sequences ( data_raw , seq_len ) num_train = int ( train_split * data . shape [ 0 ]) X_train = data [ :num_train , :- 1 , : ] y_train = data [ :num_train , - 1 , : ] X_test = data [ num_train: , :- 1 , : ] y_test = data [ num_train: , - 1 , : ] return X_train , y_train , X_test , y_test \"\"\"Walk forward validation: Initial SEQ_LEN is defined above, so, walk forward will be shifting one position to the right and create another sequence. The process is repeated until all possible positions are used.\"\"\" X_train , y_train , X_test , y_test = preprocess ( scaled_close , SEQ_LEN , train_split = 0.95 ) \"\"\"Our model will use 1805 sequences representing 99 hours of Bitcoin price changes each for training. We shall be predicting the price for 96 hours in the future\"\"\" print ( X_train . shape , X_test . shape ) (5403, 149, 1) (285, 149, 1)","title":"Preprocess data"},{"location":"MSBD5001/project/LSTM/#training","text":"","title":"Training"},{"location":"MSBD5001/project/LSTM/#build-model","text":"from tensorflow.keras.layers import Bidirectional , Dropout , LSTM , Dense , Activation DROPOUT = 0.2 # 20% Dropout is used to control over-fitting during training WINDOW_SIZE = SEQ_LEN - 1 model = keras.Sequential() # Input layer model.add(Bidirectional(LSTM(WINDOW_SIZE, return_sequences=True), input_shape=(WINDOW_SIZE, X_train.shape[-1]))) \"\"\"Bidirectional RNNs allows to train on the sequence data in forward and backward direction.\"\"\" model.add(Dropout(rate=DROPOUT)) # 1st Hidden layer model.add(Bidirectional(LSTM((WINDOW_SIZE * 2), return_sequences = True))) model.add(Dropout(rate=DROPOUT)) # 2nd Hidden layer model.add(Bidirectional(LSTM(WINDOW_SIZE, return_sequences=False))) # output layer model.add(Dense(units=1)) model.add(Activation('linear')) \"\"\"Output layer has a single neuron (predicted Bitcoin price). We use Linear activation function which activation is proportional to the input.\"\"\" BATCH_SIZE = 64 model.compile(loss='mean_squared_error', optimizer='adam') model.summary() Model: \"sequential\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= bidirectional (Bidirectional (None, 149, 298) 179992 _________________________________________________________________ dropout (Dropout) (None, 149, 298) 0 _________________________________________________________________ bidirectional_1 (Bidirection (None, 149, 596) 1423248 _________________________________________________________________ dropout_1 (Dropout) (None, 149, 596) 0 _________________________________________________________________ bidirectional_2 (Bidirection (None, 298) 889232 _________________________________________________________________ dense (Dense) (None, 1) 299 _________________________________________________________________ activation (Activation) (None, 1) 0 ================================================================= Total params: 2,492,771 Trainable params: 2,492,771 Non-trainable params: 0 _________________________________________________________________","title":"Build model"},{"location":"MSBD5001/project/LSTM/#train-model","text":"history = model.fit(X_train, y_train, epochs=30, batch_size=BATCH_SIZE, shuffle=False, validation_split=0.1) Epoch 1/30 76/76 [==============================] - 8s 100ms/step - loss: 0.0042 - val_loss: 0.0054 Epoch 2/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0043 - val_loss: 0.0040 Epoch 3/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0058 - val_loss: 4.1895e-04 Epoch 4/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0082 - val_loss: 0.0062 Epoch 5/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0097 - val_loss: 3.5601e-04 Epoch 6/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0046 - val_loss: 0.0010 Epoch 7/30 76/76 [==============================] - 6s 78ms/step - loss: 4.8942e-04 - val_loss: 9.7077e-05 Epoch 8/30 76/76 [==============================] - 6s 78ms/step - loss: 4.0978e-04 - val_loss: 8.7487e-05 Epoch 9/30 76/76 [==============================] - 6s 78ms/step - loss: 2.6390e-04 - val_loss: 1.6159e-04 Epoch 10/30 76/76 [==============================] - 6s 78ms/step - loss: 2.0697e-04 - val_loss: 9.5372e-05 Epoch 11/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9897e-04 - val_loss: 1.6377e-04 Epoch 12/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9292e-04 - val_loss: 1.1390e-04 Epoch 13/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9810e-04 - val_loss: 9.2403e-05 Epoch 14/30 76/76 [==============================] - 6s 78ms/step - loss: 1.9398e-04 - val_loss: 1.0540e-04 Epoch 15/30 76/76 [==============================] - 6s 78ms/step - loss: 1.8777e-04 - val_loss: 1.0370e-04 Epoch 16/30 76/76 [==============================] - 6s 78ms/step - loss: 2.1799e-04 - val_loss: 9.7871e-05 Epoch 17/30 76/76 [==============================] - 6s 78ms/step - loss: 2.4891e-04 - val_loss: 8.5473e-05 Epoch 18/30 76/76 [==============================] - 6s 78ms/step - loss: 2.2044e-04 - val_loss: 1.0333e-04 Epoch 19/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0013 - val_loss: 4.0906e-04 Epoch 20/30 76/76 [==============================] - 6s 78ms/step - loss: 3.4754e-04 - val_loss: 1.7922e-04 Epoch 21/30 76/76 [==============================] - 6s 78ms/step - loss: 3.6990e-04 - val_loss: 1.9532e-04 Epoch 22/30 76/76 [==============================] - 6s 78ms/step - loss: 3.0917e-04 - val_loss: 1.7043e-04 Epoch 23/30 76/76 [==============================] - 6s 78ms/step - loss: 4.0549e-04 - val_loss: 2.0193e-04 Epoch 24/30 76/76 [==============================] - 6s 78ms/step - loss: 3.7887e-04 - val_loss: 1.4705e-04 Epoch 25/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0020 - val_loss: 8.1100e-04 Epoch 26/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0035 - val_loss: 2.9418e-04 Epoch 27/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0035 - val_loss: 3.3067e-04 Epoch 28/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0017 - val_loss: 3.1639e-04 Epoch 29/30 76/76 [==============================] - 6s 79ms/step - loss: 0.0021 - val_loss: 0.0043 Epoch 30/30 76/76 [==============================] - 6s 78ms/step - loss: 0.0025 - val_loss: 0.0042","title":"Train model"},{"location":"MSBD5001/project/LSTM/#testing","text":"# prediction on test data y_pred = model.predict(X_test) # invert the test to original values y_test_inverse = pd.DataFrame(scaler.inverse_transform(y_test)) # assigning datetime y_test_inverse.index = btc.index[-len(y_test):] print('Test data:',) print(y_test_inverse.tail(3)); print(); # invert the prediction to understandable values y_pred_inverse = pd.DataFrame(scaler.inverse_transform(y_pred)) # assigning datetime y_pred_inverse.index = y_test_inverse.index print('Prediction data:',) print(y_pred_inverse.tail(3)) Test data: 0 Date 2020-11-24 3414.489990 2020-11-25 3402.822998 2020-11-26 3362.326904 Prediction data: 0 Date 2020-11-24 3691.941162 2020-11-25 3716.465576 2020-11-26 3723.725342 print(f'MAE {mean_absolute_error(y_test, y_pred)}') print(f'MSE {mean_squared_error(y_test, y_pred)}') print(f'RMSE {np.sqrt(mean_squared_error(y_test, y_pred))}') MAE 0.06316911917887182 MSE 0.0040649874216323045 RMSE 0.06375725387461653 plt.figure(figsize = (15,5)) plt.plot(y_test_inverse) plt.plot(y_pred_inverse) plt.title('Actual vs Prediction plot (Price prediction model)') plt.ylabel('price') plt.xlabel('date') plt.legend(['actual', 'prediction'], loc='upper left') plt.show() last_ten_days_data = to_sequences(scaled_close[-(SEQ_LEN + 10):], SEQ_LEN) y_pred = model.predict(last_ten_days_data) y_pred_inverse = pd.DataFrame(scaler.inverse_transform(y_pred)) print(y_pred_inverse) 0 0 3429.276855 1 3485.554443 2 3485.470215 3 3465.985352 4 3463.942383 5 3429.496338 6 3464.851318 7 3456.538086 8 3464.531006 9 3479.261719","title":"Testing"},{"location":"MSBD5003/Lecture1/","text":"Big Data Definition \u00b6 Big Data is data whose scale, complexity, and speed require new architecture, techniques, algorithms, and analytics to manage it and extract value and hidden knowledge from it. Old model: Few companies are generating data, all others are consuming data New model: all of us are generating and consuming data at the same time 3 vs \u00b6 Volume \u00b6 Data are big Velocity ( Streaming data ) \u00b6 Data is being generated fast and need to be processed fast Variety \u00b6 various formats, types, and structures Numerical, text, images, audio, video, sequences, time series, social media data, multi-dim arrays, etc... A single application can be generating/collecting many types of data The structure spectrum \u00b6 Structured (schema-first) Relational database -- Semi-structured(Schema-later) Documents XML -- Unstucture data (MongoDB) Structured data \u00b6 Modify the rows is easy but modify the column costs a lot. The relational data model is the most used data model Every relation has a schema defining each columns' type The programmer must statically specify the schema Semi-structured Data \u00b6 Json object consists of a collection name: value pairs, seperated by commas. Each value can be - A string - A number - A boolean - null - An array - a JSON object How to handle big data \u00b6 Race conditions ( use locks ) The frustration of parallel programming \u00b6 Hard to debug How to migrate from one archetecture to another Cloud comuting \u00b6 Dynamic provisioning Scalability Elasticity Mapreduce \u00b6 Map: Takes raw input and produces a key, value pair Reduce: Takes data with same key and produces outputs Shuffling and sorting - Hidden phase between mappers and reducers - Groups all key value pairs Where do we store data \u00b6 Target environment \u00b6 Files are huge but not many Many reads but few writes I/O bandwidth is more important than latency GFS design decisions \u00b6 Files stored into chunks Reliability through replication Single master to coordinate access, keep metadata HDFS \u00b6 Name node: Maintains metadata info about files Maps a filename to a set of blocks Maps a block to the data nodes where it resides replication engine for blocks Datanod Store data Files are divided into blocks Communicates with name nodes through periodic heartbeat M data cells and n parity cells Storage efficiency = \\(\\frac{m}{m+n}\\) # On worker ailure \u00b6 Detect failure via periodic heartbeats Re-execute completed and in-progress map tasks Re-execute Mapreduce: A major step backwards \u00b6 Mapreduce may be a good idea for writing certain types of computations A giant step backward in the programming paradigm for large-scale data intensive applications A sub-cptimal implementation, in that it uses brute force instead of indexing Missing most of features that are routinely included in current DMBS Not novel at all","title":"Lecture1"},{"location":"MSBD5003/Lecture1/#big-data-definition","text":"Big Data is data whose scale, complexity, and speed require new architecture, techniques, algorithms, and analytics to manage it and extract value and hidden knowledge from it. Old model: Few companies are generating data, all others are consuming data New model: all of us are generating and consuming data at the same time","title":"Big Data Definition"},{"location":"MSBD5003/Lecture1/#3-vs","text":"","title":"3 vs"},{"location":"MSBD5003/Lecture1/#volume","text":"Data are big","title":"Volume"},{"location":"MSBD5003/Lecture1/#velocity-streaming-data","text":"Data is being generated fast and need to be processed fast","title":"Velocity ( Streaming data )"},{"location":"MSBD5003/Lecture1/#variety","text":"various formats, types, and structures Numerical, text, images, audio, video, sequences, time series, social media data, multi-dim arrays, etc... A single application can be generating/collecting many types of data","title":"Variety"},{"location":"MSBD5003/Lecture1/#the-structure-spectrum","text":"Structured (schema-first) Relational database -- Semi-structured(Schema-later) Documents XML -- Unstucture data (MongoDB)","title":"The structure spectrum"},{"location":"MSBD5003/Lecture1/#structured-data","text":"Modify the rows is easy but modify the column costs a lot. The relational data model is the most used data model Every relation has a schema defining each columns' type The programmer must statically specify the schema","title":"Structured data"},{"location":"MSBD5003/Lecture1/#semi-structured-data","text":"Json object consists of a collection name: value pairs, seperated by commas. Each value can be - A string - A number - A boolean - null - An array - a JSON object","title":"Semi-structured Data"},{"location":"MSBD5003/Lecture1/#how-to-handle-big-data","text":"Race conditions ( use locks )","title":"How to handle big data"},{"location":"MSBD5003/Lecture1/#the-frustration-of-parallel-programming","text":"Hard to debug How to migrate from one archetecture to another","title":"The frustration of parallel programming"},{"location":"MSBD5003/Lecture1/#cloud-comuting","text":"Dynamic provisioning Scalability Elasticity","title":"Cloud comuting"},{"location":"MSBD5003/Lecture1/#mapreduce","text":"Map: Takes raw input and produces a key, value pair Reduce: Takes data with same key and produces outputs Shuffling and sorting - Hidden phase between mappers and reducers - Groups all key value pairs","title":"Mapreduce"},{"location":"MSBD5003/Lecture1/#where-do-we-store-data","text":"","title":"Where do we store data"},{"location":"MSBD5003/Lecture1/#target-environment","text":"Files are huge but not many Many reads but few writes I/O bandwidth is more important than latency","title":"Target environment"},{"location":"MSBD5003/Lecture1/#gfs-design-decisions","text":"Files stored into chunks Reliability through replication Single master to coordinate access, keep metadata","title":"GFS design decisions"},{"location":"MSBD5003/Lecture1/#hdfs","text":"Name node: Maintains metadata info about files Maps a filename to a set of blocks Maps a block to the data nodes where it resides replication engine for blocks Datanod Store data Files are divided into blocks Communicates with name nodes through periodic heartbeat M data cells and n parity cells Storage efficiency = \\(\\frac{m}{m+n}\\) #","title":"HDFS"},{"location":"MSBD5003/Lecture1/#on-worker-ailure","text":"Detect failure via periodic heartbeats Re-execute completed and in-progress map tasks Re-execute","title":"On worker ailure"},{"location":"MSBD5003/Lecture1/#mapreduce-a-major-step-backwards","text":"Mapreduce may be a good idea for writing certain types of computations A giant step backward in the programming paradigm for large-scale data intensive applications A sub-cptimal implementation, in that it uses brute force instead of indexing Missing most of features that are routinely included in current DMBS Not novel at all","title":"Mapreduce: A major step backwards"},{"location":"MSBD5003/Lecture2/","text":"!pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 69kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 37.0MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=a6732c6ade26f105c00ba7849e278a010c66b051a7f273b109760a82bbea01a0 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 Spark \u00b6 Execution is pipelined and parallel. No need to store intermediate results. Lazy execution allows optimization. RDD has enough information about how it was rderived from to compute its partitions from data in stable storage. Example: If a partition of errors is lost, Spark rebuilds it by applying a filter on only the corresponding partition of lines. Partitions can be recomputed in parallel on different nodes, without having to roll back the whole program. Sample spark program \u00b6 from pyspark.context import SparkContext import requests sc = SparkContext.getOrCreate() text_file = sc.textFile('sample_data/README.md') Filter each line which contains T lines = text_file.filter(lambda line: 'T' in line) lines.collect() ['This directory includes a few sample datasets to get you started.', ' [MNIST database](https://en.wikipedia.org/wiki/MNIST_database), which is', ' Statistician. 27 (1): 17-21. JSTOR 2682899.'] Average text_file = sc.textFile('sample_data/README.md', 2) lines.map(lambda line: len(line.split())).reduce(lambda a, b: (a + b) / 2) 6.75 Average with partition 3 text_file = sc.textFile('sample_data/README.md', 5) lines.map(lambda line: len(line.split())).reduce(lambda a, b: (a + b) / 2) 6.75 RDD Operations \u00b6 Download file r = requests.get('https://www.cse.ust.hk/msbd5003/data/fruits.txt') open('fruits.txt', 'wb').write(r.content) 65 print file \u00b6 fruits = sc.textFile('fruits.txt') fruits.collect() ['apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry'] Map \u00b6 fruitsReversed = fruits . map ( lambda fruit : fruit [ ::- 1 ]) fruitsReversed . collect () ['elppa', 'ananab', 'nolem yranac', 'parg', 'nomel', 'egnaro', 'elppaenip', 'yrrebwarts'] Filter \u00b6 shortFruits = fruits.filter(lambda fruit: len(fruit) <= 5) shortFruits.collect() ['apple', 'grap', 'lemon'] FlatMap \u00b6 characters = fruits.flatMap(lambda fruit: list(fruit)) print(characters.collect()) ['a', 'p', 'p', 'l', 'e', 'b', 'a', 'n', 'a', 'n', 'a', 'c', 'a', 'n', 'a', 'r', 'y', ' ', 'm', 'e', 'l', 'o', 'n', 'g', 'r', 'a', 'p', 'l', 'e', 'm', 'o', 'n', 'o', 'r', 'a', 'n', 'g', 'e', 'p', 'i', 'n', 'e', 'a', 'p', 'p', 'l', 'e', 's', 't', 'r', 'a', 'w', 'b', 'e', 'r', 'r', 'y'] Collect \u00b6 new_fruits = fruits.union(fruits) new_fruits.collect() ['apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry', 'apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry'] new_fruits = fruits.intersection(fruits) new_fruits.collect() ['orange', 'pineapple', 'canary melon', 'lemon', 'banana', 'apple', 'grap', 'strawberry'] new_fruits = fruits.union(fruits).distinct() new_fruits.collect() ['orange', 'pineapple', 'canary melon', 'lemon', 'banana', 'apple', 'grap', 'strawberry'] RDD Actions \u00b6 collect \u00b6 take \u00b6 first3Fruits = fruits.take(3) print(first3Fruits) ['apple', 'banana', 'canary melon'] count \u00b6 fruits.count() 8 reduce \u00b6 fruits.map(lambda fruit: set(fruit)).reduce(lambda x, y: x.union(y)) {' ', 'a', 'b', 'c', 'e', 'g', 'i', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'w', 'y'}","title":"Lecture2"},{"location":"MSBD5003/Lecture2/#spark","text":"Execution is pipelined and parallel. No need to store intermediate results. Lazy execution allows optimization. RDD has enough information about how it was rderived from to compute its partitions from data in stable storage. Example: If a partition of errors is lost, Spark rebuilds it by applying a filter on only the corresponding partition of lines. Partitions can be recomputed in parallel on different nodes, without having to roll back the whole program.","title":"Spark"},{"location":"MSBD5003/Lecture2/#sample-spark-program","text":"from pyspark.context import SparkContext import requests sc = SparkContext.getOrCreate() text_file = sc.textFile('sample_data/README.md') Filter each line which contains T lines = text_file.filter(lambda line: 'T' in line) lines.collect() ['This directory includes a few sample datasets to get you started.', ' [MNIST database](https://en.wikipedia.org/wiki/MNIST_database), which is', ' Statistician. 27 (1): 17-21. JSTOR 2682899.'] Average text_file = sc.textFile('sample_data/README.md', 2) lines.map(lambda line: len(line.split())).reduce(lambda a, b: (a + b) / 2) 6.75 Average with partition 3 text_file = sc.textFile('sample_data/README.md', 5) lines.map(lambda line: len(line.split())).reduce(lambda a, b: (a + b) / 2) 6.75","title":"Sample spark program"},{"location":"MSBD5003/Lecture2/#rdd-operations","text":"Download file r = requests.get('https://www.cse.ust.hk/msbd5003/data/fruits.txt') open('fruits.txt', 'wb').write(r.content) 65","title":"RDD Operations"},{"location":"MSBD5003/Lecture2/#print-file","text":"fruits = sc.textFile('fruits.txt') fruits.collect() ['apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry']","title":"print file"},{"location":"MSBD5003/Lecture2/#map","text":"fruitsReversed = fruits . map ( lambda fruit : fruit [ ::- 1 ]) fruitsReversed . collect () ['elppa', 'ananab', 'nolem yranac', 'parg', 'nomel', 'egnaro', 'elppaenip', 'yrrebwarts']","title":"Map"},{"location":"MSBD5003/Lecture2/#filter","text":"shortFruits = fruits.filter(lambda fruit: len(fruit) <= 5) shortFruits.collect() ['apple', 'grap', 'lemon']","title":"Filter"},{"location":"MSBD5003/Lecture2/#flatmap","text":"characters = fruits.flatMap(lambda fruit: list(fruit)) print(characters.collect()) ['a', 'p', 'p', 'l', 'e', 'b', 'a', 'n', 'a', 'n', 'a', 'c', 'a', 'n', 'a', 'r', 'y', ' ', 'm', 'e', 'l', 'o', 'n', 'g', 'r', 'a', 'p', 'l', 'e', 'm', 'o', 'n', 'o', 'r', 'a', 'n', 'g', 'e', 'p', 'i', 'n', 'e', 'a', 'p', 'p', 'l', 'e', 's', 't', 'r', 'a', 'w', 'b', 'e', 'r', 'r', 'y']","title":"FlatMap"},{"location":"MSBD5003/Lecture2/#collect","text":"new_fruits = fruits.union(fruits) new_fruits.collect() ['apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry', 'apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry'] new_fruits = fruits.intersection(fruits) new_fruits.collect() ['orange', 'pineapple', 'canary melon', 'lemon', 'banana', 'apple', 'grap', 'strawberry'] new_fruits = fruits.union(fruits).distinct() new_fruits.collect() ['orange', 'pineapple', 'canary melon', 'lemon', 'banana', 'apple', 'grap', 'strawberry']","title":"Collect"},{"location":"MSBD5003/Lecture2/#rdd-actions","text":"","title":"RDD Actions"},{"location":"MSBD5003/Lecture2/#collect_1","text":"","title":"collect"},{"location":"MSBD5003/Lecture2/#take","text":"first3Fruits = fruits.take(3) print(first3Fruits) ['apple', 'banana', 'canary melon']","title":"take"},{"location":"MSBD5003/Lecture2/#count","text":"fruits.count() 8","title":"count"},{"location":"MSBD5003/Lecture2/#reduce","text":"fruits.map(lambda fruit: set(fruit)).reduce(lambda x, y: x.union(y)) {' ', 'a', 'b', 'c', 'e', 'g', 'i', 'l', 'm', 'n', 'o', 'p', 'r', 's', 't', 'w', 'y'}","title":"reduce"},{"location":"MSBD5003/Lecture3/","text":"!pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 69kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 40.7MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=afa56cc6a9466c8bd467ecaf305826a28ca15fb5f31ee4f848525e71d4193f60 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 Example: Linear-time selection \u00b6 Problem: \u00b6 \u2014 Input: an array A of n numbers (unordered), and k \u2014 Output: the k-th smallest number (counting from 0) Algorithm \u00b6 \\(x=A[0]\\) partition A into \\(A[0..mid-1] < A[mid] = x < A[mid+1..n-1]\\) if \\(mid =k\\) then return \\(x\\) if \\(k<mid\\) then \\(A= A[O..mid-1]\\) if k > mid then \\(A = A[mid+1,n-1], k= k\u2014 mid-1\\) gotostep 1 Key-value Pairs \u00b6 While most Spark operations work on RDDs containing any type of objects, a few special operations are only available on RDDs of key-value pairs. In Python, these operations work on RDDs containing built-in Python tuples such as (1, 2). Simply create such tuples and then call your desired operation. For example, the following code uses the reduceByKey operation on key-value pairs to count how many times each line of text occurs in a file: lines = sc . textFile ( \"README.md\" ) pairs = lines . map ( lambda s : ( s , 1 )) counts = pairs . reduceByKey ( lambda a , b : a + b ) We could also use counts.sortByKey() , for example, to sort the pairs alphabetically, and finally counts.collect() to bring them back to the driver program as a list of objects. PMI \u00b6 PMI (pointwise mutual information) is a measure of association used in information theory and statistics. Given a list of pairs (x, y) \\[pmi(x, y) = log\\frac{p(x,y)}{p(x)p(y}\\] where - \\(p(x)\\) : probability of x - \\(p(y)\\) : probability of y - \\(p(x,y)\\) : joint probability Example: p(x=0) = 0.8, p(x=1)=0.2, p(y=0)=0.25, p(y=1)=0.75 pmi(x=0;y=0) = \u22121 pmi(x=0;y=1) = 0.222392 pmi(x=1;y=0) = 1.584963 pmi(x=1;y=1) = -1.584963 Example notebook see: note book in class/PMI","title":"Lecture3"},{"location":"MSBD5003/Lecture3/#example-linear-time-selection","text":"","title":"Example: Linear-time selection"},{"location":"MSBD5003/Lecture3/#problem","text":"\u2014 Input: an array A of n numbers (unordered), and k \u2014 Output: the k-th smallest number (counting from 0)","title":"Problem:"},{"location":"MSBD5003/Lecture3/#algorithm","text":"\\(x=A[0]\\) partition A into \\(A[0..mid-1] < A[mid] = x < A[mid+1..n-1]\\) if \\(mid =k\\) then return \\(x\\) if \\(k<mid\\) then \\(A= A[O..mid-1]\\) if k > mid then \\(A = A[mid+1,n-1], k= k\u2014 mid-1\\) gotostep 1","title":"Algorithm"},{"location":"MSBD5003/Lecture3/#key-value-pairs","text":"While most Spark operations work on RDDs containing any type of objects, a few special operations are only available on RDDs of key-value pairs. In Python, these operations work on RDDs containing built-in Python tuples such as (1, 2). Simply create such tuples and then call your desired operation. For example, the following code uses the reduceByKey operation on key-value pairs to count how many times each line of text occurs in a file: lines = sc . textFile ( \"README.md\" ) pairs = lines . map ( lambda s : ( s , 1 )) counts = pairs . reduceByKey ( lambda a , b : a + b ) We could also use counts.sortByKey() , for example, to sort the pairs alphabetically, and finally counts.collect() to bring them back to the driver program as a list of objects.","title":"Key-value Pairs"},{"location":"MSBD5003/Lecture3/#pmi","text":"PMI (pointwise mutual information) is a measure of association used in information theory and statistics. Given a list of pairs (x, y) \\[pmi(x, y) = log\\frac{p(x,y)}{p(x)p(y}\\] where - \\(p(x)\\) : probability of x - \\(p(y)\\) : probability of y - \\(p(x,y)\\) : joint probability Example: p(x=0) = 0.8, p(x=1)=0.2, p(y=0)=0.25, p(y=1)=0.75 pmi(x=0;y=0) = \u22121 pmi(x=0;y=1) = 0.222392 pmi(x=1;y=0) = 1.584963 pmi(x=1;y=1) = -1.584963 Example notebook see: note book in class/PMI","title":"PMI"},{"location":"MSBD5003/Lecture4/","text":"SQL \u00b6 A tuple = a record = row A table = a set of tuples join \u00b6 support we have a table with following schema drop table if exists product , location ; create table location ( id int primary key auto_increment , location text not null ); create table product ( id int primary key auto_increment , name text , location_id int , foreign key ( location_id ) references location ( id ) ); insert into location ( location ) values ( 'Shenzhen' ); insert into location ( location ) values ( 'Shanghai' ); insert into location ( location ) values ( 'Beijing' ); insert into product ( name , location_id ) values ( 'iPad' , 1 ); insert into product ( name , location_id ) values ( 'iPhone' , 2 ); insert into product ( name , location_id ) values ( 'iMac' , 3 ); First way \u00b6 select name from product inner join location l on product . location_id = l . id where location = 'Shenzhen' ; Second way \u00b6 select name from product , location l where location_id = l . id and location = 'Shenzhen' ; Outter join \u00b6 iPad Shenzhen iPhone Shanghai iMac Beijing Null Hangzhou Inner join \u00b6 iPad Shenzhen iPhone Shanghai iMac Beijing PySpark \u00b6 !pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 61kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 32.1MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=bde33d542b14d579dae0fe882a74c735cdcb1eb1aa95d876737953e41f19d397 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.sql import Row row = Row(name='Alice', age=11) row.name, row.age ('Alice', 11) row = Row(name='Alice', age=11, count=1) print(f\"Row.count: {row.count}\") print(f\"Row['count']: {row['count']}\") Row.count: <built-in method count of Row object at 0x7fd3091ecaf0> Row['count']: 1","title":"Lecture4"},{"location":"MSBD5003/Lecture4/#sql","text":"A tuple = a record = row A table = a set of tuples","title":"SQL"},{"location":"MSBD5003/Lecture4/#join","text":"support we have a table with following schema drop table if exists product , location ; create table location ( id int primary key auto_increment , location text not null ); create table product ( id int primary key auto_increment , name text , location_id int , foreign key ( location_id ) references location ( id ) ); insert into location ( location ) values ( 'Shenzhen' ); insert into location ( location ) values ( 'Shanghai' ); insert into location ( location ) values ( 'Beijing' ); insert into product ( name , location_id ) values ( 'iPad' , 1 ); insert into product ( name , location_id ) values ( 'iPhone' , 2 ); insert into product ( name , location_id ) values ( 'iMac' , 3 );","title":"join"},{"location":"MSBD5003/Lecture4/#first-way","text":"select name from product inner join location l on product . location_id = l . id where location = 'Shenzhen' ;","title":"First way"},{"location":"MSBD5003/Lecture4/#second-way","text":"select name from product , location l where location_id = l . id and location = 'Shenzhen' ;","title":"Second way"},{"location":"MSBD5003/Lecture4/#outter-join","text":"iPad Shenzhen iPhone Shanghai iMac Beijing Null Hangzhou","title":"Outter join"},{"location":"MSBD5003/Lecture4/#inner-join","text":"iPad Shenzhen iPhone Shanghai iMac Beijing","title":"Inner join"},{"location":"MSBD5003/Lecture4/#pyspark","text":"!pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 61kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 32.1MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=bde33d542b14d579dae0fe882a74c735cdcb1eb1aa95d876737953e41f19d397 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.sql import Row row = Row(name='Alice', age=11) row.name, row.age ('Alice', 11) row = Row(name='Alice', age=11, count=1) print(f\"Row.count: {row.count}\") print(f\"Row['count']: {row['count']}\") Row.count: <built-in method count of Row object at 0x7fd3091ecaf0> Row['count']: 1","title":"PySpark"},{"location":"MSBD5003/Lecture5/","text":"","title":"Lecture5"},{"location":"MSBD5003/Lecture6/","text":"Define cloud \u00b6 On Demand Scalable Multi-Tenant Self service Reliability Utility Based Subscription Public cloud \u00b6 Providers let clients access the cloud via Internet Made available to the general public Private cloud \u00b6 The cloud is used solely by an organization (e.g. HKUST, Facebook, HSBC) May reside in-house or off-premise Secure, dedicated infrastructure with the benefits of on-demand provisioning Not burdened by network bandwidth and availability issues and security threats associated with public clouds. Greater control, security, and resilience. Hybrid cloud \u00b6 Composed of multiple clouds (private, public, etc.) that remain independent entities, but interoperate using standard or proprietary protocols Banks, hospitals, government Infrastructure-as-a-Service \u00b6 Providers give you the computing infrastructure made available as a service. You get \u201cbare-metal\u201d machines. Providers manage a large pool of resources, and use virtualization to dynamically allocate Customers \u201crent\u201d these physical resources to customize their own infrastructure Full control of OS, storage, applications, and some networking components (e.g., firewalls) IaaS \u00b6 Netflix rents thousands of servers, terabytes of storage from Amazon Web Services (AWS) Develop and deploy specialized software for transcoding, storage, streaming, analytics, etc. on top of it Is able to support tens of millions of connected devices, used by 40+ million users from 40+ countries PaaS \u00b6 Providers give you a software platform, or middleware, where applications run You develop and maintain and deploy your own software on top of the platform The hardware needed for running the software is automatically managed by the platform. You can\u2019t explicitly ask for resources. SaaS \u00b6 Providers give you a piece of software/application. They take care of updating, and maintaining it. You simply use the software through the Internet. Why the cloud \u00b6 Pay only for what you use Easy/fast deployment to end users Monthly payments Encourages standard systems Requires less in-house staff, costs Resource pooling \u00b6 The provider\u2019s resources are pooled to serve consumers using a multi-tenant model, with different physical and virtual resources dynamically allocated according to consumer demand. Location independence: the customer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter). Advantage for providers: efficiency in utilization","title":"Lecture6"},{"location":"MSBD5003/Lecture6/#define-cloud","text":"On Demand Scalable Multi-Tenant Self service Reliability Utility Based Subscription","title":"Define cloud"},{"location":"MSBD5003/Lecture6/#public-cloud","text":"Providers let clients access the cloud via Internet Made available to the general public","title":"Public cloud"},{"location":"MSBD5003/Lecture6/#private-cloud","text":"The cloud is used solely by an organization (e.g. HKUST, Facebook, HSBC) May reside in-house or off-premise Secure, dedicated infrastructure with the benefits of on-demand provisioning Not burdened by network bandwidth and availability issues and security threats associated with public clouds. Greater control, security, and resilience.","title":"Private cloud"},{"location":"MSBD5003/Lecture6/#hybrid-cloud","text":"Composed of multiple clouds (private, public, etc.) that remain independent entities, but interoperate using standard or proprietary protocols Banks, hospitals, government","title":"Hybrid cloud"},{"location":"MSBD5003/Lecture6/#infrastructure-as-a-service","text":"Providers give you the computing infrastructure made available as a service. You get \u201cbare-metal\u201d machines. Providers manage a large pool of resources, and use virtualization to dynamically allocate Customers \u201crent\u201d these physical resources to customize their own infrastructure Full control of OS, storage, applications, and some networking components (e.g., firewalls)","title":"Infrastructure-as-a-Service"},{"location":"MSBD5003/Lecture6/#iaas","text":"Netflix rents thousands of servers, terabytes of storage from Amazon Web Services (AWS) Develop and deploy specialized software for transcoding, storage, streaming, analytics, etc. on top of it Is able to support tens of millions of connected devices, used by 40+ million users from 40+ countries","title":"IaaS"},{"location":"MSBD5003/Lecture6/#paas","text":"Providers give you a software platform, or middleware, where applications run You develop and maintain and deploy your own software on top of the platform The hardware needed for running the software is automatically managed by the platform. You can\u2019t explicitly ask for resources.","title":"PaaS"},{"location":"MSBD5003/Lecture6/#saas","text":"Providers give you a piece of software/application. They take care of updating, and maintaining it. You simply use the software through the Internet.","title":"SaaS"},{"location":"MSBD5003/Lecture6/#why-the-cloud","text":"Pay only for what you use Easy/fast deployment to end users Monthly payments Encourages standard systems Requires less in-house staff, costs","title":"Why the cloud"},{"location":"MSBD5003/Lecture6/#resource-pooling","text":"The provider\u2019s resources are pooled to serve consumers using a multi-tenant model, with different physical and virtual resources dynamically allocated according to consumer demand. Location independence: the customer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter). Advantage for providers: efficiency in utilization","title":"Resource pooling"},{"location":"MSBD5003/Lecture7/","text":"Code at internal.ipynb Data Partitioning \u00b6 RDDs are stored in partitions. When performing computations on RDDs, these partitions can be operated on in parallel. You get better parallelism when the partitions are balanced. When RDDs are first created, the partitions are balanced. However, partitions may get out of balance after certain transformations. Hash Partitioning \u00b6 We can view the contents of each partition: - e.g., prime.glom().collect()[1][0:4] - We see that it hashed all numbers x such that x mod 8 = 1 to partition #1 In general, hash partitioning allocates tuple (k, v) to partition p where - p = k.hashCode() % numPartitions Usually works well but be aware of bad inputs! Shuffle \u00b6 Spark uses shuffles to implement wide dependencies - Examples: reduceByKey, repartition, coalesce, join (on RDDs not partitioned using the same partitioner) Spark generates sets of tasks - map tasks to organize the data, and a set of reduce tasks to group/aggregate it. Internally, Spark builds a hash table within each task to perform the grouping. If the hash table is too large, Spark will spill these tables to disk, incurring the additional overhead of disk I/O RDDs resulting from shuffles are automatically cached. Range partitioning \u00b6 For data types that have or ordering defined - Examples: Int, Char, String, \u2026 - Internally, Spark samples the data so as to produce more balanced partitions. - Used by default after sorting Example: - An RDD with keys [8, 96, 240, 400, 401, 800], - Number of partitions: 4 - In this case, hash partitioning distributes the keys as follows among the partitions: - partition 0: [8, 96, 240, 400, 800] - partition 1: [401] - partition 2: [] - partition 3: [] Range partitioning would improve the partitioning significantly Partitioner inheritance \u00b6 Operations on Pair RDDs that hold to (and propagate) a partitioner: mapValues (if parent has a partitioner) flatMapValues (if parent has a partitioner) filter (if parent has a partitioner)","title":"Lecture7"},{"location":"MSBD5003/Lecture7/#data-partitioning","text":"RDDs are stored in partitions. When performing computations on RDDs, these partitions can be operated on in parallel. You get better parallelism when the partitions are balanced. When RDDs are first created, the partitions are balanced. However, partitions may get out of balance after certain transformations.","title":"Data Partitioning"},{"location":"MSBD5003/Lecture7/#hash-partitioning","text":"We can view the contents of each partition: - e.g., prime.glom().collect()[1][0:4] - We see that it hashed all numbers x such that x mod 8 = 1 to partition #1 In general, hash partitioning allocates tuple (k, v) to partition p where - p = k.hashCode() % numPartitions Usually works well but be aware of bad inputs!","title":"Hash Partitioning"},{"location":"MSBD5003/Lecture7/#shuffle","text":"Spark uses shuffles to implement wide dependencies - Examples: reduceByKey, repartition, coalesce, join (on RDDs not partitioned using the same partitioner) Spark generates sets of tasks - map tasks to organize the data, and a set of reduce tasks to group/aggregate it. Internally, Spark builds a hash table within each task to perform the grouping. If the hash table is too large, Spark will spill these tables to disk, incurring the additional overhead of disk I/O RDDs resulting from shuffles are automatically cached.","title":"Shuffle"},{"location":"MSBD5003/Lecture7/#range-partitioning","text":"For data types that have or ordering defined - Examples: Int, Char, String, \u2026 - Internally, Spark samples the data so as to produce more balanced partitions. - Used by default after sorting Example: - An RDD with keys [8, 96, 240, 400, 401, 800], - Number of partitions: 4 - In this case, hash partitioning distributes the keys as follows among the partitions: - partition 0: [8, 96, 240, 400, 800] - partition 1: [401] - partition 2: [] - partition 3: [] Range partitioning would improve the partitioning significantly","title":"Range partitioning"},{"location":"MSBD5003/Lecture7/#partitioner-inheritance","text":"Operations on Pair RDDs that hold to (and propagate) a partitioner: mapValues (if parent has a partitioner) flatMapValues (if parent has a partitioner) filter (if parent has a partitioner)","title":"Partitioner inheritance"},{"location":"MSBD5003/Lecture8/","text":"Algorithm Design \u00b6 !pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 63kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 38.8MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=c2149ee5f1b68200a671dfab446e477b77a733c24b319c6e977cd2618ae1a79e Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 Divide-and-Conquer \u00b6 Classical D&C - Divide problem into 2 parts - Recursively solve each part - Combine the results together D&C under big data systems Divide problem into \ufffc partitions, where (ideally) \ufffc is the number of executors in the system Solve the problem on each partition Combine the results together Example: sum(), reduce() Prefix sums \u00b6 Input: Sequence x of n elements, binary associative operator + Output: Sequence y of n elements, with\u2028yk = x1 + ... + xk Example: x = [1, 4, 3, 5, 6, 7, 0, 1] y = [1, 5, 8, 13, 19, 26, 26, 27] Algorithm: Compute sum for each partition Compute the prefix sums of the \ufffc sums Compute prefix sums in each partition Time: O(2n) from pyspark.context import SparkContext sc = SparkContext . getOrCreate () x = [ 1, 4, 3, 5, 6, 7, 0, 1 ] rdd = sc . parallelize ( x , 4 ). cache () def f ( i ) : yield sum ( i ) sums = rdd . mapPartitions ( f ). collect () print ( sums ) for i in range ( 1 , len ( sums )) : sums [ i ] += sums [ i - 1 ] print ( sums ) def g ( index , iter ) : global sums if index == 0 : s = 0 else : s = sums [ index - 1 ] for i in iter : s += i yield s prefix_sums = rdd . mapPartitionsWithIndex ( g ) print ( prefix_sums . collect ()) [5, 8, 13, 1] [5, 13, 26, 27] [1, 5, 8, 13, 19, 26, 26, 27] Given a sequence of integers, check whether these numbers are monotonically decreasing. x = [ 1, 3, 5, 6, 7, 8, 3 ] rdd = sc . parallelize ( x , 4 ). cache () def f ( it ) : first = next ( it ) last = first increasing = True for i in it : if i < last : increasing = False last = i yield increasing , first , last results = rdd . mapPartitions ( f ). collect () print ( results ) increasing = True if results [ 0 ][ 0 ] == False : increasing = False else : for i in range ( 1 , len ( results )) : if results [ i ][ 0 ] == False or results [ i ][ 1 ] < results [ i - 1 ][ 2 ] : increasing = False print ( increasing ) [(True, 1, 1), (True, 3, 5), (True, 6, 7), (False, 8, 3)] False Maximum sub array \u00b6 Level 1: Naively: 2 executors are working, all others idle time = \ufffc \\(O(n/2)\\) Smarter: \ufffc \\(L_m\\) and \\(R_m\\) \ufffc can be found by the prefix-sum algorithm Can use all executors, time =$O(n/p) \ufffc Level 2: We have 4 subarrays, and solve two prefix-sums for each subarray Each subarray has size \ufffc, and we make sure that each has the same number of partitions Time = \ufffc \\(O(n / p\\) Level 3: Time = \ufffc \\(O(n / p)\\) Stop recursion when each subarray is one partition. Total time: \ufffc \\(O(\\frac{n}{p}\\times logp)\\)","title":"Lecture8"},{"location":"MSBD5003/Lecture8/#algorithm-design","text":"!pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 63kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 38.8MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=c2149ee5f1b68200a671dfab446e477b77a733c24b319c6e977cd2618ae1a79e Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1","title":"Algorithm Design"},{"location":"MSBD5003/Lecture8/#divide-and-conquer","text":"Classical D&C - Divide problem into 2 parts - Recursively solve each part - Combine the results together D&C under big data systems Divide problem into \ufffc partitions, where (ideally) \ufffc is the number of executors in the system Solve the problem on each partition Combine the results together Example: sum(), reduce()","title":"Divide-and-Conquer"},{"location":"MSBD5003/Lecture8/#prefix-sums","text":"Input: Sequence x of n elements, binary associative operator + Output: Sequence y of n elements, with\u2028yk = x1 + ... + xk Example: x = [1, 4, 3, 5, 6, 7, 0, 1] y = [1, 5, 8, 13, 19, 26, 26, 27] Algorithm: Compute sum for each partition Compute the prefix sums of the \ufffc sums Compute prefix sums in each partition Time: O(2n) from pyspark.context import SparkContext sc = SparkContext . getOrCreate () x = [ 1, 4, 3, 5, 6, 7, 0, 1 ] rdd = sc . parallelize ( x , 4 ). cache () def f ( i ) : yield sum ( i ) sums = rdd . mapPartitions ( f ). collect () print ( sums ) for i in range ( 1 , len ( sums )) : sums [ i ] += sums [ i - 1 ] print ( sums ) def g ( index , iter ) : global sums if index == 0 : s = 0 else : s = sums [ index - 1 ] for i in iter : s += i yield s prefix_sums = rdd . mapPartitionsWithIndex ( g ) print ( prefix_sums . collect ()) [5, 8, 13, 1] [5, 13, 26, 27] [1, 5, 8, 13, 19, 26, 26, 27] Given a sequence of integers, check whether these numbers are monotonically decreasing. x = [ 1, 3, 5, 6, 7, 8, 3 ] rdd = sc . parallelize ( x , 4 ). cache () def f ( it ) : first = next ( it ) last = first increasing = True for i in it : if i < last : increasing = False last = i yield increasing , first , last results = rdd . mapPartitions ( f ). collect () print ( results ) increasing = True if results [ 0 ][ 0 ] == False : increasing = False else : for i in range ( 1 , len ( results )) : if results [ i ][ 0 ] == False or results [ i ][ 1 ] < results [ i - 1 ][ 2 ] : increasing = False print ( increasing ) [(True, 1, 1), (True, 3, 5), (True, 6, 7), (False, 8, 3)] False","title":"Prefix sums"},{"location":"MSBD5003/Lecture8/#maximum-sub-array","text":"Level 1: Naively: 2 executors are working, all others idle time = \ufffc \\(O(n/2)\\) Smarter: \ufffc \\(L_m\\) and \\(R_m\\) \ufffc can be found by the prefix-sum algorithm Can use all executors, time =$O(n/p) \ufffc Level 2: We have 4 subarrays, and solve two prefix-sums for each subarray Each subarray has size \ufffc, and we make sure that each has the same number of partitions Time = \ufffc \\(O(n / p\\) Level 3: Time = \ufffc \\(O(n / p)\\) Stop recursion when each subarray is one partition. Total time: \ufffc \\(O(\\frac{n}{p}\\times logp)\\)","title":"Maximum sub array"},{"location":"MSBD5003/homeworks/HW4/","text":"Question 1 \u00b6 Write code to perform the following tasks using GraphFrames: Find Alice's two-hop neighbors' names, regardless of the edge type. Question 2 \u00b6 Redo the previous question, but exclude Alice's two-hop neighbors who have an edge back to Alice. Question 3 \u00b6 Find all people who follow Charlie. Hint: Use AND in SQL, or (..) & (..) in DataFrame boolean expressions. Question 4 \u00b6 Find all people who are being followed by at least 2 people. Question 5 \u00b6 Create a queue of 10 RDDs using this data set and feed it into a Spark Streaming program. Your Spark Streaming algorithm should maintain a state that keeps track of the longest noun seen so far associated with each distinct adjective. After each RDD, print any 5 adjectives and their associated longest nouns, as well as the longest noun associated with the adjective 'good'. Note that not every line in the data set contains exactly two words, so make sure to clean the data as they are fed into the streaming program. The skeleton code is provided below: from pyspark.streaming import StreamingContext ssc = StreamingContext ( sc , 5 ) # Provide a checkpointing directory. Required for stateful transformations ssc . checkpoint ( \"checkpoint\" ) numPartitions = 8 rdd = sc . textFile ( '../data/adj_noun_pairs.txt' , numPartitions ) rddQueue = rdd . randomSplit ([ 1 ] * 10 , 123 ) lines = ssc . queueStream ( rddQueue ) # FILL IN YOUR CODE ssc . start () ssc . awaitTermination ( 50 ) ssc . stop ( False ) print ( \"Finished\" )","title":"Hw4"},{"location":"MSBD5003/homeworks/HW4/#question-1","text":"Write code to perform the following tasks using GraphFrames: Find Alice's two-hop neighbors' names, regardless of the edge type.","title":"Question 1"},{"location":"MSBD5003/homeworks/HW4/#question-2","text":"Redo the previous question, but exclude Alice's two-hop neighbors who have an edge back to Alice.","title":"Question 2"},{"location":"MSBD5003/homeworks/HW4/#question-3","text":"Find all people who follow Charlie. Hint: Use AND in SQL, or (..) & (..) in DataFrame boolean expressions.","title":"Question 3"},{"location":"MSBD5003/homeworks/HW4/#question-4","text":"Find all people who are being followed by at least 2 people.","title":"Question 4"},{"location":"MSBD5003/homeworks/HW4/#question-5","text":"Create a queue of 10 RDDs using this data set and feed it into a Spark Streaming program. Your Spark Streaming algorithm should maintain a state that keeps track of the longest noun seen so far associated with each distinct adjective. After each RDD, print any 5 adjectives and their associated longest nouns, as well as the longest noun associated with the adjective 'good'. Note that not every line in the data set contains exactly two words, so make sure to clean the data as they are fed into the streaming program. The skeleton code is provided below: from pyspark.streaming import StreamingContext ssc = StreamingContext ( sc , 5 ) # Provide a checkpointing directory. Required for stateful transformations ssc . checkpoint ( \"checkpoint\" ) numPartitions = 8 rdd = sc . textFile ( '../data/adj_noun_pairs.txt' , numPartitions ) rddQueue = rdd . randomSplit ([ 1 ] * 10 , 123 ) lines = ssc . queueStream ( rddQueue ) # FILL IN YOUR CODE ssc . start () ssc . awaitTermination ( 50 ) ssc . stop ( False ) print ( \"Finished\" )","title":"Question 5"},{"location":"MSBD5003/homeworks/hw1/","text":"!pip install pyspar import requests from pyspark.context import SparkContext r = requests . get ( 'https://www.cse.ust.hk/msbd5003/data/fruits.txt' ) open ( 'fruits.txt' , 'wb' ) . write ( r . content ) sc = SparkContext . getOrCreate () Question 1 \u00b6 The following piece of code computes the frequencies of the words in a text file: from operator import add lines = sc . textFile ( 'README.md' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) Add one line to find the most frequent word. Output this word and its frequency. Hint: Use sortBy(), reduce(), or max() from operator import add lines = sc . textFile ( 'sample_data/README.md' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) \\ . max ( key = lambda x : x [ 1 ]) print ( counts ) ('is', 4) Question 2 \u00b6 Modify the word count example above, so that we only count the frequencies of those words consisting of 5 or more characters. from operator import add lines = sc . textFile ( 'sample_data/README.md' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) \\ . filter ( lambda x : len ( x [ 0 ]) >= 5 ) print ( counts . take ( 10 )) [('directory', 1), ('datasets', 1), ('`california_housing_data*.csv`', 1), ('housing', 1), ('https://developers.google.com/machine-learning/crash-course/california-housing-data-description', 1), ('`mnist_*.csv`', 1), (\"[Anscombe's\", 1), ('originally', 1), ('Anscombe,', 1), (\"'Graphs\", 1)] Question 3 \u00b6 Consider the following piece of code: A = sc . parallelize ( range ( 1 , 100 )) t = 50 B = A . filter ( lambda x : x < t ) print ( B . count ()) t = 10 C = B . filter ( lambda x : x > t ) print ( C . count ()) What's its output? (Yes, you can just run it.) A = sc.parallelize(range(1, 100)) t = 50 B = A.filter(lambda x: x < t) print(B.count()) t = 10 C = B.filter(lambda x: x > t) print(C.count()) 49 0 Question 4 \u00b6 The intent of the code above is to get all numbers below 50 from A and put them into B, and then get all numbers above 10 from B and put them into C. Fix the code so that it produces the desired behavior, by adding one line of code. You are not allowed to change the existing code. A = sc.parallelize(range(1, 100)) t = 50 B = A.filter(lambda x: x < t) B.cache() print(B.count()) t = 10 C = B.filter(lambda x: x > t) print(C.count()) 49 39 Question 5 \u00b6 Modify the PMI example by sending a_dict and n_dict inside the closure. Do not use broadcast variables. By changing broadcast variable n_dict = sc.broadcast(n_freqs.collectAsMap()) a_dict = sc.broadcast(a_freqs.collectAsMap()) to global variable n_dict = n_freqs . collectAsMap () a_dict = a_freqs . collectAsMap () Question 6 \u00b6 The following code creates an RDD with 4 partitions: partition 0, 1, 2, and 3. A = sc . parallelize ( range ( 100 ), 4 ) For each item in the RDD, add its partition number to it, and write the results to another RDD, i.e., the resulting RDD should contain: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102] def f ( splitIndex , iterator ): for i in iterator : yield i + splitIndex A = sc . parallelize ( range ( 100 ), 4 ) A . mapPartitionsWithIndex ( f ). collect ()","title":"Hw1"},{"location":"MSBD5003/homeworks/hw1/#question-1","text":"The following piece of code computes the frequencies of the words in a text file: from operator import add lines = sc . textFile ( 'README.md' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) Add one line to find the most frequent word. Output this word and its frequency. Hint: Use sortBy(), reduce(), or max() from operator import add lines = sc . textFile ( 'sample_data/README.md' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) \\ . max ( key = lambda x : x [ 1 ]) print ( counts ) ('is', 4)","title":"Question 1"},{"location":"MSBD5003/homeworks/hw1/#question-2","text":"Modify the word count example above, so that we only count the frequencies of those words consisting of 5 or more characters. from operator import add lines = sc . textFile ( 'sample_data/README.md' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) \\ . filter ( lambda x : len ( x [ 0 ]) >= 5 ) print ( counts . take ( 10 )) [('directory', 1), ('datasets', 1), ('`california_housing_data*.csv`', 1), ('housing', 1), ('https://developers.google.com/machine-learning/crash-course/california-housing-data-description', 1), ('`mnist_*.csv`', 1), (\"[Anscombe's\", 1), ('originally', 1), ('Anscombe,', 1), (\"'Graphs\", 1)]","title":"Question 2"},{"location":"MSBD5003/homeworks/hw1/#question-3","text":"Consider the following piece of code: A = sc . parallelize ( range ( 1 , 100 )) t = 50 B = A . filter ( lambda x : x < t ) print ( B . count ()) t = 10 C = B . filter ( lambda x : x > t ) print ( C . count ()) What's its output? (Yes, you can just run it.) A = sc.parallelize(range(1, 100)) t = 50 B = A.filter(lambda x: x < t) print(B.count()) t = 10 C = B.filter(lambda x: x > t) print(C.count()) 49 0","title":"Question 3"},{"location":"MSBD5003/homeworks/hw1/#question-4","text":"The intent of the code above is to get all numbers below 50 from A and put them into B, and then get all numbers above 10 from B and put them into C. Fix the code so that it produces the desired behavior, by adding one line of code. You are not allowed to change the existing code. A = sc.parallelize(range(1, 100)) t = 50 B = A.filter(lambda x: x < t) B.cache() print(B.count()) t = 10 C = B.filter(lambda x: x > t) print(C.count()) 49 39","title":"Question 4"},{"location":"MSBD5003/homeworks/hw1/#question-5","text":"Modify the PMI example by sending a_dict and n_dict inside the closure. Do not use broadcast variables. By changing broadcast variable n_dict = sc.broadcast(n_freqs.collectAsMap()) a_dict = sc.broadcast(a_freqs.collectAsMap()) to global variable n_dict = n_freqs . collectAsMap () a_dict = a_freqs . collectAsMap ()","title":"Question 5"},{"location":"MSBD5003/homeworks/hw1/#question-6","text":"The following code creates an RDD with 4 partitions: partition 0, 1, 2, and 3. A = sc . parallelize ( range ( 100 ), 4 ) For each item in the RDD, add its partition number to it, and write the results to another RDD, i.e., the resulting RDD should contain: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102] def f ( splitIndex , iterator ): for i in iterator : yield i + splitIndex A = sc . parallelize ( range ( 100 ), 4 ) A . mapPartitionsWithIndex ( f ). collect ()","title":"Question 6"},{"location":"MSBD5003/homeworks/hw2/","text":"!pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 62kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 38.1MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=579f4f3993e28b1ba393be6ffc555dc3c75b4997f72e1ad9bd8ec34f37910075 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.context import SparkContext from pyspark.sql.session import SparkSession sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) df = spark.read.csv('/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/sales.csv', header=True, inferSchema=True) df.show() +----------------+--------+-----+------------+-----------------+--------------------+--------------+--------------+----------------+----------------+-----------+----------+ |Transaction_date| Product|Price|Payment_Type| Name| City| State| Country| Account_Created| Last_Login| Latitude| Longitude| +----------------+--------+-----+------------+-----------------+--------------------+--------------+--------------+----------------+----------------+-----------+----------+ | 01/02/2009 6:17|Product1| 1200| Mastercard| carolina| Basildon| England|United Kingdom| 01/02/2009 6:00| 01/02/2009 6:08| 51.5|-1.1166667| | 01/02/2009 4:53|Product1| 1200| Visa| Betina|Parkville ...| MO| United States| 01/02/2009 4:42| 01/02/2009 7:49| 39.195| -94.68194| |01/02/2009 13:08|Product1| 1200| Mastercard|Federica e Andrea|Astoria ...| OR| United States|01/01/2009 16:21|01/03/2009 12:32| 46.18806| -123.83| |01/03/2009 14:44|Product1| 1200| Visa| Gouya| Echuca| Victoria| Australia| 9/25/05 21:13|01/03/2009 14:22|-36.1333333| 144.75| |01/04/2009 12:56|Product2| 3600| Visa| Gerd W |Cahaba Heights ...| AL| United States| 11/15/08 15:47|01/04/2009 12:45| 33.52056| -86.8025| |01/04/2009 13:19|Product1| 1200| Visa| LAURENCE|Mickleton ...| NJ| United States| 9/24/08 15:19|01/04/2009 13:04| 39.79| -75.23806| |01/04/2009 20:11|Product1| 1200| Mastercard| Fleur|Peoria ...| IL| United States| 01/03/2009 9:38|01/04/2009 19:45| 40.69361| -89.58889| |01/02/2009 20:09|Product1| 1200| Mastercard| adam|Martin ...| TN| United States|01/02/2009 17:43|01/04/2009 20:01| 36.34333| -88.85028| |01/04/2009 13:17|Product1| 1200| Mastercard| Renee Elisabeth| Tel Aviv| Tel Aviv| Israel|01/04/2009 13:03|01/04/2009 22:10| 32.0666667|34.7666667| |01/04/2009 14:11|Product1| 1200| Visa| Aidan| Chatou| Ile-de-France| France| 06/03/2008 4:22| 01/05/2009 1:17| 48.8833333| 2.15| | 01/05/2009 2:42|Product1| 1200| Diners| Stacy|New York ...| NY| United States| 01/05/2009 2:23| 01/05/2009 4:59| 40.71417| -74.00639| | 01/05/2009 5:39|Product1| 1200| Amex| Heidi| Eindhoven| Noord-Brabant| Netherlands| 01/05/2009 4:55| 01/05/2009 8:15| 51.45| 5.4666667| | 01/02/2009 9:16|Product1| 1200| Mastercard| Sean |Shavano Park ...| TX| United States| 01/02/2009 8:32| 01/05/2009 9:05| 29.42389| -98.49333| |01/05/2009 10:08|Product1| 1200| Visa| Georgia|Eagle ...| ID| United States|11/11/2008 15:53|01/05/2009 10:05| 43.69556|-116.35306| |01/02/2009 14:18|Product1| 1200| Visa| Richard|Riverside ...| NJ| United States|12/09/2008 12:07|01/05/2009 11:01| 40.03222| -74.95778| | 01/04/2009 1:05|Product1| 1200| Diners| Leanne| Julianstown| Meath| Ireland| 01/04/2009 0:00|01/05/2009 13:36| 53.6772222|-6.3191667| |01/05/2009 11:37|Product1| 1200| Visa| Janet| Ottawa| Ontario| Canada| 01/05/2009 9:35|01/05/2009 19:24| 45.4166667| -75.7| | 01/06/2009 5:02|Product1| 1200| Diners| barbara| Hyderabad|Andhra Pradesh| India| 01/06/2009 2:41| 01/06/2009 7:52| 17.3833333|78.4666667| | 01/06/2009 7:45|Product2| 3600| Visa| Sabine| London| England|United Kingdom| 01/06/2009 7:00| 01/06/2009 9:17| 51.52721| 0.14559| | 01/02/2009 7:35|Product1| 1200| Diners| Hani|Salt Lake City ...| UT| United States| 12/30/08 5:44|01/06/2009 10:52| 40.76083|-111.89028| +----------------+--------+-----+------------+-----------------+--------------------+--------------+--------------+----------------+----------------+-----------+----------+ only showing top 20 rows Question 1 \u00b6 Find all distinct countries. Hint: use select(), distinct() countries = df.select(\"Country\").distinct() countries.collect() [Row(Country='Sweden'), Row(Country='Jersey'), Row(Country='Malaysia'), Row(Country='Turkey'), Row(Country='Germany'), Row(Country='France'), Row(Country='Belgium'), Row(Country='Finland'), Row(Country='United States'), Row(Country='India'), Row(Country='Kuwait'), Row(Country='Malta'), Row(Country='Italy'), Row(Country='Norway'), Row(Country='Spain'), Row(Country='Denmark'), Row(Country='Ireland'), Row(Country='Israel'), Row(Country='Iceland'), Row(Country='South Korea'), Row(Country='Switzerland'), Row(Country='United Arab Emirates'), Row(Country='Canada'), Row(Country='Brazil'), Row(Country='Luxembourg'), Row(Country='New Zealand'), Row(Country='Australia'), Row(Country='Austria'), Row(Country='South Africa'), Row(Country='Bahrain'), Row(Country='Hungary'), Row(Country='United Kingdom'), Row(Country='Moldova'), Row(Country='Netherlands')] Question 2 \u00b6 Find the Name and Price of sales records in Brazil. Hint: use filter(). df.select(\"Country\", \"Price\").filter(\"Country = 'Brazil' \").show() +-------+-----+ |Country|Price| +-------+-----+ | Brazil| 1200| | Brazil| 7500| +-------+-----+ Question 3 \u00b6 For each country, find the total Price. Hint: Use groupBy() df.groupBy('Country').sum('Price').withColumnRenamed('sum(Price)', \"Total Price\").show() +-------------+-----------+ | Country|Total Price| +-------------+-----------+ | Sweden| 8400| | Jersey| 1200| | Malaysia| 1200| | Turkey| 2400| | Germany| 22800| | France| 30300| | Belgium| 3600| | Finland| 1200| |United States| 350350| | India| 2400| | Kuwait| 1200| | Malta| 3600| | Italy| 2400| | Norway| 12000| | Spain| 2400| | Denmark| 8400| | Ireland| 29100| | Israel| 1200| | Iceland| 1200| | South Korea| 1200| +-------------+-----------+ only showing top 20 rows Question 4 \u00b6 List countries by their total Price in descending order. Hint: Use orderBy() df.groupBy('Country').sum('Price').withColumnRenamed('sum(Price)', \"Total Price\").orderBy('Total Price', ascending=False).show() +--------------------+-----------+ | Country|Total Price| +--------------------+-----------+ | United States| 350350| | United Kingdom| 63600| | Canada| 42000| | France| 30300| | Ireland| 29100| | Germany| 22800| | Australia| 22800| | Switzerland| 19200| | Netherlands| 14400| | Norway| 12000| | Brazil| 8700| | Denmark| 8400| | Sweden| 8400| | Austria| 3600| | South Africa| 3600| | Malta| 3600| | Belgium| 3600| |United Arab Emirates| 3600| | Turkey| 2400| | New Zealand| 2400| +--------------------+-----------+ only showing top 20 rows Question 5 \u00b6 Redo Question 3, but replace the country names by their IDs. Hint: Use join() df2 = spark.read.csv('/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/countries.csv', header=True, inferSchema=True) df2.show() +--------------+---+ | Country| ID| +--------------+---+ |United Kingdom| 1| | United States| 2| | Australia| 3| | Israel| 4| | France| 5| | Netherlands| 6| | Ireland| 7| | Canada| 8| | India| 9| | South Africa| 10| | Finland| 11| | Switzerland| 12| | Denmark| 13| | Belgium| 14| | Sweden| 15| | Norway| 16| | Luxembourg| 17| | Italy| 18| | Germany| 19| | Moldova| 20| +--------------+---+ only showing top 20 rows df.join(df2, 'Country').groupBy('ID').sum('Price').withColumnRenamed('sum(Price)', \"Total Price\").show() +---+-----------+ | ID|Total Price| +---+-----------+ | 31| 1200| | 34| 2400| | 28| 3600| | 26| 3600| | 27| 1200| | 12| 19200| | 22| 3600| | 1| 63600| | 13| 8400| | 6| 14400| | 16| 12000| | 3| 22800| | 20| 1200| | 5| 30300| | 19| 22800| | 15| 8400| | 9| 2400| | 17| 1200| | 4| 1200| | 8| 42000| +---+-----------+ only showing top 20 rows Question 6 \u00b6 Rewrite the PageRank example using DataFrame API. Here is a skeleton of the code. Your job is to fill in the missing part. The data files can be downloaded at: from pyspark.sql.functions import * numOfIterations = 10 lines = spark . read . text ( \"pagerank_data.txt\" ) # You can also test your program on the follow larger data set: # lines = spark.read.text(\"dblp.in\") a = lines . select ( split ( lines [ 0 ], ' ' )) links = a . select ( a [ 0 ][ 0 ] . alias ( 'src' ), a [ 0 ][ 1 ] . alias ( 'dst' )) outdegrees = links . groupBy ( 'src' ) . count () ranks = outdegrees . select ( 'src' , lit ( 1 ) . alias ( 'rank' )) for iteration in range ( numOfIterations ): # FILL IN THIS PART ranks . orderBy ( desc ( 'rank' )) . show () lines = spark.read.text(\"/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/pagerank_data.txt\") lines.show() +-----+ |value| +-----+ | 1 2| | 1 3| | 2 3| | 3 4| | 4 1| | 2 1| +-----+ from pyspark.sql.functions import * from pyspark.sql.types import FloatType from operator import add numOfIterations = 10 # You can also test your program on the follow larger data set: # lines = spark.read.text(\"dblp.in\") a = lines . select ( split ( lines [ 0 ], ' ' )) links = a . select ( a [ 0 ][ 0 ] . alias ( 'src' ), a [ 0 ][ 1 ] . alias ( 'dst' )) outdegrees = links . groupBy ( 'src' ) . count () ranks = outdegrees . select ( 'src' , lit ( 1 ) . alias ( 'rank' )) for iteration in range ( numOfIterations ): contribs = links . join ( ranks , 'src' ) . join ( outdegrees , 'src' ) . withColumnRenamed ( 'count' , 'outdegrees' ) contribs = contribs . select ( 'src' , 'dst' ,( contribs . rank / contribs . outdegrees ) . alias ( 'rank' )) . groupBy ( 'dst' ) . sum () . withColumnRenamed ( 'dst' , 'src' ) . withColumnRenamed ( 'sum(rank)' , 'rank' ) ranks = contribs . select ( 'src' , ( contribs . rank * 0.85 + 0.15 ) . alias ( 'rank' )) ranks . orderBy ( desc ( 'rank' )) . show () +---+------------------+ |src| rank| +---+------------------+ | 1|1.2981882732854677| | 4|0.9999999999999998| | 3|0.9999999999999998| | 2|0.7018117267145316| +---+------------------+","title":"Hw2"},{"location":"MSBD5003/homeworks/hw2/#question-1","text":"Find all distinct countries. Hint: use select(), distinct() countries = df.select(\"Country\").distinct() countries.collect() [Row(Country='Sweden'), Row(Country='Jersey'), Row(Country='Malaysia'), Row(Country='Turkey'), Row(Country='Germany'), Row(Country='France'), Row(Country='Belgium'), Row(Country='Finland'), Row(Country='United States'), Row(Country='India'), Row(Country='Kuwait'), Row(Country='Malta'), Row(Country='Italy'), Row(Country='Norway'), Row(Country='Spain'), Row(Country='Denmark'), Row(Country='Ireland'), Row(Country='Israel'), Row(Country='Iceland'), Row(Country='South Korea'), Row(Country='Switzerland'), Row(Country='United Arab Emirates'), Row(Country='Canada'), Row(Country='Brazil'), Row(Country='Luxembourg'), Row(Country='New Zealand'), Row(Country='Australia'), Row(Country='Austria'), Row(Country='South Africa'), Row(Country='Bahrain'), Row(Country='Hungary'), Row(Country='United Kingdom'), Row(Country='Moldova'), Row(Country='Netherlands')]","title":"Question 1"},{"location":"MSBD5003/homeworks/hw2/#question-2","text":"Find the Name and Price of sales records in Brazil. Hint: use filter(). df.select(\"Country\", \"Price\").filter(\"Country = 'Brazil' \").show() +-------+-----+ |Country|Price| +-------+-----+ | Brazil| 1200| | Brazil| 7500| +-------+-----+","title":"Question 2"},{"location":"MSBD5003/homeworks/hw2/#question-3","text":"For each country, find the total Price. Hint: Use groupBy() df.groupBy('Country').sum('Price').withColumnRenamed('sum(Price)', \"Total Price\").show() +-------------+-----------+ | Country|Total Price| +-------------+-----------+ | Sweden| 8400| | Jersey| 1200| | Malaysia| 1200| | Turkey| 2400| | Germany| 22800| | France| 30300| | Belgium| 3600| | Finland| 1200| |United States| 350350| | India| 2400| | Kuwait| 1200| | Malta| 3600| | Italy| 2400| | Norway| 12000| | Spain| 2400| | Denmark| 8400| | Ireland| 29100| | Israel| 1200| | Iceland| 1200| | South Korea| 1200| +-------------+-----------+ only showing top 20 rows","title":"Question 3"},{"location":"MSBD5003/homeworks/hw2/#question-4","text":"List countries by their total Price in descending order. Hint: Use orderBy() df.groupBy('Country').sum('Price').withColumnRenamed('sum(Price)', \"Total Price\").orderBy('Total Price', ascending=False).show() +--------------------+-----------+ | Country|Total Price| +--------------------+-----------+ | United States| 350350| | United Kingdom| 63600| | Canada| 42000| | France| 30300| | Ireland| 29100| | Germany| 22800| | Australia| 22800| | Switzerland| 19200| | Netherlands| 14400| | Norway| 12000| | Brazil| 8700| | Denmark| 8400| | Sweden| 8400| | Austria| 3600| | South Africa| 3600| | Malta| 3600| | Belgium| 3600| |United Arab Emirates| 3600| | Turkey| 2400| | New Zealand| 2400| +--------------------+-----------+ only showing top 20 rows","title":"Question 4"},{"location":"MSBD5003/homeworks/hw2/#question-5","text":"Redo Question 3, but replace the country names by their IDs. Hint: Use join() df2 = spark.read.csv('/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/countries.csv', header=True, inferSchema=True) df2.show() +--------------+---+ | Country| ID| +--------------+---+ |United Kingdom| 1| | United States| 2| | Australia| 3| | Israel| 4| | France| 5| | Netherlands| 6| | Ireland| 7| | Canada| 8| | India| 9| | South Africa| 10| | Finland| 11| | Switzerland| 12| | Denmark| 13| | Belgium| 14| | Sweden| 15| | Norway| 16| | Luxembourg| 17| | Italy| 18| | Germany| 19| | Moldova| 20| +--------------+---+ only showing top 20 rows df.join(df2, 'Country').groupBy('ID').sum('Price').withColumnRenamed('sum(Price)', \"Total Price\").show() +---+-----------+ | ID|Total Price| +---+-----------+ | 31| 1200| | 34| 2400| | 28| 3600| | 26| 3600| | 27| 1200| | 12| 19200| | 22| 3600| | 1| 63600| | 13| 8400| | 6| 14400| | 16| 12000| | 3| 22800| | 20| 1200| | 5| 30300| | 19| 22800| | 15| 8400| | 9| 2400| | 17| 1200| | 4| 1200| | 8| 42000| +---+-----------+ only showing top 20 rows","title":"Question 5"},{"location":"MSBD5003/homeworks/hw2/#question-6","text":"Rewrite the PageRank example using DataFrame API. Here is a skeleton of the code. Your job is to fill in the missing part. The data files can be downloaded at: from pyspark.sql.functions import * numOfIterations = 10 lines = spark . read . text ( \"pagerank_data.txt\" ) # You can also test your program on the follow larger data set: # lines = spark.read.text(\"dblp.in\") a = lines . select ( split ( lines [ 0 ], ' ' )) links = a . select ( a [ 0 ][ 0 ] . alias ( 'src' ), a [ 0 ][ 1 ] . alias ( 'dst' )) outdegrees = links . groupBy ( 'src' ) . count () ranks = outdegrees . select ( 'src' , lit ( 1 ) . alias ( 'rank' )) for iteration in range ( numOfIterations ): # FILL IN THIS PART ranks . orderBy ( desc ( 'rank' )) . show () lines = spark.read.text(\"/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/pagerank_data.txt\") lines.show() +-----+ |value| +-----+ | 1 2| | 1 3| | 2 3| | 3 4| | 4 1| | 2 1| +-----+ from pyspark.sql.functions import * from pyspark.sql.types import FloatType from operator import add numOfIterations = 10 # You can also test your program on the follow larger data set: # lines = spark.read.text(\"dblp.in\") a = lines . select ( split ( lines [ 0 ], ' ' )) links = a . select ( a [ 0 ][ 0 ] . alias ( 'src' ), a [ 0 ][ 1 ] . alias ( 'dst' )) outdegrees = links . groupBy ( 'src' ) . count () ranks = outdegrees . select ( 'src' , lit ( 1 ) . alias ( 'rank' )) for iteration in range ( numOfIterations ): contribs = links . join ( ranks , 'src' ) . join ( outdegrees , 'src' ) . withColumnRenamed ( 'count' , 'outdegrees' ) contribs = contribs . select ( 'src' , 'dst' ,( contribs . rank / contribs . outdegrees ) . alias ( 'rank' )) . groupBy ( 'dst' ) . sum () . withColumnRenamed ( 'dst' , 'src' ) . withColumnRenamed ( 'sum(rank)' , 'rank' ) ranks = contribs . select ( 'src' , ( contribs . rank * 0.85 + 0.15 ) . alias ( 'rank' )) ranks . orderBy ( desc ( 'rank' )) . show () +---+------------------+ |src| rank| +---+------------------+ | 1|1.2981882732854677| | 4|0.9999999999999998| | 3|0.9999999999999998| | 2|0.7018117267145316| +---+------------------+","title":"Question 6"},{"location":"MSBD5003/homeworks/hw3/","text":"!pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 65kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 37.0MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=edc89a8f53022da82822d1b1bfb5ff85b57d72c5c4f9530d935fa927d268c34f Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.context import SparkContext from pyspark.sql.session import SparkSession sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) Question 1 \u00b6 Load it into spark and use divide-and-conquer to find the first (adj, noun) pair in which the noun is 'unification'. Print the corresponding adjective. The skeleton code is provided below. One solution is to use filter() to find all pairs where the noun is 'unification', and then report the first one. This is inefficient. The better idea is to find, in parallel, the first such pair in each partition (if one exists), and then find the first partition that returns such a pair. numPartitions = 10 lines = sc . textFile ( path_to_file , numPartitions ) pairs = lines . map ( lambda l : tuple ( l . split ())) . filter ( lambda p : len ( p ) == 2 ) pairs . cache () # FILL IN YOUR CODE HERE numPartitions = 10 def find_word ( iterator ): for adj , noun in iterator : if noun == \"unification\" : yield ( adj , noun ) break path_to_file = \"/content/drive/My Drive/courses/HKUST/MSBD5003/data/adj_noun_pairs.txt\" lines = sc . textFile ( path_to_file , numPartitions ) pairs = lines . map ( lambda l : tuple ( l . split ())). filter ( lambda p : len ( p ) == 2 ) pairs . cache () words = pairs . mapPartitions ( find_word ). collect () print ( words [ 0 ][ 0 ]) several Answer \u00b6 numPartitions = 10 def find_word ( iterator ): for adj , noun in iterator : if noun == \"unification\" : yield ( adj , noun ) break path_to_file = \"/content/drive/My Drive/courses/HKUST/MSBD5003/data/adj_noun_pairs.txt\" lines = sc . textFile ( path_to_file , numPartitions ) pairs = lines . map ( lambda l : tuple ( l . split ())) . filter ( lambda p : len ( p ) == 2 ) pairs . cache () words = pairs . mapPartitions ( find_word ) . collect () print ( words [ 0 ][ 0 ]) Question 2 \u00b6 Design a parallel divide-and-conquer algorithm for the following problem: Given two strings of equal length, compare them lexicographically. Output '<', '=', or '>', depending on the comparison result. The skeleton code is provided below. Your code should run on all partitions of the rdd in parallel. x = 'abcccbcbcacaccacaabb' y = 'abcccbcccacaccacaabb' numPartitions = 4 rdd = sc . parallelize ( zip ( x , y ), numPartitions ) # FILL IN YOUR CODE HERE ord(\"A\") 65 x = 'abcccbcbcacaccacaabb' y = 'abcccbcccacaccacaabb' def get_sum_by_partitions ( iterator ): sum_1 = 0 sum_2 = 0 for a , b in iterator : sum_1 += ord ( a ) sum_2 += ord ( b ) yield ( sum_1 , sum_2 ) numPartitions = 4 rdd = sc . parallelize ( zip ( x , y ), numPartitions ) sums = rdd . mapPartitions ( get_sum_by_partitions ). collect () sum_1 = 0 sum_2 = 0 for s_1 , s_2 in sums : sum_1 += s_1 sum_2 += s_2 if sum_1 < sum_2 : print ( \"<\" ) elif sum_1 == sum_2 : print ( \"=\" ) else : print ( \">\" ) > Answer \u00b6 x = 'abcccbcbcacaccacaabb' y = 'abcccbcccacaccacaabb' def get_sum_by_partitions ( iterator ): sum_1 = 0 sum_2 = 0 for a , b in iterator : sum_1 += ord ( a ) sum_2 += ord ( b ) yield ( sum_1 , sum_2 ) numPartitions = 4 rdd = sc . parallelize ( zip ( x , y ), numPartitions ) sums = rdd . mapPartitions ( get_sum_by_partitions ) . collect () sum_1 = 0 sum_2 = 0 for s_1 , s_2 in sums : sum_1 += s_1 sum_2 += s_2 if sum_1 < sum_2 : print ( \"<\" ) elif sum_1 == sum_2 : print ( \"=\" ) else : print ( \">\" )","title":"Hw3"},{"location":"MSBD5003/homeworks/hw3/#question-1","text":"Load it into spark and use divide-and-conquer to find the first (adj, noun) pair in which the noun is 'unification'. Print the corresponding adjective. The skeleton code is provided below. One solution is to use filter() to find all pairs where the noun is 'unification', and then report the first one. This is inefficient. The better idea is to find, in parallel, the first such pair in each partition (if one exists), and then find the first partition that returns such a pair. numPartitions = 10 lines = sc . textFile ( path_to_file , numPartitions ) pairs = lines . map ( lambda l : tuple ( l . split ())) . filter ( lambda p : len ( p ) == 2 ) pairs . cache () # FILL IN YOUR CODE HERE numPartitions = 10 def find_word ( iterator ): for adj , noun in iterator : if noun == \"unification\" : yield ( adj , noun ) break path_to_file = \"/content/drive/My Drive/courses/HKUST/MSBD5003/data/adj_noun_pairs.txt\" lines = sc . textFile ( path_to_file , numPartitions ) pairs = lines . map ( lambda l : tuple ( l . split ())). filter ( lambda p : len ( p ) == 2 ) pairs . cache () words = pairs . mapPartitions ( find_word ). collect () print ( words [ 0 ][ 0 ]) several","title":"Question 1"},{"location":"MSBD5003/homeworks/hw3/#answer","text":"numPartitions = 10 def find_word ( iterator ): for adj , noun in iterator : if noun == \"unification\" : yield ( adj , noun ) break path_to_file = \"/content/drive/My Drive/courses/HKUST/MSBD5003/data/adj_noun_pairs.txt\" lines = sc . textFile ( path_to_file , numPartitions ) pairs = lines . map ( lambda l : tuple ( l . split ())) . filter ( lambda p : len ( p ) == 2 ) pairs . cache () words = pairs . mapPartitions ( find_word ) . collect () print ( words [ 0 ][ 0 ])","title":"Answer"},{"location":"MSBD5003/homeworks/hw3/#question-2","text":"Design a parallel divide-and-conquer algorithm for the following problem: Given two strings of equal length, compare them lexicographically. Output '<', '=', or '>', depending on the comparison result. The skeleton code is provided below. Your code should run on all partitions of the rdd in parallel. x = 'abcccbcbcacaccacaabb' y = 'abcccbcccacaccacaabb' numPartitions = 4 rdd = sc . parallelize ( zip ( x , y ), numPartitions ) # FILL IN YOUR CODE HERE ord(\"A\") 65 x = 'abcccbcbcacaccacaabb' y = 'abcccbcccacaccacaabb' def get_sum_by_partitions ( iterator ): sum_1 = 0 sum_2 = 0 for a , b in iterator : sum_1 += ord ( a ) sum_2 += ord ( b ) yield ( sum_1 , sum_2 ) numPartitions = 4 rdd = sc . parallelize ( zip ( x , y ), numPartitions ) sums = rdd . mapPartitions ( get_sum_by_partitions ). collect () sum_1 = 0 sum_2 = 0 for s_1 , s_2 in sums : sum_1 += s_1 sum_2 += s_2 if sum_1 < sum_2 : print ( \"<\" ) elif sum_1 == sum_2 : print ( \"=\" ) else : print ( \">\" ) >","title":"Question 2"},{"location":"MSBD5003/homeworks/hw3/#answer_1","text":"x = 'abcccbcbcacaccacaabb' y = 'abcccbcccacaccacaabb' def get_sum_by_partitions ( iterator ): sum_1 = 0 sum_2 = 0 for a , b in iterator : sum_1 += ord ( a ) sum_2 += ord ( b ) yield ( sum_1 , sum_2 ) numPartitions = 4 rdd = sc . parallelize ( zip ( x , y ), numPartitions ) sums = rdd . mapPartitions ( get_sum_by_partitions ) . collect () sum_1 = 0 sum_2 = 0 for s_1 , s_2 in sums : sum_1 += s_1 sum_2 += s_2 if sum_1 < sum_2 : print ( \"<\" ) elif sum_1 == sum_2 : print ( \"=\" ) else : print ( \">\" )","title":"Answer"},{"location":"MSBD5003/notebooks%20in%20class/DC/","text":"! pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 63kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 47.6MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=bd505a7a219c64c9cf329fc493b951b33584b8631e2c6893141869ec65dcc4d0 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.context import SparkContext from pyspark.sql.session import SparkSession sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) Prefix Sums \u00b6 x = [ 1 , 4 , 3 , 5 , 6 , 7 , 0 , 1 ] rdd = sc . parallelize ( x , 4 ) . cache () def f ( iterator ): yield sum ( iterator ) sums = rdd . mapPartitions ( f ) . collect () print ( sums ) for i in range ( 1 , len ( sums )): sums [ i ] += sums [ i - 1 ] print ( sums ) def g ( index , iterator ): global sums if index == 0 : s = 0 else : s = sums [ index - 1 ] for i in iterator : s += i yield s prefix_sums = rdd . mapPartitionsWithIndex ( g ) print ( prefix_sums . collect ()) [5, 8, 13, 1] [5, 13, 26, 27] [1, 5, 8, 13, 19, 26, 26, 27] Monotocity checking \u00b6 x = [ 1 , 3 , 4 , 5 , 7 , 3 , 10 , 14 , 16 , 20 , 21 , 24 , 24 , 26 , 27 , 30 ] rdd = sc . parallelize ( x , 4 ) . cache () def f ( it ): first = next ( it ) last = first increasing = True for i in it : if i < last : increasing = False last = i yield increasing , first , last results = rdd . mapPartitions ( f ) . collect () print ( results ) increasing = True if results [ 0 ][ 0 ] == False : increasing = False else : for i in range ( 1 , len ( results )): if results [ i ][ 0 ] == False or results [ i ][ 1 ] < results [ i - 1 ][ 2 ]: increasing = False if increasing : print ( \"Monotone\" ) else : print ( \"Not monotone\" ) [(True, 1, 5), (False, 7, 14), (True, 16, 24), (True, 24, 30)] Not monotone Maximum Subarray Problem \u00b6 # Classical divide and conquer algorithm A = [ - 3 , 2 , 1 , - 4 , 5 , 2 , - 1 , 3 , - 1 ] def MaxSubarray ( A , p , r ): if p == r : return A [ p ] q = ( p + r ) // 2 M1 = MaxSubarray ( A , p , q ) M2 = MaxSubarray ( A , q + 1 , r ) Lm = - float ( 'inf' ) Rm = Lm V = 0 for i in range ( q , p - 1 , - 1 ): V += A [ i ] if V > Lm : Lm = V V = 0 for i in range ( q + 1 , r + 1 ): V += A [ i ] if V > Rm : Rm = V return max ( M1 , M2 , Lm + Rm ) print ( MaxSubarray ( A , 0 , len ( A ) - 1 )) 9 # Linear-time algorithm # Written in a way so that we can call it for each partition def linear_time ( it ): Vmax = - float ( 'inf' ) V = 0 for Ai in it : V += Ai if V > Vmax : Vmax = V if V < 0 : V = 0 yield Vmax print ( next ( linear_time ( A ))) 9 # The Spark algorithm: def compute_sum ( it ): yield sum ( it ) def compute_LmRm ( index , it ): Lm = - float ( 'inf' ) Rm = - float ( 'inf' ) L = sums [ index ] R = 0 for Ai in it : L -= Ai R += Ai if L > Lm : Lm = L if R > Rm : Rm = R yield ( Lm , Rm ) num_partitions = 4 rdd = sc . parallelize ( A , num_partitions ) . cache () sums = rdd . mapPartitions ( compute_sum ) . collect () print ( sums ) LmRms = rdd . mapPartitionsWithIndex ( compute_LmRm ) . collect () print ( LmRms ) best = max ( rdd . mapPartitions ( linear_time ) . collect ()) for i in range ( num_partitions - 1 ): for j in range ( i + 1 , num_partitions ): x = LmRms [ i ][ 0 ] + sum ( sums [ i + 1 : j ]) + LmRms [ j ][ 1 ] if x > best : best = x print ( best ) [-1, -3, 7, 1] [(2, -1), (0, 1), (2, 7), (2, 2)] 9","title":"Dc"},{"location":"MSBD5003/notebooks%20in%20class/DC/#prefix-sums","text":"x = [ 1 , 4 , 3 , 5 , 6 , 7 , 0 , 1 ] rdd = sc . parallelize ( x , 4 ) . cache () def f ( iterator ): yield sum ( iterator ) sums = rdd . mapPartitions ( f ) . collect () print ( sums ) for i in range ( 1 , len ( sums )): sums [ i ] += sums [ i - 1 ] print ( sums ) def g ( index , iterator ): global sums if index == 0 : s = 0 else : s = sums [ index - 1 ] for i in iterator : s += i yield s prefix_sums = rdd . mapPartitionsWithIndex ( g ) print ( prefix_sums . collect ()) [5, 8, 13, 1] [5, 13, 26, 27] [1, 5, 8, 13, 19, 26, 26, 27]","title":"Prefix Sums"},{"location":"MSBD5003/notebooks%20in%20class/DC/#monotocity-checking","text":"x = [ 1 , 3 , 4 , 5 , 7 , 3 , 10 , 14 , 16 , 20 , 21 , 24 , 24 , 26 , 27 , 30 ] rdd = sc . parallelize ( x , 4 ) . cache () def f ( it ): first = next ( it ) last = first increasing = True for i in it : if i < last : increasing = False last = i yield increasing , first , last results = rdd . mapPartitions ( f ) . collect () print ( results ) increasing = True if results [ 0 ][ 0 ] == False : increasing = False else : for i in range ( 1 , len ( results )): if results [ i ][ 0 ] == False or results [ i ][ 1 ] < results [ i - 1 ][ 2 ]: increasing = False if increasing : print ( \"Monotone\" ) else : print ( \"Not monotone\" ) [(True, 1, 5), (False, 7, 14), (True, 16, 24), (True, 24, 30)] Not monotone","title":"Monotocity checking"},{"location":"MSBD5003/notebooks%20in%20class/DC/#maximum-subarray-problem","text":"# Classical divide and conquer algorithm A = [ - 3 , 2 , 1 , - 4 , 5 , 2 , - 1 , 3 , - 1 ] def MaxSubarray ( A , p , r ): if p == r : return A [ p ] q = ( p + r ) // 2 M1 = MaxSubarray ( A , p , q ) M2 = MaxSubarray ( A , q + 1 , r ) Lm = - float ( 'inf' ) Rm = Lm V = 0 for i in range ( q , p - 1 , - 1 ): V += A [ i ] if V > Lm : Lm = V V = 0 for i in range ( q + 1 , r + 1 ): V += A [ i ] if V > Rm : Rm = V return max ( M1 , M2 , Lm + Rm ) print ( MaxSubarray ( A , 0 , len ( A ) - 1 )) 9 # Linear-time algorithm # Written in a way so that we can call it for each partition def linear_time ( it ): Vmax = - float ( 'inf' ) V = 0 for Ai in it : V += Ai if V > Vmax : Vmax = V if V < 0 : V = 0 yield Vmax print ( next ( linear_time ( A ))) 9 # The Spark algorithm: def compute_sum ( it ): yield sum ( it ) def compute_LmRm ( index , it ): Lm = - float ( 'inf' ) Rm = - float ( 'inf' ) L = sums [ index ] R = 0 for Ai in it : L -= Ai R += Ai if L > Lm : Lm = L if R > Rm : Rm = R yield ( Lm , Rm ) num_partitions = 4 rdd = sc . parallelize ( A , num_partitions ) . cache () sums = rdd . mapPartitions ( compute_sum ) . collect () print ( sums ) LmRms = rdd . mapPartitionsWithIndex ( compute_LmRm ) . collect () print ( LmRms ) best = max ( rdd . mapPartitions ( linear_time ) . collect ()) for i in range ( num_partitions - 1 ): for j in range ( i + 1 , num_partitions ): x = LmRms [ i ][ 0 ] + sum ( sums [ i + 1 : j ]) + LmRms [ j ][ 1 ] if x > best : best = x print ( best ) [-1, -3, 7, 1] [(2, -1), (0, 1), (2, 7), (2, 2)] 9","title":"Maximum Subarray Problem"},{"location":"MSBD5003/notebooks%20in%20class/PMI/","text":"PMI \u00b6 PMI (pointwise mutual information) is a measure of association used in information theory and statistics. Given a list of pairs (x, y) \\[pmi(x, y) = log\\frac{p(x,y)}{p(x)p(y}\\] where - \\(p(x)\\) : probability of x - \\(p(y)\\) : probability of y - \\(p(x,y)\\) : joint probability Example: p(x=0) = 0.8, p(x=1)=0.2, p(y=0)=0.25, p(y=1)=0.75 pmi(x=0;y=0) = \u22121 pmi(x=0;y=1) = 0.222392 pmi(x=1;y=0) = 1.584963 pmi(x=1;y=1) = -1.584963 Example notebook see: note book in class/PMI ! pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 70kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 44.6MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=ae3121fc30af19c4ec22b0beb2c7452d103f59dc5ad06c6fa21a5b108cdbf54a Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 import requests from pyspark.context import SparkContext r = requests . get ( 'https://www.cse.ust.hk/msbd5003/data/adj_noun_pairs.txt' ) open ( 'adj_noun_pairs.txt' , 'wb' ) . write ( r . content ) sc = SparkContext . getOrCreate () # Data file at https://www.cse.ust.hk/msbd5003/data lines = sc . textFile ( 'adj_noun_pairs.txt' ) lines . count () 3162692 lines . getNumPartitions () 2 lines . take ( 5 ) ['early radical', 'french revolution', 'pejorative way', 'violent means', 'positive label'] # Converting lines into word pairs. # Data is dirty: some lines have more than 2 words, so filter them out. pairs = lines . map ( lambda l : tuple ( l . split ())) . filter ( lambda p : len ( p ) == 2 ) pairs . cache () PythonRDD[4] at RDD at PythonRDD.scala:53 pairs . take ( 5 ) [('early', 'radical'), ('french', 'revolution'), ('pejorative', 'way'), ('violent', 'means'), ('positive', 'label')] N = pairs . count () N 3162674 # Compute the frequency of each pair. # Ignore pairs that not frequent enough pair_freqs = pairs . map ( lambda p : ( p , 1 )) . reduceByKey ( lambda f1 , f2 : f1 + f2 ) \\ . filter ( lambda pf : pf [ 1 ] >= 100 ) pair_freqs . take ( 5 ) [(('political', 'philosophy'), 160), (('human', 'society'), 154), (('16th', 'century'), 950), (('first', 'man'), 166), (('same', 'time'), 2744)] # Computing the frequencies of the adjectives and the nouns a_freqs = pairs . map ( lambda p : ( p [ 0 ], 1 )) . reduceByKey ( lambda x , y : x + y ) n_freqs = pairs . map ( lambda p : ( p [ 1 ], 1 )) . reduceByKey ( lambda x , y : x + y ) a_freqs . take ( 5 ) [('violent', 1191), ('positive', 2302), ('self-defined', 3), ('political', 15935), ('differ', 381)] n_freqs . count () 106333 # Broadcasting the adjective and noun frequencies. #a_dict = a_freqs.collectAsMap() #a_dict = sc.parallelize(a_dict).map(lambda x: x) n_dict = sc . broadcast ( n_freqs . collectAsMap ()) a_dict = sc . broadcast ( a_freqs . collectAsMap ()) a_dict . value [ 'violent' ] 1191 from math import * # Computing the PMI for a pair. def pmi_score ( pair_freq ): w1 , w2 = pair_freq [ 0 ] f = pair_freq [ 1 ] pmi = log ( float ( f ) * N / ( a_dict . value [ w1 ] * n_dict . value [ w2 ]), 2 ) return pmi , ( w1 , w2 ) # Computing the PMI for all pairs. scored_pairs = pair_freqs . map ( pmi_score ) # Printing the most strongly associated pairs. scored_pairs . top ( 10 ) [(14.41018838546462, ('magna', 'carta')), (13.071365888694997, ('polish-lithuanian', 'Commonwealth')), (12.990597616733414, ('nitrous', 'oxide')), (12.64972604311254, ('latter-day', 'Saints')), (12.50658937509916, ('stainless', 'steel')), (12.482331020687814, ('pave', 'runway')), (12.19140721768055, ('corporal', 'punishment')), (12.183248694293388, ('capital', 'punishment')), (12.147015483562537, ('rush', 'yard')), (12.109945794428935, ('globular', 'cluster'))] Another way n_dict = n_freqs . collectAsMap () a_dict = a_freqs . collectAsMap () from math import * # Computing the PMI for a pair. def pmi_score ( pair_freq ): w1 , w2 = pair_freq [ 0 ] f = pair_freq [ 1 ] pmi = log ( float ( f ) * N / ( a_dict [ w1 ] * n_dict [ w2 ]), 2 ) return pmi , ( w1 , w2 ) scored_pairs = pair_freqs . map ( pmi_score ) scored_pairs . top ( 10 ) [(14.41018838546462, ('magna', 'carta')), (13.071365888694997, ('polish-lithuanian', 'Commonwealth')), (12.990597616733414, ('nitrous', 'oxide')), (12.64972604311254, ('latter-day', 'Saints')), (12.50658937509916, ('stainless', 'steel')), (12.482331020687814, ('pave', 'runway')), (12.19140721768055, ('corporal', 'punishment')), (12.183248694293388, ('capital', 'punishment')), (12.147015483562537, ('rush', 'yard')), (12.109945794428935, ('globular', 'cluster'))]","title":"Pmi"},{"location":"MSBD5003/notebooks%20in%20class/PMI/#pmi","text":"PMI (pointwise mutual information) is a measure of association used in information theory and statistics. Given a list of pairs (x, y) \\[pmi(x, y) = log\\frac{p(x,y)}{p(x)p(y}\\] where - \\(p(x)\\) : probability of x - \\(p(y)\\) : probability of y - \\(p(x,y)\\) : joint probability Example: p(x=0) = 0.8, p(x=1)=0.2, p(y=0)=0.25, p(y=1)=0.75 pmi(x=0;y=0) = \u22121 pmi(x=0;y=1) = 0.222392 pmi(x=1;y=0) = 1.584963 pmi(x=1;y=1) = -1.584963 Example notebook see: note book in class/PMI ! pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 70kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 44.6MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=ae3121fc30af19c4ec22b0beb2c7452d103f59dc5ad06c6fa21a5b108cdbf54a Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 import requests from pyspark.context import SparkContext r = requests . get ( 'https://www.cse.ust.hk/msbd5003/data/adj_noun_pairs.txt' ) open ( 'adj_noun_pairs.txt' , 'wb' ) . write ( r . content ) sc = SparkContext . getOrCreate () # Data file at https://www.cse.ust.hk/msbd5003/data lines = sc . textFile ( 'adj_noun_pairs.txt' ) lines . count () 3162692 lines . getNumPartitions () 2 lines . take ( 5 ) ['early radical', 'french revolution', 'pejorative way', 'violent means', 'positive label'] # Converting lines into word pairs. # Data is dirty: some lines have more than 2 words, so filter them out. pairs = lines . map ( lambda l : tuple ( l . split ())) . filter ( lambda p : len ( p ) == 2 ) pairs . cache () PythonRDD[4] at RDD at PythonRDD.scala:53 pairs . take ( 5 ) [('early', 'radical'), ('french', 'revolution'), ('pejorative', 'way'), ('violent', 'means'), ('positive', 'label')] N = pairs . count () N 3162674 # Compute the frequency of each pair. # Ignore pairs that not frequent enough pair_freqs = pairs . map ( lambda p : ( p , 1 )) . reduceByKey ( lambda f1 , f2 : f1 + f2 ) \\ . filter ( lambda pf : pf [ 1 ] >= 100 ) pair_freqs . take ( 5 ) [(('political', 'philosophy'), 160), (('human', 'society'), 154), (('16th', 'century'), 950), (('first', 'man'), 166), (('same', 'time'), 2744)] # Computing the frequencies of the adjectives and the nouns a_freqs = pairs . map ( lambda p : ( p [ 0 ], 1 )) . reduceByKey ( lambda x , y : x + y ) n_freqs = pairs . map ( lambda p : ( p [ 1 ], 1 )) . reduceByKey ( lambda x , y : x + y ) a_freqs . take ( 5 ) [('violent', 1191), ('positive', 2302), ('self-defined', 3), ('political', 15935), ('differ', 381)] n_freqs . count () 106333 # Broadcasting the adjective and noun frequencies. #a_dict = a_freqs.collectAsMap() #a_dict = sc.parallelize(a_dict).map(lambda x: x) n_dict = sc . broadcast ( n_freqs . collectAsMap ()) a_dict = sc . broadcast ( a_freqs . collectAsMap ()) a_dict . value [ 'violent' ] 1191 from math import * # Computing the PMI for a pair. def pmi_score ( pair_freq ): w1 , w2 = pair_freq [ 0 ] f = pair_freq [ 1 ] pmi = log ( float ( f ) * N / ( a_dict . value [ w1 ] * n_dict . value [ w2 ]), 2 ) return pmi , ( w1 , w2 ) # Computing the PMI for all pairs. scored_pairs = pair_freqs . map ( pmi_score ) # Printing the most strongly associated pairs. scored_pairs . top ( 10 ) [(14.41018838546462, ('magna', 'carta')), (13.071365888694997, ('polish-lithuanian', 'Commonwealth')), (12.990597616733414, ('nitrous', 'oxide')), (12.64972604311254, ('latter-day', 'Saints')), (12.50658937509916, ('stainless', 'steel')), (12.482331020687814, ('pave', 'runway')), (12.19140721768055, ('corporal', 'punishment')), (12.183248694293388, ('capital', 'punishment')), (12.147015483562537, ('rush', 'yard')), (12.109945794428935, ('globular', 'cluster'))] Another way n_dict = n_freqs . collectAsMap () a_dict = a_freqs . collectAsMap () from math import * # Computing the PMI for a pair. def pmi_score ( pair_freq ): w1 , w2 = pair_freq [ 0 ] f = pair_freq [ 1 ] pmi = log ( float ( f ) * N / ( a_dict [ w1 ] * n_dict [ w2 ]), 2 ) return pmi , ( w1 , w2 ) scored_pairs = pair_freqs . map ( pmi_score ) scored_pairs . top ( 10 ) [(14.41018838546462, ('magna', 'carta')), (13.071365888694997, ('polish-lithuanian', 'Commonwealth')), (12.990597616733414, ('nitrous', 'oxide')), (12.64972604311254, ('latter-day', 'Saints')), (12.50658937509916, ('stainless', 'steel')), (12.482331020687814, ('pave', 'runway')), (12.19140721768055, ('corporal', 'punishment')), (12.183248694293388, ('capital', 'punishment')), (12.147015483562537, ('rush', 'yard')), (12.109945794428935, ('globular', 'cluster'))]","title":"PMI"},{"location":"MSBD5003/notebooks%20in%20class/graph/","text":"! pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 38kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 51.8MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=d4a7bf9d9286fd24237188aa6c7e6fce433cbe8062ab1b5448e6c06d960012fe Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 ! pip install graphframes Collecting graphframes Downloading https://files.pythonhosted.org/packages/0b/27/c7c7e1ced2fe9a905f865dd91faaec2ac8a8e313f511678c8ec92a41a153/graphframes-0.6-py2.py3-none-any.whl Requirement already satisfied: numpy in /usr/local/lib/python3.6/dist-packages (from graphframes) (1.18.5) Collecting nose \u001b[?25l Downloading https://files.pythonhosted.org/packages/15/d8/dd071918c040f50fa1cf80da16423af51ff8ce4a0f2399b7bf8de45ac3d9/nose-1.3.7-py3-none-any.whl (154kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 15.3MB/s \u001b[?25hInstalling collected packages: nose, graphframes Successfully installed graphframes-0.6 nose-1.3.7 ! wget https : // dl . bintray . com / spark - packages / maven / graphframes / graphframes / 0.8 . 0 - spark3 . 0 - s_2 . 12 / graphframes - 0.8 . 0 - spark3 . 0 - s_2 . 12. jar --2020-12-02 15:45:29-- https://dl.bintray.com/spark-packages/maven/graphframes/graphframes/0.8.0-spark3.0-s_2.12/graphframes-0.8.0-spark3.0-s_2.12.jar Resolving dl.bintray.com (dl.bintray.com)... 3.122.43.129, 35.157.127.85 Connecting to dl.bintray.com (dl.bintray.com)|3.122.43.129|:443... connected. HTTP request sent, awaiting response... 302 Location: https://d29vzk4ow07wi7.cloudfront.net/b62d4bb1c4fdd74c9ce5aa4adee520a7a4375c2de73487381644e5220c67c1dd?response-content-disposition=attachment%3Bfilename%3D%22graphframes-0.8.0-spark3.0-s_2.12.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvYjYyZDRiYjFjNGZkZDc0YzljZTVhYTRhZGVlNTIwYTdhNDM3NWMyZGU3MzQ4NzM4MTY0NGU1MjIwYzY3YzFkZD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmdyYXBoZnJhbWVzLTAuOC4wLXNwYXJrMy4wLXNfMi4xMi5qYXIlMjIiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MDY5MjQ2NDl9LCJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMC4wLjAuMC8wIn19fV19&Signature=dJQvqo-UV~oRF0t93Qw-YSGpDE1pvQCuS0t~kNdiC2cDsUoJ5CdWB-RinPlpEX5TY8-oIQBnpefd7ljNKnJ5t7L1ae4ZcIQLfqBdvJdMK7AcKzytxy3cc17j7Zc80hbTMYVkhThFSJS0Loz6fvPyedCqfjI8G66Mrp46VgSpTBCqHxF0bKusZuM4w82M9d-iLmYELnyDNPHTbLIAjlMh24CcxETAKmI~AN-pZPjaGz6YMc9rFuyROe8FE4p2B5jbmjzo5LB0AHNdJll~GXtqGFKPsdJavvoCVDqbAdyJxL3XtGZdMLwbSHO6WMhbJRetQc5mEgqSLPsrNXrCvD2Q-g__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA [following] --2020-12-02 15:45:29-- https://d29vzk4ow07wi7.cloudfront.net/b62d4bb1c4fdd74c9ce5aa4adee520a7a4375c2de73487381644e5220c67c1dd?response-content-disposition=attachment%3Bfilename%3D%22graphframes-0.8.0-spark3.0-s_2.12.jar%22&Policy=eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvYjYyZDRiYjFjNGZkZDc0YzljZTVhYTRhZGVlNTIwYTdhNDM3NWMyZGU3MzQ4NzM4MTY0NGU1MjIwYzY3YzFkZD9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmdyYXBoZnJhbWVzLTAuOC4wLXNwYXJrMy4wLXNfMi4xMi5qYXIlMjIiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjE2MDY5MjQ2NDl9LCJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMC4wLjAuMC8wIn19fV19&Signature=dJQvqo-UV~oRF0t93Qw-YSGpDE1pvQCuS0t~kNdiC2cDsUoJ5CdWB-RinPlpEX5TY8-oIQBnpefd7ljNKnJ5t7L1ae4ZcIQLfqBdvJdMK7AcKzytxy3cc17j7Zc80hbTMYVkhThFSJS0Loz6fvPyedCqfjI8G66Mrp46VgSpTBCqHxF0bKusZuM4w82M9d-iLmYELnyDNPHTbLIAjlMh24CcxETAKmI~AN-pZPjaGz6YMc9rFuyROe8FE4p2B5jbmjzo5LB0AHNdJll~GXtqGFKPsdJavvoCVDqbAdyJxL3XtGZdMLwbSHO6WMhbJRetQc5mEgqSLPsrNXrCvD2Q-g__&Key-Pair-Id=APKAIFKFWOMXM2UMTSFA Resolving d29vzk4ow07wi7.cloudfront.net (d29vzk4ow07wi7.cloudfront.net)... 54.240.168.145, 54.240.168.82, 54.240.168.77, ... Connecting to d29vzk4ow07wi7.cloudfront.net (d29vzk4ow07wi7.cloudfront.net)|54.240.168.145|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 243265 (238K) [multipart/form-data] Saving to: \u2018graphframes-0.8.0-spark3.0-s_2.12.jar\u2019 graphframes-0.8.0-s 100%[===================>] 237.56K 563KB/s in 0.4s 2020-12-02 15:45:31 (563 KB/s) - \u2018graphframes-0.8.0-spark3.0-s_2.12.jar\u2019 saved [243265/243265] os . environ [ 'PYSPARK_SUBMIT_ARGS' ] = '--packages graphframes:graphframes:0.8.1-spark3.0-s_2.12 pyspark-shell' --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-15-4d1ba1edf8bb> in <module>() ----> 1 os.environ['PYSPARK_SUBMIT_ARGS'] = '--packages graphframes:graphframes:0.8.1-spark3.0-s_2.12 pyspark-shell' NameError: name 'os' is not defined from pyspark.context import SparkContext from pyspark.sql.session import SparkSession from pyspark.sql.types import Row sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) from graphframes import * sc . addPyFile ( \"https://dl.bintray.com/spark-packages/maven/graphframes/graphframes/0.8.0-spark3.0-s_2.12/graphframes-0.8.0-spark3.0-s_2.12.jar\" ) # Vertics DataFrame v = spark . createDataFrame ([ ( \"a\" , \"Alice\" , 34 ), ( \"b\" , \"Bob\" , 36 ), ( \"c\" , \"Charlie\" , 37 ), ( \"d\" , \"David\" , 29 ), ( \"e\" , \"Esther\" , 32 ), ( \"f\" , \"Fanny\" , 38 ), ( \"g\" , \"Gabby\" , 60 ) ], [ \"id\" , \"name\" , \"age\" ]) # Edges DataFrame e = spark . createDataFrame ([ ( \"a\" , \"b\" , \"friend\" ), ( \"b\" , \"c\" , \"follow\" ), ( \"c\" , \"b\" , \"follow\" ), ( \"f\" , \"c\" , \"follow\" ), ( \"e\" , \"f\" , \"follow\" ), ( \"e\" , \"d\" , \"friend\" ), ( \"d\" , \"a\" , \"friend\" ), ( \"a\" , \"e\" , \"friend\" ), ( \"g\" , \"e\" , \"follow\" ) ], [ \"src\" , \"dst\" , \"relationship\" ]) # Create a GraphFrame g = GraphFrame ( v , e ) g . vertices . show () g . edges . show () --------------------------------------------------------------------------- Py4JJavaError Traceback (most recent call last) <ipython-input-14-eccf3cb921e3> in <module>() 24 25 # Create a GraphFrame ---> 26 g = GraphFrame(v, e) 27 28 g.vertices.show() /usr/local/lib/python3.6/dist-packages/graphframes/graphframe.py in __init__(self, v, e) 63 self._sqlContext = v.sql_ctx 64 self._sc = self._sqlContext._sc ---> 65 self._jvm_gf_api = _java_api(self._sc) 66 67 self.ID = self._jvm_gf_api.ID() /usr/local/lib/python3.6/dist-packages/graphframes/graphframe.py in _java_api(jsc) 36 def _java_api(jsc): 37 javaClassName = \"org.graphframes.GraphFramePythonAPI\" ---> 38 return jsc._jvm.Thread.currentThread().getContextClassLoader().loadClass(javaClassName) \\ 39 .newInstance() 40 /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in __call__(self, *args) 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( -> 1305 answer, self.gateway_client, self.target_id, self.name) 1306 1307 for temp_arg in temp_args: /usr/local/lib/python3.6/dist-packages/pyspark/sql/utils.py in deco(*a, **kw) 126 def deco(*a, **kw): 127 try: --> 128 return f(*a, **kw) 129 except py4j.protocol.Py4JJavaError as e: 130 converted = convert_exception(e.java_exception) /usr/local/lib/python3.6/dist-packages/py4j/protocol.py in get_return_value(answer, gateway_client, target_id, name) 326 raise Py4JJavaError( 327 \"An error occurred while calling {0}{1}{2}.\\n\". --> 328 format(target_id, \".\", name), value) 329 else: 330 raise Py4JError( Py4JJavaError: An error occurred while calling o148.loadClass. : java.lang.ClassNotFoundException: org.graphframes.GraphFramePythonAPI at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:471) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:589) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at py4j.reflection.MethodInvoker.invoke(MethodInvoker.java:244) at py4j.reflection.ReflectionEngine.invoke(ReflectionEngine.java:357) at py4j.Gateway.invoke(Gateway.java:282) at py4j.commands.AbstractCommand.invokeMethod(AbstractCommand.java:132) at py4j.commands.CallCommand.execute(CallCommand.java:79) at py4j.GatewayConnection.run(GatewayConnection.java:238) at java.base/java.lang.Thread.run(Thread.java:834) 3 # g.vertices and g.edges are just DataFrames # You can use any DataFrame API on them g . edges . filter ( \"src = 'a'\" ) . show () +---+---+------------+ |src|dst|relationship| +---+---+------------+ | a| b| friend| | a| e| friend| +---+---+------------+ g . edges . filter ( \"src = 'a'\" ) . count () 2 # Count the number of followers of c. # This queries the edge DataFrame. print ( g . edges . filter ( \"relationship = 'follow' and dst = 'c'\" ) . count ()) 2 # A GraphFrame has additional attributes g . outDegrees . show () +---+---------+ | id|outDegree| +---+---------+ | g| 1| | f| 1| | e| 2| | d| 1| | c| 1| | b| 1| | a| 2| +---+---------+ g . inDegrees . show () +---+--------+ | id|inDegree| +---+--------+ | f| 1| | e| 2| | d| 1| | c| 2| | b| 2| | a| 1| +---+--------+ g . inDegrees . explain () == Physical Plan == *(2) HashAggregate(keys=[dst#45], functions=[count(1)]) +- Exchange hashpartitioning(dst#45, 200), true, [id=#171] +- *(1) HashAggregate(keys=[dst#45], functions=[partial_count(1)]) +- *(1) Project [dst#45] +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] myInDegrees = g . edges . groupBy ( 'dst' ) . count () \\ . withColumnRenamed ( 'dst' , 'id' ) . withColumnRenamed ( 'count' , 'inDegree' ) myInDegrees . show () +---+--------+ | id|inDegree| +---+--------+ | f| 1| | e| 2| | d| 1| | c| 2| | b| 2| | a| 1| +---+--------+ myInDegrees . explain () == Physical Plan == *(2) HashAggregate(keys=[dst#45], functions=[count(1)]) +- Exchange hashpartitioning(dst#45, 200), true, [id=#218] +- *(1) HashAggregate(keys=[dst#45], functions=[partial_count(1)]) +- *(1) Project [dst#45] +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] print ( g . inDegrees . storageLevel ) Serialized 1x Replicated g . inDegrees . cache () DataFrame[id: string, inDegree: int] print ( g . inDegrees . storageLevel ) Disk Memory Deserialized 1x Replicated print ( g . vertices . storageLevel ) Serialized 1x Replicated g . cache () GraphFrame(v:[id: string, name: string ... 1 more field], e:[src: string, dst: string ... 1 more field]) print ( g . vertices . storageLevel ) print ( g . edges . storageLevel ) Disk Memory Deserialized 1x Replicated Disk Memory Deserialized 1x Replicated # A triplet view of the graph g . triplets . show () +----------------+--------------+----------------+ | src| edge| dst| +----------------+--------------+----------------+ | [e, Esther, 32]|[e, f, follow]| [f, Fanny, 38]| | [g, Gabby, 60]|[g, e, follow]| [e, Esther, 32]| | [a, Alice, 34]|[a, e, friend]| [e, Esther, 32]| | [e, Esther, 32]|[e, d, friend]| [d, David, 29]| | [f, Fanny, 38]|[f, c, follow]|[c, Charlie, 37]| | [b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| |[c, Charlie, 37]|[c, b, follow]| [b, Bob, 36]| | [a, Alice, 34]|[a, b, friend]| [b, Bob, 36]| | [d, David, 29]|[d, a, friend]| [a, Alice, 34]| +----------------+--------------+----------------+ g . triplets . explain () == Physical Plan == *(9) Project [src#217, edge#215, dst#219] +- *(9) SortMergeJoin [edge#215.dst], [dst#219.id], Inner :- *(6) Sort [edge#215.dst ASC NULLS FIRST], false, 0 : +- Exchange hashpartitioning(edge#215.dst, 200), true, [id=#312] : +- *(5) SortMergeJoin [edge#215.src], [src#217.id], Inner : :- *(2) Sort [edge#215.src ASC NULLS FIRST], false, 0 : : +- Exchange hashpartitioning(edge#215.src, 200), true, [id=#297] : : +- *(1) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS edge#215] : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : +- *(4) Sort [src#217.id ASC NULLS FIRST], false, 0 : +- Exchange hashpartitioning(src#217.id, 200), true, [id=#305] : +- *(3) Project [struct(id, id#38, name, name#39, age, age#40L) AS src#217] : +- InMemoryTableScan [age#40L, id#38, name#39] : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] +- *(8) Sort [dst#219.id ASC NULLS FIRST], false, 0 +- Exchange hashpartitioning(dst#219.id, 200), true, [id=#320] +- *(7) Project [struct(id, id#38, name, name#39, age, age#40L) AS dst#219] +- InMemoryTableScan [age#40L, id#38, name#39] +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] Motif Finding \u00b6 # Search for pairs of vertices with edges in both directions between them. motifs = g . find ( \"(a)-[]->(b); (b)-[]->(a)\" ) . filter ( 'a.id < b.id' ) motifs . show () +------------+----------------+ | a| b| +------------+----------------+ |[b, Bob, 36]|[c, Charlie, 37]| +------------+----------------+ # Find triangles triangles = g . find ( \"(a)-[]->(b); (b)-[]->(c); (c)-[]->(a)\" ) triangles = triangles . filter ( \"a.id < b.id AND a.id < c.id\" ) triangles . show () +--------------+---------------+--------------+ | a| b| c| +--------------+---------------+--------------+ |[a, Alice, 34]|[e, Esther, 32]|[d, David, 29]| +--------------+---------------+--------------+ triangles . explain () == Physical Plan == *(6) Project [a#630, b#632, c#657] +- *(6) BroadcastHashJoin [c#657.id, a#630.id], [__tmp-6526019406657860729#687.src, __tmp-6526019406657860729#687.dst], Inner, BuildRight :- *(6) Project [a#630, b#632, c#657] : +- *(6) BroadcastHashJoin [__tmp-430217833014886237#655.dst], [c#657.id], Inner, BuildRight, (a#630.id < c#657.id) : :- *(6) BroadcastHashJoin [b#632.id], [__tmp-430217833014886237#655.src], Inner, BuildRight : : :- *(6) Project [a#630, b#632] : : : +- *(6) BroadcastHashJoin [__tmp-1043886091038848698#628.dst], [b#632.id], Inner, BuildRight, (a#630.id < b#632.id) : : : :- *(6) BroadcastHashJoin [__tmp-1043886091038848698#628.src], [a#630.id], Inner, BuildRight : : : : :- *(6) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-1043886091038848698#628] : : : : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : : : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : : : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : : : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#628] : : : : +- *(1) Project [struct(id, id#38, name, name#39, age, age#40L) AS a#630] : : : : +- InMemoryTableScan [age#40L, id#38, name#39] : : : : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : : : : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] : : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#634] : : : +- *(2) Project [struct(id, id#38, name, name#39, age, age#40L) AS b#632] : : : +- InMemoryTableScan [age#40L, id#38, name#39] : : : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : : : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<src:string,dst:string,relationship:string>, false].src)), [id=#641] : : +- *(3) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-430217833014886237#655] : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#647] : +- *(4) Project [struct(id, id#38, name, name#39, age, age#40L) AS c#657] : +- InMemoryTableScan [age#40L, id#38, name#39] : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<src:string,dst:string,relationship:string>, false].src, input[0, struct<src:string,dst:string,relationship:string>, false].dst)), [id=#654] +- *(5) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-6526019406657860729#687] +- InMemoryTableScan [dst#45, relationship#46, src#44] +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] # Negation oneway = g . find ( \"(a)-[]->(b); !(b)-[]->(a)\" ) oneway . show () +---------------+----------------+ | a| b| +---------------+----------------+ | [a, Alice, 34]| [e, Esther, 32]| |[e, Esther, 32]| [d, David, 29]| | [a, Alice, 34]| [b, Bob, 36]| | [g, Gabby, 60]| [e, Esther, 32]| |[e, Esther, 32]| [f, Fanny, 38]| | [f, Fanny, 38]|[c, Charlie, 37]| | [d, David, 29]| [a, Alice, 34]| +---------------+----------------+ # Find vertices without incoming edges: g . find ( \"!()-[]->(a)\" ) . show () +--------------+ | a| +--------------+ |[g, Gabby, 60]| +--------------+ # More meaningful queries can be expressed by applying filters. # Question: where is this filter applied? g . find ( \"(a)-[e]->(b); (b)-[]->(a)\" ) . filter ( \"b.age > 36\" ) . show () +------------+--------------+----------------+ | a| e| b| +------------+--------------+----------------+ |[b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| +------------+--------------+----------------+ +------------+ |relationship| +------------+ | follow| +------------+ g . find ( \"(a)-[]->(b); (b)-[]->(a)\" ) . filter ( \"b.age > 36\" ) . explain () == Physical Plan == *(4) Project [a#2584, b#2586] +- *(4) BroadcastHashJoin [b#2586.id, a#2584.id], [__tmp2506060614762666678#2609.src, __tmp2506060614762666678#2609.dst], Inner, BuildRight :- *(4) Project [a#2584, b#2586] : +- *(4) BroadcastHashJoin [__tmp-3851898762290097694#2582.dst], [b#2586.id], Inner, BuildRight : :- *(4) BroadcastHashJoin [__tmp-3851898762290097694#2582.src], [a#2584.id], Inner, BuildRight : : :- *(4) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-3851898762290097694#2582] : : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#1356] : : +- *(1) Project [struct(id, id#38, name, name#39, age, age#40L) AS a#2584] : : +- InMemoryTableScan [age#40L, id#38, name#39] : : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#1363] : +- *(2) Project [struct(id, id#38, name, name#39, age, age#40L) AS b#2586] : +- *(2) Filter (isnotnull(age#40L) AND (age#40L > 36)) : +- InMemoryTableScan [age#40L, id#38, name#39], [isnotnull(age#40L), (age#40L > 36)] : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<src:string,dst:string,relationship:string>, false].src, input[0, struct<src:string,dst:string,relationship:string>, false].dst)), [id=#1370] +- *(3) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp2506060614762666678#2609] +- InMemoryTableScan [dst#45, relationship#46, src#44] +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] # Find chains of 4 vertices such that at least 2 of the 3 edges are \"friend\" relationships. # The when function is similar to the CASE WHEN in SQL chain4 = g . find ( \"(a)-[e1]->(b); (b)-[e2]->(c); (c)-[e3]->(d)\" ) . where ( 'a!=d AND a!=c AND b!=d' ) friendTo1 = lambda e : when ( e [ 'relationship' ] == 'friend' , 1 ) . otherwise ( 0 ) chain4 . select ( '*' , friendTo1 ( chain4 [ 'e1' ]) . alias ( 'f1' ), \\ friendTo1 ( chain4 [ 'e2' ]) . alias ( 'f2' ), \\ friendTo1 ( chain4 [ 'e3' ]) . alias ( 'f3' )) \\ . where ( 'f1 + f2 + f3 >= 2' ) . select ( 'a' , 'b' , 'c' , 'd' ) . show () +---------------+--------------+---------------+--------------+---------------+--------------+----------------+---+---+---+ | a| e1| b| e2| c| e3| d| f1| f2| f3| +---------------+--------------+---------------+--------------+---------------+--------------+----------------+---+---+---+ | [d, David, 29]|[d, a, friend]| [a, Alice, 34]|[a, e, friend]|[e, Esther, 32]|[e, f, follow]| [f, Fanny, 38]| 1| 1| 0| | [d, David, 29]|[d, a, friend]| [a, Alice, 34]|[a, b, friend]| [b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| 1| 1| 0| |[e, Esther, 32]|[e, d, friend]| [d, David, 29]|[d, a, friend]| [a, Alice, 34]|[a, b, friend]| [b, Bob, 36]| 1| 1| 1| | [g, Gabby, 60]|[g, e, follow]|[e, Esther, 32]|[e, d, friend]| [d, David, 29]|[d, a, friend]| [a, Alice, 34]| 0| 1| 1| +---------------+--------------+---------------+--------------+---------------+--------------+----------------+---+---+---+ Subgraphs \u00b6 # Select subgraph of users older than 30, and relationships of type \"friend\". # Drop isolated vertices (users) which are not contained in any edges (relationships). g1 = g . filterVertices ( \"age > 30\" ) . filterEdges ( \"relationship = 'friend'\" ) \\ . dropIsolatedVertices () g1 . vertices . show () g1 . edges . show () +---+------+---+ | id| name|age| +---+------+---+ | e|Esther| 32| | b| Bob| 36| | a| Alice| 34| +---+------+---+ +---+---+------------+ |src|dst|relationship| +---+---+------------+ | a| e| friend| | a| b| friend| +---+---+------------+ # Select subgraph based on edges \"e\" of type \"follow\" # pointing from a younger user \"a\" to an older user \"b\". paths = g . find ( \"(a)-[e]->(b)\" ) \\ . filter ( \"e.relationship = 'follow'\" ) \\ . filter ( \"a.age < b.age\" ) # \"paths\" contains vertex info. Extract the edges. e2 = paths . select ( \"e.*\" ) # Construct the subgraph g2 = GraphFrame ( g . vertices , e2 ) . dropIsolatedVertices () g2 . vertices . show () g2 . edges . show () +---+-------+---+ | id| name|age| +---+-------+---+ | f| Fanny| 38| | e| Esther| 32| | c|Charlie| 37| | b| Bob| 36| +---+-------+---+ +---+---+------------+ |src|dst|relationship| +---+---+------------+ | e| f| follow| | b| c| follow| +---+---+------------+ BFS \u00b6 # Starting vertex is 'a' layers = [ g . vertices . select ( 'id' ) . where ( \"id = 'a'\" )] visited = layers [ 0 ] while layers [ - 1 ] . count () > 0 : # From the current layer, get all the one-hop neighbors d1 = layers [ - 1 ] . join ( g . edges , layers [ - 1 ][ 'id' ] == g . edges [ 'src' ]) # Rename the column as 'id', and remove visited verices and duplicates d2 = d1 . select ( d1 [ 'dst' ] . alias ( 'id' )) \\ . subtract ( visited ) . distinct () . cache () layers += [ d2 ] visited = visited . union ( layers [ - 1 ]) . cache () layers [ 0 ] . show () +---+ | id| +---+ | a| +---+ layers [ 1 ] . show () +---+ | id| +---+ | e| | b| +---+ layers [ 2 ] . show () +---+ | id| +---+ | f| | d| | c| +---+ layers [ 3 ] . show () +---+ | id| +---+ +---+ # GraphFrames provides own BFS: paths = g . bfs ( \"id = 'a'\" , \"age > 36\" ) paths . show () +--------------+--------------+---------------+--------------+----------------+ | from| e0| v1| e1| to| +--------------+--------------+---------------+--------------+----------------+ |[a, Alice, 34]|[a, b, friend]| [b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| |[a, Alice, 34]|[a, e, friend]|[e, Esther, 32]|[e, f, follow]| [f, Fanny, 38]| +--------------+--------------+---------------+--------------+----------------+ List Ranking \u00b6 # -1 denotes end of list data = [( 0 , 5 ), ( 1 , 0 ), ( 3 , 4 ), ( 4 , 6 ), ( 5 , - 1 ), ( 6 , 1 )] e = spark . createDataFrame ( data , [ 'src' , 'dst' ]) v = e . select ( col ( 'src' ) . alias ( 'id' ), when ( e . dst == - 1 , 0 ) . otherwise ( 1 ) . alias ( 'd' )) v1 = spark . createDataFrame ([( - 1 , 0 )], [ 'id' , 'd' ]) v = v . union ( v1 ) v . show () e . show () +---+---+ | id| d| +---+---+ | 0| 1| | 1| 1| | 3| 1| | 4| 1| | 5| 0| | 6| 1| | -1| 0| +---+---+ +---+---+ |src|dst| +---+---+ | 0| 5| | 1| 0| | 3| 4| | 4| 6| | 5| -1| | 6| 1| +---+---+ while e . filter ( 'dst != -1' ) . count () > 0 : g = GraphFrame ( v , e ) g . cache () v = g . triplets . select ( col ( 'src.id' ) . alias ( 'id' ), ( col ( 'src.d' ) + col ( 'dst.d' )) . alias ( 'd' )) \\ . union ( v1 ) e = g . find ( '(a)-[]->(b); (b)-[]->(c)' ) \\ . select ( col ( 'a.id' ) . alias ( 'src' ), col ( 'c.id' ) . alias ( 'dst' )) \\ . union ( e . filter ( 'dst = -1' )) v . show () +---+---+ | id| d| +---+---+ | 0| 1| | 1| 2| | 3| 5| | 4| 4| | 5| 0| | 6| 3| | -1| 0| +---+---+ Message passing via AggregateMessages \u00b6 from pyspark.sql.functions import coalesce , col , lit , sum , when , min , max from graphframes.lib import AggregateMessages as AM # AggregateMessages has the following members: src, dst, edge, msg # For each user, sum the ages of the adjacent users. agg = g . aggregateMessages ( sum ( AM . msg ) . alias ( \"summedAges\" ), sendToSrc = AM . dst [ 'age' ], sendToDst = AM . src [ 'age' ]) agg . show () +---+----------+ | id|summedAges| +---+----------+ | g| 32| | f| 69| | e| 161| | d| 66| | c| 110| | b| 108| | a| 97| +---+----------+ The Pregel Model for Graph Computation \u00b6 # Pagerank in the Pregel model from pyspark.sql.functions import coalesce , col , lit , sum , when , min from graphframes.lib import Pregel # Need to set up a directory for Pregel computation sc . setCheckpointDir ( \"checkpoint\" ) ''' Use builder pattern to describe the operations. Call run() to start a run. It returns a DataFrame of vertices from the last iteration. When a run starts, it expands the vertices DataFrame using column expressions defined by withVertexColumn(). Those additional vertex properties can be changed during Pregel iterations. In each Pregel iteration, there are three phases: * Given each edge triplet, generate messages and specify target vertices to send, described by sendMsgToDst() and sendMsgToSrc(). * Aggregate messages by target vertex IDs, described by aggMsgs(). * Update additional vertex properties based on aggregated messages and states from previous iteration, described by withVertexColumn(). ''' v = g . outDegrees g = GraphFrame ( v , e ) ranks = g . pregel \\ . setMaxIter ( 5 ) \\ . sendMsgToDst ( Pregel . src ( \"rank\" ) / Pregel . src ( \"outDegree\" )) \\ . aggMsgs ( sum ( Pregel . msg ())) \\ . withVertexColumn ( \"rank\" , lit ( 1.0 ), \\ coalesce ( Pregel . msg (), lit ( 0.0 )) * lit ( 0.85 ) + lit ( 0.15 )) \\ . run () ranks . show () # pyspark.sql.functions.coalesce(*cols): Returns the first column that is not null. # Not to be confused with spark.sql.coalesce(numPartitions) +---+---------+-------------------+ | id|outDegree| rank| +---+---------+-------------------+ | g| 1| 0.15| | f| 1|0.41104330078124995| | e| 2| 0.5032932031249999| | d| 1|0.41104330078124995| | c| 1| 2.780783203124999| | b| 1| 2.2680220312499997| | a| 2| 0.4758149609375| +---+---------+-------------------+ # BFS in the Pregel model g = GraphFrame ( v , e ) dist = g . pregel \\ . sendMsgToDst ( when ( Pregel . src ( 'active' ), Pregel . src ( 'd' ) + 1 )) \\ . aggMsgs ( min ( Pregel . msg ())) \\ . withVertexColumn ( 'd' , when ( v [ 'id' ] == 'a' , 0 ) . otherwise ( 99999 ), \\ when ( Pregel . msg () < col ( 'd' ), Pregel . msg ()) . otherwise ( col ( 'd' ))) \\ . withVertexColumn ( 'active' , when ( v [ 'id' ] == 'a' , True ) . otherwise ( False ), \\ when ( Pregel . msg () < col ( 'd' ), True ) . otherwise ( False )) \\ . run () dist . show () +---+---------+-----+------+ | id|outDegree| d|active| +---+---------+-----+------+ | g| 1|99999| false| | f| 1| 2| false| | e| 2| 1| false| | d| 1| 2| false| | c| 1| 2| false| | b| 1| 1| false| | a| 2| 0| false| +---+---------+-----+------+","title":"Graph"},{"location":"MSBD5003/notebooks%20in%20class/graph/#motif-finding","text":"# Search for pairs of vertices with edges in both directions between them. motifs = g . find ( \"(a)-[]->(b); (b)-[]->(a)\" ) . filter ( 'a.id < b.id' ) motifs . show () +------------+----------------+ | a| b| +------------+----------------+ |[b, Bob, 36]|[c, Charlie, 37]| +------------+----------------+ # Find triangles triangles = g . find ( \"(a)-[]->(b); (b)-[]->(c); (c)-[]->(a)\" ) triangles = triangles . filter ( \"a.id < b.id AND a.id < c.id\" ) triangles . show () +--------------+---------------+--------------+ | a| b| c| +--------------+---------------+--------------+ |[a, Alice, 34]|[e, Esther, 32]|[d, David, 29]| +--------------+---------------+--------------+ triangles . explain () == Physical Plan == *(6) Project [a#630, b#632, c#657] +- *(6) BroadcastHashJoin [c#657.id, a#630.id], [__tmp-6526019406657860729#687.src, __tmp-6526019406657860729#687.dst], Inner, BuildRight :- *(6) Project [a#630, b#632, c#657] : +- *(6) BroadcastHashJoin [__tmp-430217833014886237#655.dst], [c#657.id], Inner, BuildRight, (a#630.id < c#657.id) : :- *(6) BroadcastHashJoin [b#632.id], [__tmp-430217833014886237#655.src], Inner, BuildRight : : :- *(6) Project [a#630, b#632] : : : +- *(6) BroadcastHashJoin [__tmp-1043886091038848698#628.dst], [b#632.id], Inner, BuildRight, (a#630.id < b#632.id) : : : :- *(6) BroadcastHashJoin [__tmp-1043886091038848698#628.src], [a#630.id], Inner, BuildRight : : : : :- *(6) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-1043886091038848698#628] : : : : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : : : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : : : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : : : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#628] : : : : +- *(1) Project [struct(id, id#38, name, name#39, age, age#40L) AS a#630] : : : : +- InMemoryTableScan [age#40L, id#38, name#39] : : : : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : : : : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] : : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#634] : : : +- *(2) Project [struct(id, id#38, name, name#39, age, age#40L) AS b#632] : : : +- InMemoryTableScan [age#40L, id#38, name#39] : : : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : : : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<src:string,dst:string,relationship:string>, false].src)), [id=#641] : : +- *(3) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-430217833014886237#655] : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#647] : +- *(4) Project [struct(id, id#38, name, name#39, age, age#40L) AS c#657] : +- InMemoryTableScan [age#40L, id#38, name#39] : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<src:string,dst:string,relationship:string>, false].src, input[0, struct<src:string,dst:string,relationship:string>, false].dst)), [id=#654] +- *(5) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-6526019406657860729#687] +- InMemoryTableScan [dst#45, relationship#46, src#44] +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] # Negation oneway = g . find ( \"(a)-[]->(b); !(b)-[]->(a)\" ) oneway . show () +---------------+----------------+ | a| b| +---------------+----------------+ | [a, Alice, 34]| [e, Esther, 32]| |[e, Esther, 32]| [d, David, 29]| | [a, Alice, 34]| [b, Bob, 36]| | [g, Gabby, 60]| [e, Esther, 32]| |[e, Esther, 32]| [f, Fanny, 38]| | [f, Fanny, 38]|[c, Charlie, 37]| | [d, David, 29]| [a, Alice, 34]| +---------------+----------------+ # Find vertices without incoming edges: g . find ( \"!()-[]->(a)\" ) . show () +--------------+ | a| +--------------+ |[g, Gabby, 60]| +--------------+ # More meaningful queries can be expressed by applying filters. # Question: where is this filter applied? g . find ( \"(a)-[e]->(b); (b)-[]->(a)\" ) . filter ( \"b.age > 36\" ) . show () +------------+--------------+----------------+ | a| e| b| +------------+--------------+----------------+ |[b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| +------------+--------------+----------------+ +------------+ |relationship| +------------+ | follow| +------------+ g . find ( \"(a)-[]->(b); (b)-[]->(a)\" ) . filter ( \"b.age > 36\" ) . explain () == Physical Plan == *(4) Project [a#2584, b#2586] +- *(4) BroadcastHashJoin [b#2586.id, a#2584.id], [__tmp2506060614762666678#2609.src, __tmp2506060614762666678#2609.dst], Inner, BuildRight :- *(4) Project [a#2584, b#2586] : +- *(4) BroadcastHashJoin [__tmp-3851898762290097694#2582.dst], [b#2586.id], Inner, BuildRight : :- *(4) BroadcastHashJoin [__tmp-3851898762290097694#2582.src], [a#2584.id], Inner, BuildRight : : :- *(4) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp-3851898762290097694#2582] : : : +- InMemoryTableScan [dst#45, relationship#46, src#44] : : : +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) : : : +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] : : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#1356] : : +- *(1) Project [struct(id, id#38, name, name#39, age, age#40L) AS a#2584] : : +- InMemoryTableScan [age#40L, id#38, name#39] : : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] : +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<id:string,name:string,age:bigint>, false].id)), [id=#1363] : +- *(2) Project [struct(id, id#38, name, name#39, age, age#40L) AS b#2586] : +- *(2) Filter (isnotnull(age#40L) AND (age#40L > 36)) : +- InMemoryTableScan [age#40L, id#38, name#39], [isnotnull(age#40L), (age#40L > 36)] : +- InMemoryRelation [id#38, name#39, age#40L], StorageLevel(disk, memory, deserialized, 1 replicas) : +- *(1) Scan ExistingRDD[id#38,name#39,age#40L] +- BroadcastExchange HashedRelationBroadcastMode(List(input[0, struct<src:string,dst:string,relationship:string>, false].src, input[0, struct<src:string,dst:string,relationship:string>, false].dst)), [id=#1370] +- *(3) Project [struct(src, src#44, dst, dst#45, relationship, relationship#46) AS __tmp2506060614762666678#2609] +- InMemoryTableScan [dst#45, relationship#46, src#44] +- InMemoryRelation [src#44, dst#45, relationship#46], StorageLevel(disk, memory, deserialized, 1 replicas) +- *(1) Scan ExistingRDD[src#44,dst#45,relationship#46] # Find chains of 4 vertices such that at least 2 of the 3 edges are \"friend\" relationships. # The when function is similar to the CASE WHEN in SQL chain4 = g . find ( \"(a)-[e1]->(b); (b)-[e2]->(c); (c)-[e3]->(d)\" ) . where ( 'a!=d AND a!=c AND b!=d' ) friendTo1 = lambda e : when ( e [ 'relationship' ] == 'friend' , 1 ) . otherwise ( 0 ) chain4 . select ( '*' , friendTo1 ( chain4 [ 'e1' ]) . alias ( 'f1' ), \\ friendTo1 ( chain4 [ 'e2' ]) . alias ( 'f2' ), \\ friendTo1 ( chain4 [ 'e3' ]) . alias ( 'f3' )) \\ . where ( 'f1 + f2 + f3 >= 2' ) . select ( 'a' , 'b' , 'c' , 'd' ) . show () +---------------+--------------+---------------+--------------+---------------+--------------+----------------+---+---+---+ | a| e1| b| e2| c| e3| d| f1| f2| f3| +---------------+--------------+---------------+--------------+---------------+--------------+----------------+---+---+---+ | [d, David, 29]|[d, a, friend]| [a, Alice, 34]|[a, e, friend]|[e, Esther, 32]|[e, f, follow]| [f, Fanny, 38]| 1| 1| 0| | [d, David, 29]|[d, a, friend]| [a, Alice, 34]|[a, b, friend]| [b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| 1| 1| 0| |[e, Esther, 32]|[e, d, friend]| [d, David, 29]|[d, a, friend]| [a, Alice, 34]|[a, b, friend]| [b, Bob, 36]| 1| 1| 1| | [g, Gabby, 60]|[g, e, follow]|[e, Esther, 32]|[e, d, friend]| [d, David, 29]|[d, a, friend]| [a, Alice, 34]| 0| 1| 1| +---------------+--------------+---------------+--------------+---------------+--------------+----------------+---+---+---+","title":"Motif Finding"},{"location":"MSBD5003/notebooks%20in%20class/graph/#subgraphs","text":"# Select subgraph of users older than 30, and relationships of type \"friend\". # Drop isolated vertices (users) which are not contained in any edges (relationships). g1 = g . filterVertices ( \"age > 30\" ) . filterEdges ( \"relationship = 'friend'\" ) \\ . dropIsolatedVertices () g1 . vertices . show () g1 . edges . show () +---+------+---+ | id| name|age| +---+------+---+ | e|Esther| 32| | b| Bob| 36| | a| Alice| 34| +---+------+---+ +---+---+------------+ |src|dst|relationship| +---+---+------------+ | a| e| friend| | a| b| friend| +---+---+------------+ # Select subgraph based on edges \"e\" of type \"follow\" # pointing from a younger user \"a\" to an older user \"b\". paths = g . find ( \"(a)-[e]->(b)\" ) \\ . filter ( \"e.relationship = 'follow'\" ) \\ . filter ( \"a.age < b.age\" ) # \"paths\" contains vertex info. Extract the edges. e2 = paths . select ( \"e.*\" ) # Construct the subgraph g2 = GraphFrame ( g . vertices , e2 ) . dropIsolatedVertices () g2 . vertices . show () g2 . edges . show () +---+-------+---+ | id| name|age| +---+-------+---+ | f| Fanny| 38| | e| Esther| 32| | c|Charlie| 37| | b| Bob| 36| +---+-------+---+ +---+---+------------+ |src|dst|relationship| +---+---+------------+ | e| f| follow| | b| c| follow| +---+---+------------+","title":"Subgraphs"},{"location":"MSBD5003/notebooks%20in%20class/graph/#bfs","text":"# Starting vertex is 'a' layers = [ g . vertices . select ( 'id' ) . where ( \"id = 'a'\" )] visited = layers [ 0 ] while layers [ - 1 ] . count () > 0 : # From the current layer, get all the one-hop neighbors d1 = layers [ - 1 ] . join ( g . edges , layers [ - 1 ][ 'id' ] == g . edges [ 'src' ]) # Rename the column as 'id', and remove visited verices and duplicates d2 = d1 . select ( d1 [ 'dst' ] . alias ( 'id' )) \\ . subtract ( visited ) . distinct () . cache () layers += [ d2 ] visited = visited . union ( layers [ - 1 ]) . cache () layers [ 0 ] . show () +---+ | id| +---+ | a| +---+ layers [ 1 ] . show () +---+ | id| +---+ | e| | b| +---+ layers [ 2 ] . show () +---+ | id| +---+ | f| | d| | c| +---+ layers [ 3 ] . show () +---+ | id| +---+ +---+ # GraphFrames provides own BFS: paths = g . bfs ( \"id = 'a'\" , \"age > 36\" ) paths . show () +--------------+--------------+---------------+--------------+----------------+ | from| e0| v1| e1| to| +--------------+--------------+---------------+--------------+----------------+ |[a, Alice, 34]|[a, b, friend]| [b, Bob, 36]|[b, c, follow]|[c, Charlie, 37]| |[a, Alice, 34]|[a, e, friend]|[e, Esther, 32]|[e, f, follow]| [f, Fanny, 38]| +--------------+--------------+---------------+--------------+----------------+","title":"BFS"},{"location":"MSBD5003/notebooks%20in%20class/graph/#list-ranking","text":"# -1 denotes end of list data = [( 0 , 5 ), ( 1 , 0 ), ( 3 , 4 ), ( 4 , 6 ), ( 5 , - 1 ), ( 6 , 1 )] e = spark . createDataFrame ( data , [ 'src' , 'dst' ]) v = e . select ( col ( 'src' ) . alias ( 'id' ), when ( e . dst == - 1 , 0 ) . otherwise ( 1 ) . alias ( 'd' )) v1 = spark . createDataFrame ([( - 1 , 0 )], [ 'id' , 'd' ]) v = v . union ( v1 ) v . show () e . show () +---+---+ | id| d| +---+---+ | 0| 1| | 1| 1| | 3| 1| | 4| 1| | 5| 0| | 6| 1| | -1| 0| +---+---+ +---+---+ |src|dst| +---+---+ | 0| 5| | 1| 0| | 3| 4| | 4| 6| | 5| -1| | 6| 1| +---+---+ while e . filter ( 'dst != -1' ) . count () > 0 : g = GraphFrame ( v , e ) g . cache () v = g . triplets . select ( col ( 'src.id' ) . alias ( 'id' ), ( col ( 'src.d' ) + col ( 'dst.d' )) . alias ( 'd' )) \\ . union ( v1 ) e = g . find ( '(a)-[]->(b); (b)-[]->(c)' ) \\ . select ( col ( 'a.id' ) . alias ( 'src' ), col ( 'c.id' ) . alias ( 'dst' )) \\ . union ( e . filter ( 'dst = -1' )) v . show () +---+---+ | id| d| +---+---+ | 0| 1| | 1| 2| | 3| 5| | 4| 4| | 5| 0| | 6| 3| | -1| 0| +---+---+","title":"List Ranking"},{"location":"MSBD5003/notebooks%20in%20class/graph/#message-passing-via-aggregatemessages","text":"from pyspark.sql.functions import coalesce , col , lit , sum , when , min , max from graphframes.lib import AggregateMessages as AM # AggregateMessages has the following members: src, dst, edge, msg # For each user, sum the ages of the adjacent users. agg = g . aggregateMessages ( sum ( AM . msg ) . alias ( \"summedAges\" ), sendToSrc = AM . dst [ 'age' ], sendToDst = AM . src [ 'age' ]) agg . show () +---+----------+ | id|summedAges| +---+----------+ | g| 32| | f| 69| | e| 161| | d| 66| | c| 110| | b| 108| | a| 97| +---+----------+","title":"Message passing via AggregateMessages"},{"location":"MSBD5003/notebooks%20in%20class/graph/#the-pregel-model-for-graph-computation","text":"# Pagerank in the Pregel model from pyspark.sql.functions import coalesce , col , lit , sum , when , min from graphframes.lib import Pregel # Need to set up a directory for Pregel computation sc . setCheckpointDir ( \"checkpoint\" ) ''' Use builder pattern to describe the operations. Call run() to start a run. It returns a DataFrame of vertices from the last iteration. When a run starts, it expands the vertices DataFrame using column expressions defined by withVertexColumn(). Those additional vertex properties can be changed during Pregel iterations. In each Pregel iteration, there are three phases: * Given each edge triplet, generate messages and specify target vertices to send, described by sendMsgToDst() and sendMsgToSrc(). * Aggregate messages by target vertex IDs, described by aggMsgs(). * Update additional vertex properties based on aggregated messages and states from previous iteration, described by withVertexColumn(). ''' v = g . outDegrees g = GraphFrame ( v , e ) ranks = g . pregel \\ . setMaxIter ( 5 ) \\ . sendMsgToDst ( Pregel . src ( \"rank\" ) / Pregel . src ( \"outDegree\" )) \\ . aggMsgs ( sum ( Pregel . msg ())) \\ . withVertexColumn ( \"rank\" , lit ( 1.0 ), \\ coalesce ( Pregel . msg (), lit ( 0.0 )) * lit ( 0.85 ) + lit ( 0.15 )) \\ . run () ranks . show () # pyspark.sql.functions.coalesce(*cols): Returns the first column that is not null. # Not to be confused with spark.sql.coalesce(numPartitions) +---+---------+-------------------+ | id|outDegree| rank| +---+---------+-------------------+ | g| 1| 0.15| | f| 1|0.41104330078124995| | e| 2| 0.5032932031249999| | d| 1|0.41104330078124995| | c| 1| 2.780783203124999| | b| 1| 2.2680220312499997| | a| 2| 0.4758149609375| +---+---------+-------------------+ # BFS in the Pregel model g = GraphFrame ( v , e ) dist = g . pregel \\ . sendMsgToDst ( when ( Pregel . src ( 'active' ), Pregel . src ( 'd' ) + 1 )) \\ . aggMsgs ( min ( Pregel . msg ())) \\ . withVertexColumn ( 'd' , when ( v [ 'id' ] == 'a' , 0 ) . otherwise ( 99999 ), \\ when ( Pregel . msg () < col ( 'd' ), Pregel . msg ()) . otherwise ( col ( 'd' ))) \\ . withVertexColumn ( 'active' , when ( v [ 'id' ] == 'a' , True ) . otherwise ( False ), \\ when ( Pregel . msg () < col ( 'd' ), True ) . otherwise ( False )) \\ . run () dist . show () +---+---------+-----+------+ | id|outDegree| d|active| +---+---------+-----+------+ | g| 1|99999| false| | f| 1| 2| false| | e| 2| 1| false| | d| 1| 2| false| | c| 1| 2| false| | b| 1| 1| false| | a| 2| 0| false| +---+---------+-----+------+","title":"The Pregel Model for Graph Computation"},{"location":"MSBD5003/notebooks%20in%20class/internal/","text":"! pip install pyspark from pyspark.context import SparkContext sc = SparkContext . getOrCreate () Finding Prime Numbers \u00b6 Algorithm: take every number from 2 to n find all multiples of these numbers that are smaller than or equal to n (containing duplicates, but that\u2019s ok) subtract from all numbers these composite numbers We see that all tasks but one finished quickly, while the last one takes a long time. before more deep but less efficient n = 5000 allnumbers = sc . parallelize ( range ( 2 , n ), 8 ) . cache () composite = allnumbers . flatMap ( lambda x : range ( x * 2 , n , x )) prime = allnumbers . subtract ( composite ) print ( composite . take ( 10 )) print ( prime . take ( 10 )) [4, 6, 8, 10, 12, 14, 16, 18, 20, 22] [17, 97, 113, 193, 241, 257, 337, 353, 401, 433] # Find the number of elements in each parttion def partitionsize ( it ): yield len ( list ( it )) print ( allnumbers . mapPartitions ( partitionsize ) . collect ()) print ( composite . mapPartitions ( partitionsize ) . collect ()) print ( prime . mapPartitions ( partitionsize ) . collect ()) print ( prime . glom () . collect ()[ 2 ][ 0 : 4 ]) [624, 625, 625, 625, 624, 625, 625, 625] [4174, 4160, 4170, 4170, 4170, 4164, 4170, 4181] [0, 81, 1, 84, 0, 81, 0, 87, 0, 80, 0, 84, 0, 87, 0, 84] [2] after efficient in time but more in total time allnumbers = sc . parallelize ( range ( 2 , n ), 8 ) . cache () composite = allnumbers . flatMap ( lambda x : range ( x * 2 , n , x )) . repartition ( 8 ) prime = allnumbers . subtract ( composite ) print ( composite . take ( 10 )) print ( prime . take ( 10 )) [44, 46, 48, 50, 52, 54, 56, 58, 60, 62] [17, 97, 113, 193, 241, 257, 337, 353, 401, 433] print ( allnumbers . mapPartitions ( partitionsize ) . collect ()) print ( composite . mapPartitions ( partitionsize ) . collect ()) print ( prime . mapPartitions ( partitionsize ) . collect ()) print ( prime . glom () . collect ()[ 1 ][ 0 : 4 ]) [624, 625, 625, 625, 624, 625, 625, 625] [4174, 4160, 4170, 4170, 4170, 4164, 4170, 4181] [0, 81, 1, 84, 0, 81, 0, 87, 0, 80, 0, 84, 0, 87, 0, 84] [17, 97, 113, 193] Data Partitioning \u00b6 data = [ 8 , 96 , 240 , 400 , 1 , 800 , 4 , 12 ] rdd = sc . parallelize ( zip ( data , data ), 4 ) print ( rdd . partitioner ) print ( rdd . glom () . collect ()) rdd = rdd . reduceByKey ( lambda x , y : x + y ) print ( rdd . glom () . collect ()) print ( rdd . partitioner ) print ( rdd . partitioner . partitionFunc ) rdd1 = rdd . map ( lambda x : ( x [ 0 ], x [ 1 ] + 1 )) print ( rdd1 . glom () . collect ()) print ( rdd1 . partitioner ) rdd2 = rdd . mapValues ( lambda x : x + 1 ) print ( rdd2 . partitioner . partitionFunc ) rdd = rdd . sortByKey () print ( rdd . glom () . collect ()) print ( rdd . partitioner . partitionFunc ) rdd3 = rdd . mapValues ( lambda x : x + 1 ) print ( rdd3 . partitioner . partitionFunc ) None [[(8, 8), (96, 96)], [(240, 240), (400, 400)], [(1, 1), (800, 800)], [(4, 4), (12, 12)]] [[(8, 8), (96, 96), (240, 240), (400, 400), (800, 800), (4, 4), (12, 12)], [(1, 1)], [], []] <pyspark.rdd.Partitioner object at 0x7fd9be009198> <function portable_hash at 0x7fd9cc338488> [[(8, 9), (96, 97), (240, 241), (400, 401), (800, 801), (4, 5), (12, 13)], [(1, 2)], [], []] None <function portable_hash at 0x7fd9cc338488> [[(1, 1), (4, 4), (8, 8)], [(12, 12), (96, 96)], [(240, 240), (400, 400)], [(800, 800)]] <function RDD.sortByKey.<locals>.rangePartitioner at 0x7fd9be0b68c8> <function RDD.sortByKey.<locals>.rangePartitioner at 0x7fd9be0b68c8> def partitionsize ( it ): yield len ( list ( it )) n = 40000 def f ( x ): return x % 9 data1 = list ( range ( 0 , n , 16 )) + list ( range ( 0 , n , 16 )) data2 = range ( 0 , n , 8 ) rdd1 = sc . parallelize ( zip ( data1 , data2 ), 8 ) print ( rdd1 . mapPartitions ( partitionsize ) . collect ()) rdd2 = rdd1 . reduceByKey ( lambda x , y : x + y ) print ( rdd2 . mapPartitions ( partitionsize ) . collect ()) rdd3 = rdd2 . partitionBy ( 8 , f ) print ( rdd3 . mapPartitions ( partitionsize ) . collect ()) rdd4 = rdd1 . reduceByKey ( lambda x , y : x + y , partitionFunc = f ) print ( rdd4 . mapPartitions ( partitionsize ) . collect ()) [625, 625, 625, 625, 625, 625, 625, 625] [2500, 0, 0, 0, 0, 0, 0, 0] [556, 278, 277, 278, 277, 278, 278, 278] [556, 278, 277, 278, 277, 278, 278, 278] a = sc . parallelize ( zip ( range ( 10000 ), range ( 10000 )), 8 ) b = sc . parallelize ( zip ( range ( 10000 ), range ( 10000 )), 8 ) print ( a . partitioner ) a = a . reduceByKey ( lambda x , y : x + y ) print ( a . partitioner . partitionFunc ) b = b . reduceByKey ( lambda x , y : x + y ) print ( b . partitioner . partitionFunc ) c = a . join ( b ) print ( c . getNumPartitions ()) print ( c . partitioner . partitionFunc ) print ( c . glom () . first ()[ 0 : 4 ]) None <function portable_hash at 0x7fd9cc338488> <function portable_hash at 0x7fd9cc338488> 8 <function portable_hash at 0x7fd9cc338488> [(0, (0, 0)), (8, (8, 8)), (16, (16, 16)), (24, (24, 24))] Partitioning in DataFrames \u00b6 data1 = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 ] data2 = [ 2 , 2 , 3 , 4 , 5 , 3 , 1 , 1 , 2 , 3 ] df = spark . createDataFrame ( zip ( data1 , data2 )) print ( df . rdd . getNumPartitions ()) print ( df . rdd . glom () . collect ()) 48 [[], [], [], [], [Row(_1=1, _2=2)], [], [], [], [], [Row(_1=1, _2=2)], [], [], [], [], [Row(_1=1, _2=3)], [], [], [], [], [Row(_1=2, _2=4)], [], [], [], [Row(_1=2, _2=5)], [], [], [], [], [Row(_1=2, _2=3)], [], [], [], [], [Row(_1=3, _2=1)], [], [], [], [], [Row(_1=3, _2=1)], [], [], [], [], [Row(_1=3, _2=2)], [], [], [], [Row(_1=4, _2=3)]] df1 = df . repartition ( 6 , df . _1 ) print ( df1 . rdd . glom () . collect ()) df1 . show () [[], [], [Row(_1=2, _2=4), Row(_1=2, _2=5), Row(_1=2, _2=3), Row(_1=4, _2=3)], [Row(_1=3, _2=1), Row(_1=3, _2=1), Row(_1=3, _2=2)], [], [Row(_1=1, _2=2), Row(_1=1, _2=2), Row(_1=1, _2=3)]] +---+---+ | _1| _2| +---+---+ | 2| 4| | 2| 5| | 2| 3| | 4| 3| | 3| 1| | 3| 1| | 3| 2| | 1| 2| | 1| 2| | 1| 3| +---+---+ # A 'real' example from SF Express # Prepare three relational tables from pyspark.sql.functions import * num_waybills = 1000 num_customers = 100 rdd = sc . parallelize (( i , ) for i in range ( num_waybills )) waybills = spark . createDataFrame ( rdd ) . select ( floor ( rand () * num_waybills ) . alias ( 'waybill' ), floor ( rand () * num_customers ) . alias ( 'customer' )) \\ . repartition ( 'waybill' ) \\ . cache () waybills . show () print ( waybills . count ()) rdd = sc . parallelize (( i , i ) for i in range ( num_customers )) customers = spark . createDataFrame ( rdd , [ 'customer' , 'phone' ]) . cache () customers . show () print ( customers . count ()) rdd = sc . parallelize (( i , ) for i in range ( num_waybills )) waybill_status = spark . createDataFrame ( rdd ) . select ( floor ( rand () * num_waybills ) . alias ( 'waybill' ), floor ( rand () * 10 ) . alias ( 'version' )) \\ . groupBy ( 'waybill' ) . max ( 'version' ) . cache () waybill_status . show () print ( waybill_status . count ()) +-------+--------+ |waybill|customer| +-------+--------+ | 964| 90| | 474| 10| | 26| 73| | 26| 66| | 191| 56| | 191| 89| | 541| 73| | 541| 2| | 938| 12| | 278| 78| | 720| 93| | 705| 11| | 367| 22| | 442| 12| | 442| 91| | 367| 1| | 367| 48| | 296| 62| | 926| 86| | 965| 9| +-------+--------+ only showing top 20 rows 1000 +--------+-----+ |customer|phone| +--------+-----+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| | 5| 5| | 6| 6| | 7| 7| | 8| 8| | 9| 9| | 10| 10| | 11| 11| | 12| 12| | 13| 13| | 14| 14| | 15| 15| | 16| 16| | 17| 17| | 18| 18| | 19| 19| +--------+-----+ only showing top 20 rows 100 +-------+------------+ |waybill|max(version)| +-------+------------+ | 474| 4| | 964| 4| | 29| 8| | 191| 7| | 541| 5| | 293| 3| | 270| 7| | 938| 3| | 730| 8| | 243| 3| | 278| 9| | 367| 5| | 442| 6| | 54| 9| | 19| 1| | 965| 9| | 926| 6| | 296| 0| | 0| 5| | 287| 4| +-------+------------+ only showing top 20 rows 635 # We want to join 3 tables together. # Knowing how each table is partitioned helps optimize the join order. # waybills.join(customers, 'customer').join(waybill_status, 'waybill').show() waybills . join ( waybill_status , 'waybill' ) . join ( customers , 'customer' ) . show () +--------+-------+------------+-----+ |customer|waybill|max(version)|phone| +--------+-------+------------+-----+ | 90| 964| 4| 90| | 10| 474| 4| 10| | 56| 191| 7| 56| | 89| 191| 7| 89| | 73| 541| 5| 73| | 2| 541| 5| 2| | 12| 938| 3| 12| | 78| 278| 9| 78| | 22| 367| 5| 22| | 12| 442| 6| 12| | 91| 442| 6| 91| | 1| 367| 5| 1| | 48| 367| 5| 48| | 62| 296| 0| 62| | 86| 926| 6| 86| | 9| 965| 9| 9| | 22| 19| 1| 22| | 45| 54| 9| 45| | 73| 926| 6| 73| | 10| 926| 6| 10| +--------+-------+------------+-----+ only showing top 20 rows Threading \u00b6 import threading import random partitions = 20 n = 5000000 * partitions # use different seeds in different threads and different partitions # a bit ugly, since mapPartitionsWithIndex takes a function with only index # and it as parameters def f1 ( index , it ): random . seed ( index + 987231 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f2 ( index , it ): random . seed ( index + 987232 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f3 ( index , it ): random . seed ( index + 987233 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f4 ( index , it ): random . seed ( index + 987234 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f5 ( index , it ): random . seed ( index + 987245 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 f = [ f1 , f2 , f3 , f4 , f5 ] # the function executed in each thread/job def dojob ( i ): count = sc . parallelize ( range ( 1 , n + 1 ), partitions ) \\ . mapPartitionsWithIndex ( f [ i ]) . reduce ( lambda a , b : a + b ) print ( \"Worker\" , i , \"reports: Pi is roughly\" , 4.0 * count / n ) # create and execute the threads threads = [] for i in range ( 5 ): t = threading . Thread ( target = dojob , args = ( i ,)) threads += [ t ] t . start () # wait for all threads to complete for t in threads : t . join () Worker 1 reports: Pi is roughly 3.14160468 Worker 0 reports: Pi is roughly 3.14166108 Worker 2 reports: Pi is roughly 3.141534 Worker 3 reports: Pi is roughly 3.14153212 Worker 4 reports: Pi is roughly 3.1413932","title":"Internal"},{"location":"MSBD5003/notebooks%20in%20class/internal/#finding-prime-numbers","text":"Algorithm: take every number from 2 to n find all multiples of these numbers that are smaller than or equal to n (containing duplicates, but that\u2019s ok) subtract from all numbers these composite numbers We see that all tasks but one finished quickly, while the last one takes a long time. before more deep but less efficient n = 5000 allnumbers = sc . parallelize ( range ( 2 , n ), 8 ) . cache () composite = allnumbers . flatMap ( lambda x : range ( x * 2 , n , x )) prime = allnumbers . subtract ( composite ) print ( composite . take ( 10 )) print ( prime . take ( 10 )) [4, 6, 8, 10, 12, 14, 16, 18, 20, 22] [17, 97, 113, 193, 241, 257, 337, 353, 401, 433] # Find the number of elements in each parttion def partitionsize ( it ): yield len ( list ( it )) print ( allnumbers . mapPartitions ( partitionsize ) . collect ()) print ( composite . mapPartitions ( partitionsize ) . collect ()) print ( prime . mapPartitions ( partitionsize ) . collect ()) print ( prime . glom () . collect ()[ 2 ][ 0 : 4 ]) [624, 625, 625, 625, 624, 625, 625, 625] [4174, 4160, 4170, 4170, 4170, 4164, 4170, 4181] [0, 81, 1, 84, 0, 81, 0, 87, 0, 80, 0, 84, 0, 87, 0, 84] [2] after efficient in time but more in total time allnumbers = sc . parallelize ( range ( 2 , n ), 8 ) . cache () composite = allnumbers . flatMap ( lambda x : range ( x * 2 , n , x )) . repartition ( 8 ) prime = allnumbers . subtract ( composite ) print ( composite . take ( 10 )) print ( prime . take ( 10 )) [44, 46, 48, 50, 52, 54, 56, 58, 60, 62] [17, 97, 113, 193, 241, 257, 337, 353, 401, 433] print ( allnumbers . mapPartitions ( partitionsize ) . collect ()) print ( composite . mapPartitions ( partitionsize ) . collect ()) print ( prime . mapPartitions ( partitionsize ) . collect ()) print ( prime . glom () . collect ()[ 1 ][ 0 : 4 ]) [624, 625, 625, 625, 624, 625, 625, 625] [4174, 4160, 4170, 4170, 4170, 4164, 4170, 4181] [0, 81, 1, 84, 0, 81, 0, 87, 0, 80, 0, 84, 0, 87, 0, 84] [17, 97, 113, 193]","title":"Finding Prime Numbers"},{"location":"MSBD5003/notebooks%20in%20class/internal/#data-partitioning","text":"data = [ 8 , 96 , 240 , 400 , 1 , 800 , 4 , 12 ] rdd = sc . parallelize ( zip ( data , data ), 4 ) print ( rdd . partitioner ) print ( rdd . glom () . collect ()) rdd = rdd . reduceByKey ( lambda x , y : x + y ) print ( rdd . glom () . collect ()) print ( rdd . partitioner ) print ( rdd . partitioner . partitionFunc ) rdd1 = rdd . map ( lambda x : ( x [ 0 ], x [ 1 ] + 1 )) print ( rdd1 . glom () . collect ()) print ( rdd1 . partitioner ) rdd2 = rdd . mapValues ( lambda x : x + 1 ) print ( rdd2 . partitioner . partitionFunc ) rdd = rdd . sortByKey () print ( rdd . glom () . collect ()) print ( rdd . partitioner . partitionFunc ) rdd3 = rdd . mapValues ( lambda x : x + 1 ) print ( rdd3 . partitioner . partitionFunc ) None [[(8, 8), (96, 96)], [(240, 240), (400, 400)], [(1, 1), (800, 800)], [(4, 4), (12, 12)]] [[(8, 8), (96, 96), (240, 240), (400, 400), (800, 800), (4, 4), (12, 12)], [(1, 1)], [], []] <pyspark.rdd.Partitioner object at 0x7fd9be009198> <function portable_hash at 0x7fd9cc338488> [[(8, 9), (96, 97), (240, 241), (400, 401), (800, 801), (4, 5), (12, 13)], [(1, 2)], [], []] None <function portable_hash at 0x7fd9cc338488> [[(1, 1), (4, 4), (8, 8)], [(12, 12), (96, 96)], [(240, 240), (400, 400)], [(800, 800)]] <function RDD.sortByKey.<locals>.rangePartitioner at 0x7fd9be0b68c8> <function RDD.sortByKey.<locals>.rangePartitioner at 0x7fd9be0b68c8> def partitionsize ( it ): yield len ( list ( it )) n = 40000 def f ( x ): return x % 9 data1 = list ( range ( 0 , n , 16 )) + list ( range ( 0 , n , 16 )) data2 = range ( 0 , n , 8 ) rdd1 = sc . parallelize ( zip ( data1 , data2 ), 8 ) print ( rdd1 . mapPartitions ( partitionsize ) . collect ()) rdd2 = rdd1 . reduceByKey ( lambda x , y : x + y ) print ( rdd2 . mapPartitions ( partitionsize ) . collect ()) rdd3 = rdd2 . partitionBy ( 8 , f ) print ( rdd3 . mapPartitions ( partitionsize ) . collect ()) rdd4 = rdd1 . reduceByKey ( lambda x , y : x + y , partitionFunc = f ) print ( rdd4 . mapPartitions ( partitionsize ) . collect ()) [625, 625, 625, 625, 625, 625, 625, 625] [2500, 0, 0, 0, 0, 0, 0, 0] [556, 278, 277, 278, 277, 278, 278, 278] [556, 278, 277, 278, 277, 278, 278, 278] a = sc . parallelize ( zip ( range ( 10000 ), range ( 10000 )), 8 ) b = sc . parallelize ( zip ( range ( 10000 ), range ( 10000 )), 8 ) print ( a . partitioner ) a = a . reduceByKey ( lambda x , y : x + y ) print ( a . partitioner . partitionFunc ) b = b . reduceByKey ( lambda x , y : x + y ) print ( b . partitioner . partitionFunc ) c = a . join ( b ) print ( c . getNumPartitions ()) print ( c . partitioner . partitionFunc ) print ( c . glom () . first ()[ 0 : 4 ]) None <function portable_hash at 0x7fd9cc338488> <function portable_hash at 0x7fd9cc338488> 8 <function portable_hash at 0x7fd9cc338488> [(0, (0, 0)), (8, (8, 8)), (16, (16, 16)), (24, (24, 24))]","title":"Data Partitioning"},{"location":"MSBD5003/notebooks%20in%20class/internal/#partitioning-in-dataframes","text":"data1 = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 ] data2 = [ 2 , 2 , 3 , 4 , 5 , 3 , 1 , 1 , 2 , 3 ] df = spark . createDataFrame ( zip ( data1 , data2 )) print ( df . rdd . getNumPartitions ()) print ( df . rdd . glom () . collect ()) 48 [[], [], [], [], [Row(_1=1, _2=2)], [], [], [], [], [Row(_1=1, _2=2)], [], [], [], [], [Row(_1=1, _2=3)], [], [], [], [], [Row(_1=2, _2=4)], [], [], [], [Row(_1=2, _2=5)], [], [], [], [], [Row(_1=2, _2=3)], [], [], [], [], [Row(_1=3, _2=1)], [], [], [], [], [Row(_1=3, _2=1)], [], [], [], [], [Row(_1=3, _2=2)], [], [], [], [Row(_1=4, _2=3)]] df1 = df . repartition ( 6 , df . _1 ) print ( df1 . rdd . glom () . collect ()) df1 . show () [[], [], [Row(_1=2, _2=4), Row(_1=2, _2=5), Row(_1=2, _2=3), Row(_1=4, _2=3)], [Row(_1=3, _2=1), Row(_1=3, _2=1), Row(_1=3, _2=2)], [], [Row(_1=1, _2=2), Row(_1=1, _2=2), Row(_1=1, _2=3)]] +---+---+ | _1| _2| +---+---+ | 2| 4| | 2| 5| | 2| 3| | 4| 3| | 3| 1| | 3| 1| | 3| 2| | 1| 2| | 1| 2| | 1| 3| +---+---+ # A 'real' example from SF Express # Prepare three relational tables from pyspark.sql.functions import * num_waybills = 1000 num_customers = 100 rdd = sc . parallelize (( i , ) for i in range ( num_waybills )) waybills = spark . createDataFrame ( rdd ) . select ( floor ( rand () * num_waybills ) . alias ( 'waybill' ), floor ( rand () * num_customers ) . alias ( 'customer' )) \\ . repartition ( 'waybill' ) \\ . cache () waybills . show () print ( waybills . count ()) rdd = sc . parallelize (( i , i ) for i in range ( num_customers )) customers = spark . createDataFrame ( rdd , [ 'customer' , 'phone' ]) . cache () customers . show () print ( customers . count ()) rdd = sc . parallelize (( i , ) for i in range ( num_waybills )) waybill_status = spark . createDataFrame ( rdd ) . select ( floor ( rand () * num_waybills ) . alias ( 'waybill' ), floor ( rand () * 10 ) . alias ( 'version' )) \\ . groupBy ( 'waybill' ) . max ( 'version' ) . cache () waybill_status . show () print ( waybill_status . count ()) +-------+--------+ |waybill|customer| +-------+--------+ | 964| 90| | 474| 10| | 26| 73| | 26| 66| | 191| 56| | 191| 89| | 541| 73| | 541| 2| | 938| 12| | 278| 78| | 720| 93| | 705| 11| | 367| 22| | 442| 12| | 442| 91| | 367| 1| | 367| 48| | 296| 62| | 926| 86| | 965| 9| +-------+--------+ only showing top 20 rows 1000 +--------+-----+ |customer|phone| +--------+-----+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| | 5| 5| | 6| 6| | 7| 7| | 8| 8| | 9| 9| | 10| 10| | 11| 11| | 12| 12| | 13| 13| | 14| 14| | 15| 15| | 16| 16| | 17| 17| | 18| 18| | 19| 19| +--------+-----+ only showing top 20 rows 100 +-------+------------+ |waybill|max(version)| +-------+------------+ | 474| 4| | 964| 4| | 29| 8| | 191| 7| | 541| 5| | 293| 3| | 270| 7| | 938| 3| | 730| 8| | 243| 3| | 278| 9| | 367| 5| | 442| 6| | 54| 9| | 19| 1| | 965| 9| | 926| 6| | 296| 0| | 0| 5| | 287| 4| +-------+------------+ only showing top 20 rows 635 # We want to join 3 tables together. # Knowing how each table is partitioned helps optimize the join order. # waybills.join(customers, 'customer').join(waybill_status, 'waybill').show() waybills . join ( waybill_status , 'waybill' ) . join ( customers , 'customer' ) . show () +--------+-------+------------+-----+ |customer|waybill|max(version)|phone| +--------+-------+------------+-----+ | 90| 964| 4| 90| | 10| 474| 4| 10| | 56| 191| 7| 56| | 89| 191| 7| 89| | 73| 541| 5| 73| | 2| 541| 5| 2| | 12| 938| 3| 12| | 78| 278| 9| 78| | 22| 367| 5| 22| | 12| 442| 6| 12| | 91| 442| 6| 91| | 1| 367| 5| 1| | 48| 367| 5| 48| | 62| 296| 0| 62| | 86| 926| 6| 86| | 9| 965| 9| 9| | 22| 19| 1| 22| | 45| 54| 9| 45| | 73| 926| 6| 73| | 10| 926| 6| 10| +--------+-------+------------+-----+ only showing top 20 rows","title":"Partitioning in DataFrames"},{"location":"MSBD5003/notebooks%20in%20class/internal/#threading","text":"import threading import random partitions = 20 n = 5000000 * partitions # use different seeds in different threads and different partitions # a bit ugly, since mapPartitionsWithIndex takes a function with only index # and it as parameters def f1 ( index , it ): random . seed ( index + 987231 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f2 ( index , it ): random . seed ( index + 987232 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f3 ( index , it ): random . seed ( index + 987233 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f4 ( index , it ): random . seed ( index + 987234 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 def f5 ( index , it ): random . seed ( index + 987245 ) for i in it : x = random . random () * 2 - 1 y = random . random () * 2 - 1 yield 1 if x ** 2 + y ** 2 < 1 else 0 f = [ f1 , f2 , f3 , f4 , f5 ] # the function executed in each thread/job def dojob ( i ): count = sc . parallelize ( range ( 1 , n + 1 ), partitions ) \\ . mapPartitionsWithIndex ( f [ i ]) . reduce ( lambda a , b : a + b ) print ( \"Worker\" , i , \"reports: Pi is roughly\" , 4.0 * count / n ) # create and execute the threads threads = [] for i in range ( 5 ): t = threading . Thread ( target = dojob , args = ( i ,)) threads += [ t ] t . start () # wait for all threads to complete for t in threads : t . join () Worker 1 reports: Pi is roughly 3.14160468 Worker 0 reports: Pi is roughly 3.14166108 Worker 2 reports: Pi is roughly 3.141534 Worker 3 reports: Pi is roughly 3.14153212 Worker 4 reports: Pi is roughly 3.1413932","title":"Threading"},{"location":"MSBD5003/notebooks%20in%20class/rdd/","text":"! pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 67kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 43.8MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=2e05d41450b321a95e338481ca93d3ac73ca8949d26874ce7b1a793684007856 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from google.colab import drive drive . mount ( '/content/drive' ) Mounted at /content/drive from pyspark.context import SparkContext from pyspark.sql.session import SparkSession sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) How do I make an RDD? \u00b6 RDDs can be created from stable storage or by transforming other RDDs. Run the cells below to create RDDs from files on the local drive. All data files can be downloaded from https://www.cse.ust.hk/msbd5003/data/ For example, https://www.cse.ust.hk/msbd5003/data/fruits.txt # Read data from local file system: print ( sc . version ) fruits = sc . textFile ( '../data/fruits.txt' ) yellowThings = sc . textFile ( '../data/yellowthings.txt' ) print ( fruits . collect ()) print ( yellowThings . collect ()) 3.0.0 ['apple', 'banana', 'canary melon', 'grape', 'lemon', 'orange', 'pineapple', 'strawberry'] ['banana', 'bee', 'butter', 'canary melon', 'gold', 'lemon', 'pineapple', 'sunflower'] # Read data from HDFS : fruits = sc . textFile ( 'hdfs://url:9000/pathname/fruits.txt' ) fruits . collect () RDD operations \u00b6 # map fruitsReversed = fruits . map ( lambda fruit : fruit [:: - 1 ]) # fruitsReversed = fruits.map(lambda fruit: fruit[::-1]) fruitsReversed . persist () # try changing the file and re-execute with and without cache print ( fruitsReversed . collect ()) # What happens when you uncomment the first line and run the whole program again with cache()? ['elppab', 'ananab', 'nolem yranac', 'parg', 'nomel', 'egnaro', 'elppaenip', 'yrrebwarts'] # filter shortFruits = fruits . filter ( lambda fruit : len ( fruit ) <= 5 ) print ( shortFruits . collect ()) ['grap', 'lemon'] # flatMap characters = fruits . flatMap ( lambda fruit : list ( fruit )) print ( characters . collect ()) ['b', 'a', 'p', 'p', 'l', 'e', 'b', 'a', 'n', 'a', 'n', 'a', 'c', 'a', 'n', 'a', 'r', 'y', ' ', 'm', 'e', 'l', 'o', 'n', 'g', 'r', 'a', 'p', 'l', 'e', 'm', 'o', 'n', 'o', 'r', 'a', 'n', 'g', 'e', 'p', 'i', 'n', 'e', 'a', 'p', 'p', 'l', 'e', 's', 't', 'r', 'a', 'w', 'b', 'e', 'r', 'r', 'y'] # union fruitsAndYellowThings = fruits . union ( yellowThings ) print ( fruitsAndYellowThings . collect ()) ['bapple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry', 'banana', 'bee', 'butter', 'canary melon', 'gold', 'lemon', 'pineapple', 'sunflower'] # intersection yellowFruits = fruits . intersection ( yellowThings ) print ( yellowFruits . collect ()) ['pineapple', 'canary melon', 'lemon', 'banana'] # distinct distinctFruitsAndYellowThings = fruitsAndYellowThings . distinct () print ( distinctFruitsAndYellowThings . collect ()) ['orange', 'pineapple', 'canary melon', 'lemon', 'bee', 'banana', 'butter', 'gold', 'sunflower', 'apple', 'grap', 'strawberry'] RDD actions \u00b6 Following are examples of some of the common actions available. For a detailed list, see RDD Actions . Run some transformations below to understand this better. Place the cursor in the cell and press SHIFT + ENTER . # collect fruitsArray = fruits . collect () yellowThingsArray = yellowThings . collect () print ( fruitsArray ) ['apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry'] # count numFruits = fruits . count () print ( numFruits ) 8 # take first3Fruits = fruits . take ( 3 ) print ( first3Fruits ) ['apple', 'banana', 'canary melon'] # reduce letterSet = fruits . map ( lambda fruit : set ( fruit )) . reduce ( lambda x , y : x . union ( y )) print ( letterSet ) {'o', 'r', 'a', 'i', 'p', 'g', 'c', ' ', 'l', 'y', 'e', 'w', 'n', 'b', 'm', 't', 's'} letterSet = fruits . flatMap ( lambda fruit : list ( fruit )) . distinct () . collect () print ( letterSet ) ['p', 'l', 'b', 'c', 'r', 'y', 'g', 'i', 's', 'a', 'e', 'n', ' ', 'm', 'o', 't', 'w'] Closure \u00b6 counter = 0 rdd = sc . parallelize ( range ( 10 )) # Wrong: Don't do this!! def increment_counter ( x ): global counter counter += x print ( rdd . collect ()) rdd . foreach ( increment_counter ) print ( counter ) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 0 rdd = sc . parallelize ( range ( 10 )) accum = sc . accumulator ( 0 ) def g ( x ): global accum accum += x a = rdd . foreach ( g ) print ( accum . value ) -45 rdd = sc . parallelize ( range ( 10 )) accum = sc . accumulator ( 0 ) def g ( x ): global accum accum += x return x * x a = rdd . map ( g ) print ( accum . value ) #print(a.reduce(lambda x, y: x+y)) a . cache () tmp = a . count () print ( accum . value ) print ( rdd . reduce ( lambda x , y : x + y )) tmp = a . count () print ( accum . value ) print ( rdd . reduce ( lambda x , y : x + y )) 0 45 45 45 45 Computing Pi using Monte Carlo simulation \u00b6 # From the official spark examples. import random import time partitions = 1000 n = 1000 * partitions def f ( _ ): x = random . random () y = random . random () return 1 if x ** 2 + y ** 2 < 1 else 0 count = sc . parallelize ( range ( 1 , n + 1 ), partitions ) \\ . map ( f ) . sum () print ( \"Pi is roughly\" , 4.0 * count / n ) Pi is roughly 3.140944 # Example: glom import sys import random def f ( _ ): random . seed ( time . time ()) return random . random () a = sc . parallelize ( range ( 0 , 100 ), 10 ) print ( a . collect ()) print ( a . glom () . collect ()) print ( a . map ( f ) . glom () . collect ()) # Weird behavior: Initially, random numbers are synched across all workers, but will get # out-of-sync after a large (e.g, 1000000) number of random numbers have been generated. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [50, 51, 52, 53, 54, 55, 56, 57, 58, 59], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74, 75, 76, 77, 78, 79], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89], [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]] [[0.6608713426170987, 0.698767024318554, 0.1874105777790005, 0.7623702078433652, 0.8851287594440702, 0.31740294580255735, 0.19323310102732394, 0.42450071105921683, 0.5933781451859748, 0.7458943680790939], [0.7261502175930336, 0.22659503054053598, 0.9192074261481535, 0.4774662604141523, 0.7974422880272903, 0.2584976474338707, 0.6055611352765481, 0.5244790798752513, 0.6861813792912159, 0.5652815222674437], [0.27860057141024697, 0.27383515025078553, 0.9176819782462265, 0.417689753313761, 0.6135860183360143, 0.8162090147099693, 0.39224804876974406, 0.543173888187219, 0.3098912544023783, 0.633182881742779], [0.0952563896474653, 0.7477071810186972, 0.5004564582092008, 0.2614834043253954, 0.5982982446751687, 0.8544002333592715, 0.26000819037953216, 0.40177311792144454, 0.03851083747397188, 0.05167636277510712], [0.9726302497724043, 0.42432064255976365, 0.9305610323744404, 0.771694551386715, 0.6789841281422876, 0.9487832709253969, 0.4943030306526911, 0.22888583384514705, 0.6165263440265218, 0.8948635092093183], [0.9816006872849989, 0.3233518004555158, 0.6660672115030636, 0.9921564654020117, 0.9574487554669273, 0.00033642413291157247, 0.5729463981674527, 0.63676146970985, 0.1068707761119706, 0.4974835849045728], [0.6877782810075579, 0.11000878013616322, 0.6630366287015564, 0.0320757478156235, 0.5550374523078817, 0.11429763248899893, 0.7746616174182379, 0.6935564378314162, 0.6081187039755812, 0.3594774747771995], [0.3402744125431225, 0.8533066685831103, 0.18605963113570156, 0.9700428171414653, 0.9046533776474858, 0.4199976147427207, 0.01833313615444565, 0.5003118405702941, 0.9167261953361863, 0.6543553598701435], [0.5463089308369264, 0.19187434980340723, 0.5311179490604816, 0.7210872364087648, 0.25848050944241396, 0.9138829006068386, 0.5015098582184656, 0.9245322749204768, 0.4746635193819774, 0.733561516539988], [0.5924804586325896, 0.44157691425623313, 0.06474182310396659, 0.3705313104712945, 0.218280453275444, 0.911250263493956, 0.4908690024649712, 0.031427016100674665, 0.3749922950484815, 0.29534800562581187]] # Example: mapPartition and mapPartitionWithIndex a = sc . parallelize ( range ( 0 , 20 ), 4 ) print ( a . glom () . collect ()) def f ( it ): s = 0 for i in it : s += i yield s print ( a . mapPartitions ( f ) . collect ()) def f ( index , it ): s = index for i in it : s += i yield s print ( a . mapPartitionsWithIndex ( f ) . collect ()) [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]] [0, 1, 3, 6, 10, 5, 11, 18, 26, 35, 10, 21, 33, 46, 60, 15, 31, 48, 66, 85] [0, 1, 3, 6, 10, 6, 12, 19, 27, 36, 12, 23, 35, 48, 62, 18, 34, 51, 69, 88] # Correct version import random import time partitions = 1000 n = 1000 * partitions seed = time . time () def f ( index , it ): random . seed ( index + seed ) for i in it : x = random . random () y = random . random () yield 1 if x ** 2 + y ** 2 < 1 else 0 count = sc . parallelize ( range ( 1 , n + 1 ), partitions ) \\ . mapPartitionsWithIndex ( f ) . sum () print ( \"Pi is roughly\" , 4.0 * count / n ) Pi is roughly 3.141832 Closure and Persistence \u00b6 # RDD variables are references A = sc . parallelize ( range ( 10 )) B = A . map ( lambda x : x * 2 ) A = B . map ( lambda x : x + 1 ) A . take ( 10 ) [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] # Linear-time selection data = [ 34 , 67 , 21 , 56 , 47 , 89 , 12 , 44 , 74 , 43 , 26 ] A = sc . parallelize ( data , 2 ) k = 4 while True : x = A . first () A1 = A . filter ( lambda z : z < x ) A2 = A . filter ( lambda z : z > x ) A1 . cache () A2 . cache () mid = A1 . count () if mid == k : print ( x ) break if k < mid : A = A1 else : A = A2 k = k - mid - 1 43 sorted ( data ) [12, 21, 26, 34, 43, 44, 47, 56, 67, 74, 89] A = sc . parallelize ( range ( 10 )) x = 5 B = A . filter ( lambda z : z < x ) # B.cache() print ( B . count ()) x = 3 print ( B . count ()) 5 5 A = sc . parallelize ( range ( 10 )) x = 5 B = A . filter ( lambda z : z < x ) # B.cache() B . unpersist () # print(B.take(10)) print ( B . collect ()) x = 3 #print(B.take(10)) print ( B . collect ()) # collect() doesn't always re-collect data - bad design! # Always use take() instead of collect() [0, 1, 2, 3, 4] [0, 1, 2, 3, 4] Key-Value Pairs \u00b6 # reduceByKey numFruitsByLength = fruits . map ( lambda fruit : ( len ( fruit ), 1 )) . reduceByKey ( lambda x , y : x + y ) print ( numFruitsByLength . take ( 10 )) from operator import add lines = sc . textFile ( '../data/course.txt' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) print ( counts . sortByKey () . take ( 20 )) print ( counts . sortBy ( lambda x : x [ 1 ], False ) . take ( 20 )) # Join simple example products = sc . parallelize ([( 1 , \"Apple\" ), ( 2 , \"Orange\" ), ( 3 , \"TV\" ), ( 5 , \"Computer\" )]) #trans = sc.parallelize([(1, 134, \"OK\"), (3, 34, \"OK\"), (5, 162, \"Error\"), (1, 135, \"OK\"), (2, 53, \"OK\"), (1, 45, \"OK\")]) trans = sc . parallelize ([( 1 , ( 134 , \"OK\" )), ( 3 , ( 34 , \"OK\" )), ( 5 , ( 162 , \"Error\" )), ( 1 , ( 135 , \"OK\" )), ( 2 , ( 53 , \"OK\" )), ( 1 , ( 45 , \"OK\" ))]) print ( products . join ( trans ) . take ( 20 )) K-means clustering \u00b6 import numpy as np def parseVector ( line ): return np . array ([ float ( x ) for x in line . split ()]) def closestPoint ( p , centers ): bestIndex = 0 closest = float ( \"+inf\" ) for i in range ( len ( centers )): tempDist = np . sum (( p - centers [ i ]) ** 2 ) if tempDist < closest : closest = tempDist bestIndex = i return bestIndex # The data file can be downloaded at http://www.cse.ust.hk/msbd5003/data/kmeans_data.txt lines = sc . textFile ( '../data/kmeans_data.txt' , 5 ) # The data file can be downloaded at http://www.cse.ust.hk/msbd5003/data/kmeans_bigdata.txt # lines = sc.textFile('../data/kmeans_bigdata.txt', 5) # lines is an RDD of strings K = 3 convergeDist = 0.01 # terminate algorithm when the total distance from old center to new centers is less than this value data = lines . map ( parseVector ) . cache () # data is an RDD of arrays kCenters = data . takeSample ( False , K , 1 ) # intial centers as a list of arrays tempDist = 1.0 # total distance from old centers to new centers while tempDist > convergeDist : closest = data . map ( lambda p : ( closestPoint ( p , kCenters ), ( p , 1 ))) # for each point in data, find its closest center # closest is an RDD of tuples (index of closest center, (point, 1)) pointStats = closest . reduceByKey ( lambda p1 , p2 : ( p1 [ 0 ] + p2 [ 0 ], p1 [ 1 ] + p2 [ 1 ])) # pointStats is an RDD of tuples (index of center, # (array of sums of coordinates, total number of points assigned)) newCenters = pointStats . map ( lambda st : ( st [ 0 ], st [ 1 ][ 0 ] / st [ 1 ][ 1 ])) . collect () # compute the new centers tempDist = sum ( np . sum (( kCenters [ i ] - p ) ** 2 ) for ( i , p ) in newCenters ) # compute the total disctance from old centers to new centers for ( i , p ) in newCenters : kCenters [ i ] = p print ( \"Final centers: \" , kCenters ) PageRank \u00b6 import re from operator import add def computeContribs ( urls , rank ): # Calculates URL contributions to the rank of other URLs. num_urls = len ( urls ) for url in urls : yield ( url , rank / num_urls ) def parseNeighbors ( urls ): # Parses a urls pair string into urls pair.\"\"\" parts = urls . split ( ' ' ) return parts [ 0 ], parts [ 1 ] # Loads in input file. It should be in format of: # URL neighbor URL # URL neighbor URL # URL neighbor URL # ... # The data file can be downloaded at http://www.cse.ust.hk/msbd5003/data/* lines = sc . textFile ( \"/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/pagerank_data.txt\" , 2 ) # lines = sc.textFile(\"../data/dblp.in\", 5) numOfIterations = 10 # Loads all URLs from input file and initialize their neighbors. links = lines . map ( lambda urls : parseNeighbors ( urls )) \\ . groupByKey () # Loads all URLs with other URL(s) link to from input file # and initialize ranks of them to one. ranks = links . mapValues ( lambda neighbors : 1.0 ) print ( 'ranks' , ranks . collect ()) print ( 'links' , links . collect ()) # Calculates and updates URL ranks continuously using PageRank algorithm. for iteration in range ( numOfIterations ): # Calculates URL contributions to the rank of other URLs. contribs = links . join ( ranks ) \\ . flatMap ( lambda url_urls_rank : computeContribs ( url_urls_rank [ 1 ][ 0 ], url_urls_rank [ 1 ][ 1 ])) # After the join, each element in the RDD is of the form # (url, (list of neighbor urls, rank)) # Re-calculates URL ranks based on neighbor contributions. # ranks = contribs.reduceByKey(add).mapValues(lambda rank: rank * 0.85 + 0.15) ranks = contribs . reduceByKey ( add ) . map ( lambda t : ( t [ 0 ], t [ 1 ] * 0.85 + 0.15 )) print ( ranks . top ( 5 , lambda x : x [ 1 ])) ranks [('1', 1.0), ('4', 1.0), ('2', 1.0), ('3', 1.0)] links [('1', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a20ef0>), ('4', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a20a58>), ('2', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a20780>), ('3', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a207f0>)] [('1', 1.2981882732854677), ('4', 0.9999999999999998), ('3', 0.9999999999999998), ('2', 0.7018117267145316)] Join vs. Broadcast Variables \u00b6 products = sc . parallelize ([( 1 , \"Apple\" ), ( 2 , \"Orange\" ), ( 3 , \"TV\" ), ( 5 , \"Computer\" )]) trans = sc . parallelize ([( 1 , ( 134 , \"OK\" )), ( 3 , ( 34 , \"OK\" )), ( 5 , ( 162 , \"Error\" )), ( 1 , ( 135 , \"OK\" )), ( 2 , ( 53 , \"OK\" )), ( 1 , ( 45 , \"OK\" ))]) print ( trans . join ( products ) . take ( 20 )) products = { 1 : \"Apple\" , 2 : \"Orange\" , 3 : \"TV\" , 5 : \"Computer\" } trans = sc . parallelize ([( 1 , ( 134 , \"OK\" )), ( 3 , ( 34 , \"OK\" )), ( 5 , ( 162 , \"Error\" )), ( 1 , ( 135 , \"OK\" )), ( 2 , ( 53 , \"OK\" )), ( 1 , ( 45 , \"OK\" ))]) broadcasted_products = sc . broadcast ( products ) results = trans . map ( lambda x : ( x [ 0 ], broadcasted_products . value [ x [ 0 ]], x [ 1 ])) # results = trans.map(lambda x: (x[0], products[x[0]], x[1])) print ( results . take ( 20 ))","title":"Rdd"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#how-do-i-make-an-rdd","text":"RDDs can be created from stable storage or by transforming other RDDs. Run the cells below to create RDDs from files on the local drive. All data files can be downloaded from https://www.cse.ust.hk/msbd5003/data/ For example, https://www.cse.ust.hk/msbd5003/data/fruits.txt # Read data from local file system: print ( sc . version ) fruits = sc . textFile ( '../data/fruits.txt' ) yellowThings = sc . textFile ( '../data/yellowthings.txt' ) print ( fruits . collect ()) print ( yellowThings . collect ()) 3.0.0 ['apple', 'banana', 'canary melon', 'grape', 'lemon', 'orange', 'pineapple', 'strawberry'] ['banana', 'bee', 'butter', 'canary melon', 'gold', 'lemon', 'pineapple', 'sunflower'] # Read data from HDFS : fruits = sc . textFile ( 'hdfs://url:9000/pathname/fruits.txt' ) fruits . collect ()","title":"How do I make an RDD?"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#rdd-operations","text":"# map fruitsReversed = fruits . map ( lambda fruit : fruit [:: - 1 ]) # fruitsReversed = fruits.map(lambda fruit: fruit[::-1]) fruitsReversed . persist () # try changing the file and re-execute with and without cache print ( fruitsReversed . collect ()) # What happens when you uncomment the first line and run the whole program again with cache()? ['elppab', 'ananab', 'nolem yranac', 'parg', 'nomel', 'egnaro', 'elppaenip', 'yrrebwarts'] # filter shortFruits = fruits . filter ( lambda fruit : len ( fruit ) <= 5 ) print ( shortFruits . collect ()) ['grap', 'lemon'] # flatMap characters = fruits . flatMap ( lambda fruit : list ( fruit )) print ( characters . collect ()) ['b', 'a', 'p', 'p', 'l', 'e', 'b', 'a', 'n', 'a', 'n', 'a', 'c', 'a', 'n', 'a', 'r', 'y', ' ', 'm', 'e', 'l', 'o', 'n', 'g', 'r', 'a', 'p', 'l', 'e', 'm', 'o', 'n', 'o', 'r', 'a', 'n', 'g', 'e', 'p', 'i', 'n', 'e', 'a', 'p', 'p', 'l', 'e', 's', 't', 'r', 'a', 'w', 'b', 'e', 'r', 'r', 'y'] # union fruitsAndYellowThings = fruits . union ( yellowThings ) print ( fruitsAndYellowThings . collect ()) ['bapple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry', 'banana', 'bee', 'butter', 'canary melon', 'gold', 'lemon', 'pineapple', 'sunflower'] # intersection yellowFruits = fruits . intersection ( yellowThings ) print ( yellowFruits . collect ()) ['pineapple', 'canary melon', 'lemon', 'banana'] # distinct distinctFruitsAndYellowThings = fruitsAndYellowThings . distinct () print ( distinctFruitsAndYellowThings . collect ()) ['orange', 'pineapple', 'canary melon', 'lemon', 'bee', 'banana', 'butter', 'gold', 'sunflower', 'apple', 'grap', 'strawberry']","title":"RDD operations"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#rdd-actions","text":"Following are examples of some of the common actions available. For a detailed list, see RDD Actions . Run some transformations below to understand this better. Place the cursor in the cell and press SHIFT + ENTER . # collect fruitsArray = fruits . collect () yellowThingsArray = yellowThings . collect () print ( fruitsArray ) ['apple', 'banana', 'canary melon', 'grap', 'lemon', 'orange', 'pineapple', 'strawberry'] # count numFruits = fruits . count () print ( numFruits ) 8 # take first3Fruits = fruits . take ( 3 ) print ( first3Fruits ) ['apple', 'banana', 'canary melon'] # reduce letterSet = fruits . map ( lambda fruit : set ( fruit )) . reduce ( lambda x , y : x . union ( y )) print ( letterSet ) {'o', 'r', 'a', 'i', 'p', 'g', 'c', ' ', 'l', 'y', 'e', 'w', 'n', 'b', 'm', 't', 's'} letterSet = fruits . flatMap ( lambda fruit : list ( fruit )) . distinct () . collect () print ( letterSet ) ['p', 'l', 'b', 'c', 'r', 'y', 'g', 'i', 's', 'a', 'e', 'n', ' ', 'm', 'o', 't', 'w']","title":"RDD actions"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#closure","text":"counter = 0 rdd = sc . parallelize ( range ( 10 )) # Wrong: Don't do this!! def increment_counter ( x ): global counter counter += x print ( rdd . collect ()) rdd . foreach ( increment_counter ) print ( counter ) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 0 rdd = sc . parallelize ( range ( 10 )) accum = sc . accumulator ( 0 ) def g ( x ): global accum accum += x a = rdd . foreach ( g ) print ( accum . value ) -45 rdd = sc . parallelize ( range ( 10 )) accum = sc . accumulator ( 0 ) def g ( x ): global accum accum += x return x * x a = rdd . map ( g ) print ( accum . value ) #print(a.reduce(lambda x, y: x+y)) a . cache () tmp = a . count () print ( accum . value ) print ( rdd . reduce ( lambda x , y : x + y )) tmp = a . count () print ( accum . value ) print ( rdd . reduce ( lambda x , y : x + y )) 0 45 45 45 45","title":"Closure"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#computing-pi-using-monte-carlo-simulation","text":"# From the official spark examples. import random import time partitions = 1000 n = 1000 * partitions def f ( _ ): x = random . random () y = random . random () return 1 if x ** 2 + y ** 2 < 1 else 0 count = sc . parallelize ( range ( 1 , n + 1 ), partitions ) \\ . map ( f ) . sum () print ( \"Pi is roughly\" , 4.0 * count / n ) Pi is roughly 3.140944 # Example: glom import sys import random def f ( _ ): random . seed ( time . time ()) return random . random () a = sc . parallelize ( range ( 0 , 100 ), 10 ) print ( a . collect ()) print ( a . glom () . collect ()) print ( a . map ( f ) . glom () . collect ()) # Weird behavior: Initially, random numbers are synched across all workers, but will get # out-of-sync after a large (e.g, 1000000) number of random numbers have been generated. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [50, 51, 52, 53, 54, 55, 56, 57, 58, 59], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [70, 71, 72, 73, 74, 75, 76, 77, 78, 79], [80, 81, 82, 83, 84, 85, 86, 87, 88, 89], [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]] [[0.6608713426170987, 0.698767024318554, 0.1874105777790005, 0.7623702078433652, 0.8851287594440702, 0.31740294580255735, 0.19323310102732394, 0.42450071105921683, 0.5933781451859748, 0.7458943680790939], [0.7261502175930336, 0.22659503054053598, 0.9192074261481535, 0.4774662604141523, 0.7974422880272903, 0.2584976474338707, 0.6055611352765481, 0.5244790798752513, 0.6861813792912159, 0.5652815222674437], [0.27860057141024697, 0.27383515025078553, 0.9176819782462265, 0.417689753313761, 0.6135860183360143, 0.8162090147099693, 0.39224804876974406, 0.543173888187219, 0.3098912544023783, 0.633182881742779], [0.0952563896474653, 0.7477071810186972, 0.5004564582092008, 0.2614834043253954, 0.5982982446751687, 0.8544002333592715, 0.26000819037953216, 0.40177311792144454, 0.03851083747397188, 0.05167636277510712], [0.9726302497724043, 0.42432064255976365, 0.9305610323744404, 0.771694551386715, 0.6789841281422876, 0.9487832709253969, 0.4943030306526911, 0.22888583384514705, 0.6165263440265218, 0.8948635092093183], [0.9816006872849989, 0.3233518004555158, 0.6660672115030636, 0.9921564654020117, 0.9574487554669273, 0.00033642413291157247, 0.5729463981674527, 0.63676146970985, 0.1068707761119706, 0.4974835849045728], [0.6877782810075579, 0.11000878013616322, 0.6630366287015564, 0.0320757478156235, 0.5550374523078817, 0.11429763248899893, 0.7746616174182379, 0.6935564378314162, 0.6081187039755812, 0.3594774747771995], [0.3402744125431225, 0.8533066685831103, 0.18605963113570156, 0.9700428171414653, 0.9046533776474858, 0.4199976147427207, 0.01833313615444565, 0.5003118405702941, 0.9167261953361863, 0.6543553598701435], [0.5463089308369264, 0.19187434980340723, 0.5311179490604816, 0.7210872364087648, 0.25848050944241396, 0.9138829006068386, 0.5015098582184656, 0.9245322749204768, 0.4746635193819774, 0.733561516539988], [0.5924804586325896, 0.44157691425623313, 0.06474182310396659, 0.3705313104712945, 0.218280453275444, 0.911250263493956, 0.4908690024649712, 0.031427016100674665, 0.3749922950484815, 0.29534800562581187]] # Example: mapPartition and mapPartitionWithIndex a = sc . parallelize ( range ( 0 , 20 ), 4 ) print ( a . glom () . collect ()) def f ( it ): s = 0 for i in it : s += i yield s print ( a . mapPartitions ( f ) . collect ()) def f ( index , it ): s = index for i in it : s += i yield s print ( a . mapPartitionsWithIndex ( f ) . collect ()) [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]] [0, 1, 3, 6, 10, 5, 11, 18, 26, 35, 10, 21, 33, 46, 60, 15, 31, 48, 66, 85] [0, 1, 3, 6, 10, 6, 12, 19, 27, 36, 12, 23, 35, 48, 62, 18, 34, 51, 69, 88] # Correct version import random import time partitions = 1000 n = 1000 * partitions seed = time . time () def f ( index , it ): random . seed ( index + seed ) for i in it : x = random . random () y = random . random () yield 1 if x ** 2 + y ** 2 < 1 else 0 count = sc . parallelize ( range ( 1 , n + 1 ), partitions ) \\ . mapPartitionsWithIndex ( f ) . sum () print ( \"Pi is roughly\" , 4.0 * count / n ) Pi is roughly 3.141832","title":"Computing Pi using Monte Carlo simulation"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#closure-and-persistence","text":"# RDD variables are references A = sc . parallelize ( range ( 10 )) B = A . map ( lambda x : x * 2 ) A = B . map ( lambda x : x + 1 ) A . take ( 10 ) [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] # Linear-time selection data = [ 34 , 67 , 21 , 56 , 47 , 89 , 12 , 44 , 74 , 43 , 26 ] A = sc . parallelize ( data , 2 ) k = 4 while True : x = A . first () A1 = A . filter ( lambda z : z < x ) A2 = A . filter ( lambda z : z > x ) A1 . cache () A2 . cache () mid = A1 . count () if mid == k : print ( x ) break if k < mid : A = A1 else : A = A2 k = k - mid - 1 43 sorted ( data ) [12, 21, 26, 34, 43, 44, 47, 56, 67, 74, 89] A = sc . parallelize ( range ( 10 )) x = 5 B = A . filter ( lambda z : z < x ) # B.cache() print ( B . count ()) x = 3 print ( B . count ()) 5 5 A = sc . parallelize ( range ( 10 )) x = 5 B = A . filter ( lambda z : z < x ) # B.cache() B . unpersist () # print(B.take(10)) print ( B . collect ()) x = 3 #print(B.take(10)) print ( B . collect ()) # collect() doesn't always re-collect data - bad design! # Always use take() instead of collect() [0, 1, 2, 3, 4] [0, 1, 2, 3, 4]","title":"Closure and Persistence"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#key-value-pairs","text":"# reduceByKey numFruitsByLength = fruits . map ( lambda fruit : ( len ( fruit ), 1 )) . reduceByKey ( lambda x , y : x + y ) print ( numFruitsByLength . take ( 10 )) from operator import add lines = sc . textFile ( '../data/course.txt' ) counts = lines . flatMap ( lambda x : x . split ()) \\ . map ( lambda x : ( x , 1 )) \\ . reduceByKey ( add ) print ( counts . sortByKey () . take ( 20 )) print ( counts . sortBy ( lambda x : x [ 1 ], False ) . take ( 20 )) # Join simple example products = sc . parallelize ([( 1 , \"Apple\" ), ( 2 , \"Orange\" ), ( 3 , \"TV\" ), ( 5 , \"Computer\" )]) #trans = sc.parallelize([(1, 134, \"OK\"), (3, 34, \"OK\"), (5, 162, \"Error\"), (1, 135, \"OK\"), (2, 53, \"OK\"), (1, 45, \"OK\")]) trans = sc . parallelize ([( 1 , ( 134 , \"OK\" )), ( 3 , ( 34 , \"OK\" )), ( 5 , ( 162 , \"Error\" )), ( 1 , ( 135 , \"OK\" )), ( 2 , ( 53 , \"OK\" )), ( 1 , ( 45 , \"OK\" ))]) print ( products . join ( trans ) . take ( 20 ))","title":"Key-Value Pairs"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#k-means-clustering","text":"import numpy as np def parseVector ( line ): return np . array ([ float ( x ) for x in line . split ()]) def closestPoint ( p , centers ): bestIndex = 0 closest = float ( \"+inf\" ) for i in range ( len ( centers )): tempDist = np . sum (( p - centers [ i ]) ** 2 ) if tempDist < closest : closest = tempDist bestIndex = i return bestIndex # The data file can be downloaded at http://www.cse.ust.hk/msbd5003/data/kmeans_data.txt lines = sc . textFile ( '../data/kmeans_data.txt' , 5 ) # The data file can be downloaded at http://www.cse.ust.hk/msbd5003/data/kmeans_bigdata.txt # lines = sc.textFile('../data/kmeans_bigdata.txt', 5) # lines is an RDD of strings K = 3 convergeDist = 0.01 # terminate algorithm when the total distance from old center to new centers is less than this value data = lines . map ( parseVector ) . cache () # data is an RDD of arrays kCenters = data . takeSample ( False , K , 1 ) # intial centers as a list of arrays tempDist = 1.0 # total distance from old centers to new centers while tempDist > convergeDist : closest = data . map ( lambda p : ( closestPoint ( p , kCenters ), ( p , 1 ))) # for each point in data, find its closest center # closest is an RDD of tuples (index of closest center, (point, 1)) pointStats = closest . reduceByKey ( lambda p1 , p2 : ( p1 [ 0 ] + p2 [ 0 ], p1 [ 1 ] + p2 [ 1 ])) # pointStats is an RDD of tuples (index of center, # (array of sums of coordinates, total number of points assigned)) newCenters = pointStats . map ( lambda st : ( st [ 0 ], st [ 1 ][ 0 ] / st [ 1 ][ 1 ])) . collect () # compute the new centers tempDist = sum ( np . sum (( kCenters [ i ] - p ) ** 2 ) for ( i , p ) in newCenters ) # compute the total disctance from old centers to new centers for ( i , p ) in newCenters : kCenters [ i ] = p print ( \"Final centers: \" , kCenters )","title":"K-means clustering"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#pagerank","text":"import re from operator import add def computeContribs ( urls , rank ): # Calculates URL contributions to the rank of other URLs. num_urls = len ( urls ) for url in urls : yield ( url , rank / num_urls ) def parseNeighbors ( urls ): # Parses a urls pair string into urls pair.\"\"\" parts = urls . split ( ' ' ) return parts [ 0 ], parts [ 1 ] # Loads in input file. It should be in format of: # URL neighbor URL # URL neighbor URL # URL neighbor URL # ... # The data file can be downloaded at http://www.cse.ust.hk/msbd5003/data/* lines = sc . textFile ( \"/content/drive/My Drive/\u8bfe\u7a0b/HKUST/MSBD5003/homeworks/hw2/pagerank_data.txt\" , 2 ) # lines = sc.textFile(\"../data/dblp.in\", 5) numOfIterations = 10 # Loads all URLs from input file and initialize their neighbors. links = lines . map ( lambda urls : parseNeighbors ( urls )) \\ . groupByKey () # Loads all URLs with other URL(s) link to from input file # and initialize ranks of them to one. ranks = links . mapValues ( lambda neighbors : 1.0 ) print ( 'ranks' , ranks . collect ()) print ( 'links' , links . collect ()) # Calculates and updates URL ranks continuously using PageRank algorithm. for iteration in range ( numOfIterations ): # Calculates URL contributions to the rank of other URLs. contribs = links . join ( ranks ) \\ . flatMap ( lambda url_urls_rank : computeContribs ( url_urls_rank [ 1 ][ 0 ], url_urls_rank [ 1 ][ 1 ])) # After the join, each element in the RDD is of the form # (url, (list of neighbor urls, rank)) # Re-calculates URL ranks based on neighbor contributions. # ranks = contribs.reduceByKey(add).mapValues(lambda rank: rank * 0.85 + 0.15) ranks = contribs . reduceByKey ( add ) . map ( lambda t : ( t [ 0 ], t [ 1 ] * 0.85 + 0.15 )) print ( ranks . top ( 5 , lambda x : x [ 1 ])) ranks [('1', 1.0), ('4', 1.0), ('2', 1.0), ('3', 1.0)] links [('1', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a20ef0>), ('4', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a20a58>), ('2', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a20780>), ('3', <pyspark.resultiterable.ResultIterable object at 0x7f8b12a207f0>)] [('1', 1.2981882732854677), ('4', 0.9999999999999998), ('3', 0.9999999999999998), ('2', 0.7018117267145316)]","title":"PageRank"},{"location":"MSBD5003/notebooks%20in%20class/rdd/#join-vs-broadcast-variables","text":"products = sc . parallelize ([( 1 , \"Apple\" ), ( 2 , \"Orange\" ), ( 3 , \"TV\" ), ( 5 , \"Computer\" )]) trans = sc . parallelize ([( 1 , ( 134 , \"OK\" )), ( 3 , ( 34 , \"OK\" )), ( 5 , ( 162 , \"Error\" )), ( 1 , ( 135 , \"OK\" )), ( 2 , ( 53 , \"OK\" )), ( 1 , ( 45 , \"OK\" ))]) print ( trans . join ( products ) . take ( 20 )) products = { 1 : \"Apple\" , 2 : \"Orange\" , 3 : \"TV\" , 5 : \"Computer\" } trans = sc . parallelize ([( 1 , ( 134 , \"OK\" )), ( 3 , ( 34 , \"OK\" )), ( 5 , ( 162 , \"Error\" )), ( 1 , ( 135 , \"OK\" )), ( 2 , ( 53 , \"OK\" )), ( 1 , ( 45 , \"OK\" ))]) broadcasted_products = sc . broadcast ( products ) results = trans . map ( lambda x : ( x [ 0 ], broadcasted_products . value [ x [ 0 ]], x [ 1 ])) # results = trans.map(lambda x: (x[0], products[x[0]], x[1])) print ( results . take ( 20 ))","title":"Join vs. Broadcast Variables"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/","text":"! pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 56kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 39.0MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=2f5ff611b6f601d04626ac58c802aeb82b7faa0f99da467b2288b8fc05a7d419 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.context import SparkContext from pyspark.sql.session import SparkSession sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) Dataframe operations \u00b6 from pyspark.sql import Row row = Row ( name = \"Alice\" , age = 11 ) print ( row ) print ( row [ 'name' ], row [ 'age' ]) print ( row . name , row . age ) row = Row ( name = \"Alice\" , age = 11 , count = 1 ) print ( row . count ) print ( row [ 'count' ]) Row(name='Alice', age=11) Alice 11 Alice 11 <built-in method count of Row object at 0x7f3384ce6e08> 1 ! wget https : // www . cse . ust . hk / msbd5003 / data / building . csv --2020-10-06 11:49:18-- https://www.cse.ust.hk/msbd5003/data/building.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 544 [text/plain] Saving to: \u2018building.csv.1\u2019 building.csv.1 100%[===================>] 544 --.-KB/s in 0s 2020-10-06 11:49:20 (30.9 MB/s) - \u2018building.csv.1\u2019 saved [544/544] # Data file at https://www.cse.ust.hk/msbd5003/data/building.csv df = spark . read . csv ( 'building.csv' , header = True , inferSchema = True ) # show the content of the dataframe df . show () +----------+-----------+-----------+-----------+------------+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country| +----------+-----------+-----------+-----------+------------+ | 1| M1| 25| AC1000| USA| | 2| M2| 27| FN39TG| France| | 3| M3| 28| JDNS77| Brazil| | 4| M4| 17| GG1919| Finland| | 5| M5| 3| ACMAX22| Hong Kong| | 6| M6| 9| AC1000| Singapore| | 7| M7| 13| FN39TG|South Africa| | 8| M8| 25| JDNS77| Australia| | 9| M9| 11| GG1919| Mexico| | 10| M10| 23| ACMAX22| China| | 11| M11| 14| AC1000| Belgium| | 12| M12| 26| FN39TG| Finland| | 13| M13| 25| JDNS77|Saudi Arabia| | 14| M14| 17| GG1919| Germany| | 15| M15| 19| ACMAX22| Israel| | 16| M16| 23| AC1000| Turkey| | 17| M17| 11| FN39TG| Egypt| | 18| M18| 25| JDNS77| Indonesia| | 19| M19| 14| GG1919| Canada| | 20| M20| 19| ACMAX22| Argentina| +----------+-----------+-----------+-----------+------------+ # Print the dataframe schema in a tree format df . printSchema () root |-- BuildingID: integer (nullable = true) |-- BuildingMgr: string (nullable = true) |-- BuildingAge: integer (nullable = true) |-- HVACproduct: string (nullable = true) |-- Country: string (nullable = true) # Create an RDD from the dataframe dfrdd = df . rdd dfrdd . take ( 3 ) [Row(BuildingID=1, BuildingMgr='M1', BuildingAge=25, HVACproduct='AC1000', Country='USA'), Row(BuildingID=2, BuildingMgr='M2', BuildingAge=27, HVACproduct='FN39TG', Country='France'), Row(BuildingID=3, BuildingMgr='M3', BuildingAge=28, HVACproduct='JDNS77', Country='Brazil')] # Retrieve specific columns from the dataframe df . select ( 'BuildingID' , 'Country' ) . show () +----------+------------+ |BuildingID| Country| +----------+------------+ | 1| USA| | 2| France| | 3| Brazil| | 4| Finland| | 5| Hong Kong| | 6| Singapore| | 7|South Africa| | 8| Australia| | 9| Mexico| | 10| China| | 11| Belgium| | 12| Finland| | 13|Saudi Arabia| | 14| Germany| | 15| Israel| | 16| Turkey| | 17| Egypt| | 18| Indonesia| | 19| Canada| | 20| Argentina| +----------+------------+ from pyspark.sql.functions import * df . where ( \"Country<'USA'\" ) . select ( 'BuildingID' , lit ( 'OK' )) . show () +----------+---+ |BuildingID| OK| +----------+---+ | 2| OK| | 3| OK| | 4| OK| | 5| OK| | 6| OK| | 7| OK| | 8| OK| | 9| OK| | 10| OK| | 11| OK| | 12| OK| | 13| OK| | 14| OK| | 15| OK| | 16| OK| | 17| OK| | 18| OK| | 19| OK| | 20| OK| +----------+---+ # Use GroupBy clause with dataframe df . groupBy ( 'HVACProduct' ) . count () . show () +-----------+-----+ |HVACProduct|count| +-----------+-----+ | ACMAX22| 4| | AC1000| 4| | JDNS77| 4| | FN39TG| 4| | GG1919| 4| +-----------+-----+ ! wget https : // www . cse . ust . hk / msbd5003 / data / Customer . csv ! wget https : // www . cse . ust . hk / msbd5003 / data / Product . csv ! wget https : // www . cse . ust . hk / msbd5003 / data / SalesOrderDetail . csv ! wget https : // www . cse . ust . hk / msbd5003 / data / SalesOrderHeader . csv --2020-10-06 11:51:08-- https://www.cse.ust.hk/msbd5003/data/Customer.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 199491 (195K) [text/plain] Saving to: \u2018Customer.csv\u2019 Customer.csv 100%[===================>] 194.82K 320KB/s in 0.6s 2020-10-06 11:51:11 (320 KB/s) - \u2018Customer.csv\u2019 saved [199491/199491] --2020-10-06 11:51:12-- https://www.cse.ust.hk/msbd5003/data/Product.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 1355634 (1.3M) [text/plain] Saving to: \u2018Product.csv\u2019 Product.csv 100%[===================>] 1.29M 1.05MB/s in 1.2s 2020-10-06 11:51:15 (1.05 MB/s) - \u2018Product.csv\u2019 saved [1355634/1355634] --2020-10-06 11:51:15-- https://www.cse.ust.hk/msbd5003/data/SalesOrderDetail.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 56766 (55K) [text/plain] Saving to: \u2018SalesOrderDetail.csv\u2019 SalesOrderDetail.cs 100%[===================>] 55.44K 137KB/s in 0.4s 2020-10-06 11:51:18 (137 KB/s) - \u2018SalesOrderDetail.csv\u2019 saved [56766/56766] --2020-10-06 11:51:18-- https://www.cse.ust.hk/msbd5003/data/SalesOrderHeader.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 8680 (8.5K) [text/plain] Saving to: \u2018SalesOrderHeader.csv\u2019 SalesOrderHeader.cs 100%[===================>] 8.48K --.-KB/s in 0s 2020-10-06 11:51:19 (79.4 MB/s) - \u2018SalesOrderHeader.csv\u2019 saved [8680/8680] Rewriting SQL with DataFrame API \u00b6 # Load data from csv files # Data files at https://www.cse.ust.hk/msbd5003/data dfCustomer = spark . read . csv ( 'Customer.csv' , header = True , inferSchema = True ) dfProduct = spark . read . csv ( 'Product.csv' , header = True , inferSchema = True ) dfDetail = spark . read . csv ( 'SalesOrderDetail.csv' , header = True , inferSchema = True ) dfHeader = spark . read . csv ( 'SalesOrderHeader.csv' , header = True , inferSchema = True ) # SELECT ProductID, Name, ListPrice # FROM Product # WHERE Color = 'black' dfProduct . filter ( \"Color = 'Black'\" ) \\ . select ( 'ProductID' , 'Name' , 'ListPrice' ) \\ . show ( truncate = False ) +---------+-----------------------------+---------+ |ProductID|Name |ListPrice| +---------+-----------------------------+---------+ |680 |HL Road Frame - Black, 58 |1431.5 | |708 |Sport-100 Helmet, Black |34.99 | |722 |LL Road Frame - Black, 58 |337.22 | |723 |LL Road Frame - Black, 60 |337.22 | |724 |LL Road Frame - Black, 62 |337.22 | |736 |LL Road Frame - Black, 44 |337.22 | |737 |LL Road Frame - Black, 48 |337.22 | |738 |LL Road Frame - Black, 52 |337.22 | |743 |HL Mountain Frame - Black, 42|1349.6 | |744 |HL Mountain Frame - Black, 44|1349.6 | |745 |HL Mountain Frame - Black, 48|1349.6 | |746 |HL Mountain Frame - Black, 46|1349.6 | |747 |HL Mountain Frame - Black, 38|1349.6 | |765 |Road-650 Black, 58 |782.99 | |766 |Road-650 Black, 60 |782.99 | |767 |Road-650 Black, 62 |782.99 | |768 |Road-650 Black, 44 |782.99 | |769 |Road-650 Black, 48 |782.99 | |770 |Road-650 Black, 52 |782.99 | |775 |Mountain-100 Black, 38 |3374.99 | +---------+-----------------------------+---------+ only showing top 20 rows dfProduct . where ( dfProduct . Color == 'Black' ) \\ . select ( dfProduct . ProductID , dfProduct [ 'Name' ], ( dfProduct [ 'ListPrice' ] * 2 ) . alias ( 'Double price' )) \\ . show ( truncate = False ) +---------+-----------------------------+------------+ |ProductID|Name |Double price| +---------+-----------------------------+------------+ |680 |HL Road Frame - Black, 58 |2863.0 | |708 |Sport-100 Helmet, Black |69.98 | |722 |LL Road Frame - Black, 58 |674.44 | |723 |LL Road Frame - Black, 60 |674.44 | |724 |LL Road Frame - Black, 62 |674.44 | |736 |LL Road Frame - Black, 44 |674.44 | |737 |LL Road Frame - Black, 48 |674.44 | |738 |LL Road Frame - Black, 52 |674.44 | |743 |HL Mountain Frame - Black, 42|2699.2 | |744 |HL Mountain Frame - Black, 44|2699.2 | |745 |HL Mountain Frame - Black, 48|2699.2 | |746 |HL Mountain Frame - Black, 46|2699.2 | |747 |HL Mountain Frame - Black, 38|2699.2 | |765 |Road-650 Black, 58 |1565.98 | |766 |Road-650 Black, 60 |1565.98 | |767 |Road-650 Black, 62 |1565.98 | |768 |Road-650 Black, 44 |1565.98 | |769 |Road-650 Black, 48 |1565.98 | |770 |Road-650 Black, 52 |1565.98 | |775 |Mountain-100 Black, 38 |6749.98 | +---------+-----------------------------+------------+ only showing top 20 rows dfProduct . where ( dfProduct . ListPrice * 2 > 100 ) \\ . select ( dfProduct . ProductID , dfProduct [ 'Name' ], dfProduct . ListPrice * 2 ) \\ . show ( truncate = False ) +---------+-------------------------+---------------+ |ProductID|Name |(ListPrice * 2)| +---------+-------------------------+---------------+ |680 |HL Road Frame - Black, 58|2863.0 | |706 |HL Road Frame - Red, 58 |2863.0 | |717 |HL Road Frame - Red, 62 |2863.0 | |718 |HL Road Frame - Red, 44 |2863.0 | |719 |HL Road Frame - Red, 48 |2863.0 | |720 |HL Road Frame - Red, 52 |2863.0 | |721 |HL Road Frame - Red, 56 |2863.0 | |722 |LL Road Frame - Black, 58|674.44 | |723 |LL Road Frame - Black, 60|674.44 | |724 |LL Road Frame - Black, 62|674.44 | |725 |LL Road Frame - Red, 44 |674.44 | |726 |LL Road Frame - Red, 48 |674.44 | |727 |LL Road Frame - Red, 52 |674.44 | |728 |LL Road Frame - Red, 58 |674.44 | |729 |LL Road Frame - Red, 60 |674.44 | |730 |LL Road Frame - Red, 62 |674.44 | |731 |ML Road Frame - Red, 44 |1189.66 | |732 |ML Road Frame - Red, 48 |1189.66 | |733 |ML Road Frame - Red, 52 |1189.66 | |734 |ML Road Frame - Red, 58 |1189.66 | +---------+-------------------------+---------------+ only showing top 20 rows # SELECT ProductID, Name, ListPrice # FROM Product # WHERE Color = 'black' # ORDER BY ProductID dfProduct . filter ( \"Color = 'Black'\" ) \\ . select ( 'ProductID' , 'Name' , 'ListPrice' ) \\ . orderBy ( 'ListPrice' ) \\ . show ( truncate = False ) +---------+--------------------------+---------+ |ProductID|Name |ListPrice| +---------+--------------------------+---------+ |860 |Half-Finger Gloves, L |24.49 | |859 |Half-Finger Gloves, M |24.49 | |858 |Half-Finger Gloves, S |24.49 | |708 |Sport-100 Helmet, Black |34.99 | |862 |Full-Finger Gloves, M |37.99 | |861 |Full-Finger Gloves, S |37.99 | |863 |Full-Finger Gloves, L |37.99 | |841 |Men's Sports Shorts, S |59.99 | |849 |Men's Sports Shorts, M |59.99 | |851 |Men's Sports Shorts, XL |59.99 | |850 |Men's Sports Shorts, L |59.99 | |815 |LL Mountain Front Wheel |60.745 | |868 |Women's Mountain Shorts, M|69.99 | |869 |Women's Mountain Shorts, L|69.99 | |867 |Women's Mountain Shorts, S|69.99 | |853 |Women's Tights, M |74.99 | |854 |Women's Tights, L |74.99 | |852 |Women's Tights, S |74.99 | |818 |LL Road Front Wheel |85.565 | |823 |LL Mountain Rear Wheel |87.745 | +---------+--------------------------+---------+ only showing top 20 rows # Find all orders and details on black product, # return the product SalesOrderID, SalesOrderDetailID, Name, UnitPrice, and OrderQty # SELECT SalesOrderID, SalesOrderDetailID, Name, UnitPrice, OrderQty # FROM SalesLT.SalesOrderDetail, SalesLT.Product # WHERE SalesOrderDetail.ProductID = Product.ProductID AND Color = 'Black' # SELECT SalesOrderID, SalesOrderDetailID, Name, UnitPrice, OrderQty # FROM SalesLT.SalesOrderDetail # JOIN SalesLT.Product ON SalesOrderDetail.ProductID = Product.ProductID # WHERE Color = 'Black' # Spark SQL supports natural joins dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) \\ . filter ( \"Color='Black'\" ) \\ . show () # If we move the filter to after select, it still works. Why? +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71797| 111045|LL Road Frame - B...| 202.332| 3| | 71783| 110730|LL Road Frame - B...| 202.332| 6| | 71938| 113297|LL Road Frame - B...| 202.332| 3| | 71915| 113090|LL Road Frame - B...| 202.332| 2| | 71815| 111451|LL Road Frame - B...| 202.332| 1| | 71797| 111044|LL Road Frame - B...| 202.332| 1| | 71783| 110710|LL Road Frame - B...| 202.332| 4| | 71936| 113260|HL Mountain Frame...| 809.76| 4| | 71899| 112937|HL Mountain Frame...| 809.76| 1| | 71845| 112137|HL Mountain Frame...| 809.76| 2| | 71832| 111806|HL Mountain Frame...| 809.76| 4| | 71780| 110622|HL Mountain Frame...| 809.76| 1| | 71936| 113235|HL Mountain Frame...| 809.76| 4| | 71845| 112134|HL Mountain Frame...| 809.76| 3| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows # This also works: d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) d1 . show () d2 = d1 . filter ( \"Color = 'Black'\" ) d2 . show () d2 . explain () +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113278|Sport-100 Helmet,...| 20.994| 3| | 71936| 113228|Sport-100 Helmet,...| 20.994| 1| | 71902| 112980|Sport-100 Helmet,...| 20.994| 2| | 71797| 111075|Sport-100 Helmet,...| 20.994| 6| | 71784| 110794|Sport-100 Helmet,...| 20.994| 10| | 71783| 110751|Sport-100 Helmet,...| 20.994| 10| | 71782| 110709|Sport-100 Helmet,...| 20.994| 3| | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71938| 113282|Sport-100 Helmet,...| 20.994| 3| | 71902| 112995|Sport-100 Helmet,...| 20.994| 7| | 71863| 112395|Sport-100 Helmet,...| 20.994| 1| | 71797| 111038|Sport-100 Helmet,...| 20.994| 4| | 71784| 110753|Sport-100 Helmet,...| 20.994| 2| | 71783| 110749|Sport-100 Helmet,...| 19.2445| 15| | 71782| 110708|Sport-100 Helmet,...| 20.994| 6| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71797| 111045|LL Road Frame - B...| 202.332| 3| | 71783| 110730|LL Road Frame - B...| 202.332| 6| | 71938| 113297|LL Road Frame - B...| 202.332| 3| | 71915| 113090|LL Road Frame - B...| 202.332| 2| | 71815| 111451|LL Road Frame - B...| 202.332| 1| | 71797| 111044|LL Road Frame - B...| 202.332| 1| | 71783| 110710|LL Road Frame - B...| 202.332| 4| | 71936| 113260|HL Mountain Frame...| 809.76| 4| | 71899| 112937|HL Mountain Frame...| 809.76| 1| | 71845| 112137|HL Mountain Frame...| 809.76| 2| | 71832| 111806|HL Mountain Frame...| 809.76| 4| | 71780| 110622|HL Mountain Frame...| 809.76| 1| | 71936| 113235|HL Mountain Frame...| 809.76| 4| | 71845| 112134|HL Mountain Frame...| 809.76| 3| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows == Physical Plan == *(2) Project [SalesOrderID#217, SalesOrderDetailID#218, Name#168, UnitPrice#221, OrderQty#219] +- *(2) BroadcastHashJoin [ProductID#220], [ProductID#167], Inner, BuildLeft :- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[3, int, true] as bigint))), [id=#380] : +- *(1) Project [SalesOrderID#217, SalesOrderDetailID#218, OrderQty#219, ProductID#220, UnitPrice#221] : +- *(1) Filter isnotnull(ProductID#220) : +- FileScan csv [SalesOrderID#217,SalesOrderDetailID#218,OrderQty#219,ProductID#220,UnitPrice#221] Batched: false, DataFilters: [isnotnull(ProductID#220)], Format: CSV, Location: InMemoryFileIndex[file:/content/SalesOrderDetail.csv], PartitionFilters: [], PushedFilters: [IsNotNull(ProductID)], ReadSchema: struct<SalesOrderID:int,SalesOrderDetailID:int,OrderQty:int,ProductID:int,UnitPrice:double> +- *(2) Project [ProductID#167, Name#168] +- *(2) Filter ((isnotnull(Color#170) AND (Color#170 = Black)) AND isnotnull(ProductID#167)) +- FileScan csv [ProductID#167,Name#168,Color#170] Batched: false, DataFilters: [isnotnull(Color#170), (Color#170 = Black), isnotnull(ProductID#167)], Format: CSV, Location: InMemoryFileIndex[file:/content/Product.csv], PartitionFilters: [], PushedFilters: [IsNotNull(Color), EqualTo(Color,Black), IsNotNull(ProductID)], ReadSchema: struct<ProductID:int,Name:string,Color:string> # SparkSQL performs optimization depending on whether intermediate dataframe are cached or not: d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) d1 . persist () d1 . show () +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113278|Sport-100 Helmet,...| 20.994| 3| | 71936| 113228|Sport-100 Helmet,...| 20.994| 1| | 71902| 112980|Sport-100 Helmet,...| 20.994| 2| | 71797| 111075|Sport-100 Helmet,...| 20.994| 6| | 71784| 110794|Sport-100 Helmet,...| 20.994| 10| | 71783| 110751|Sport-100 Helmet,...| 20.994| 10| | 71782| 110709|Sport-100 Helmet,...| 20.994| 3| | 71938| 113295|Sport-100 Helmet,...| 20.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71938| 113282|Sport-100 Helmet,...| 20.994| 3| | 71902| 112995|Sport-100 Helmet,...| 20.994| 7| | 71863| 112395|Sport-100 Helmet,...| 20.994| 1| | 71797| 111038|Sport-100 Helmet,...| 20.994| 4| | 71784| 110753|Sport-100 Helmet,...| 20.994| 2| | 71783| 110749|Sport-100 Helmet,...| 19.2445| 15| | 71782| 110708|Sport-100 Helmet,...| 20.994| 6| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows d2 = d1 . filter ( \"Color = 'Black'\" ) #d2 = d1.filter(\"OrderQty >= 10\") d2 . show () d2 . explain () +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71797| 111045|LL Road Frame - B...| 202.332| 3| | 71783| 110730|LL Road Frame - B...| 202.332| 6| | 71938| 113297|LL Road Frame - B...| 202.332| 3| | 71915| 113090|LL Road Frame - B...| 202.332| 2| | 71815| 111451|LL Road Frame - B...| 202.332| 1| | 71797| 111044|LL Road Frame - B...| 202.332| 1| | 71783| 110710|LL Road Frame - B...| 202.332| 4| | 71936| 113260|HL Mountain Frame...| 809.76| 4| | 71899| 112937|HL Mountain Frame...| 809.76| 1| | 71845| 112137|HL Mountain Frame...| 809.76| 2| | 71832| 111806|HL Mountain Frame...| 809.76| 4| | 71780| 110622|HL Mountain Frame...| 809.76| 1| | 71936| 113235|HL Mountain Frame...| 809.76| 4| | 71845| 112134|HL Mountain Frame...| 809.76| 3| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows == Physical Plan == *(2) Project [SalesOrderID#112, SalesOrderDetailID#113, Name#63, UnitPrice#116, OrderQty#114] +- *(2) BroadcastHashJoin [ProductID#115], [ProductID#62], Inner, BuildLeft :- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[3, int, true] as bigint))), [id=#280] : +- *(1) Project [SalesOrderID#112, SalesOrderDetailID#113, OrderQty#114, ProductID#115, UnitPrice#116] : +- *(1) Filter isnotnull(ProductID#115) : +- FileScan csv [SalesOrderID#112,SalesOrderDetailID#113,OrderQty#114,ProductID#115,UnitPrice#116] Batched: false, DataFilters: [isnotnull(ProductID#115)], Format: CSV, Location: InMemoryFileIndex[file:/csproject/msbd5003/public_html/data/SalesOrderDetail.csv], PartitionFilters: [], PushedFilters: [IsNotNull(ProductID)], ReadSchema: struct<SalesOrderID:int,SalesOrderDetailID:int,OrderQty:int,ProductID:int,UnitPrice:double> +- *(2) Project [ProductID#62, Name#63] +- *(2) Filter ((isnotnull(Color#65) AND (Color#65 = Black)) AND isnotnull(ProductID#62)) +- FileScan csv [ProductID#62,Name#63,Color#65] Batched: false, DataFilters: [isnotnull(Color#65), (Color#65 = Black), isnotnull(ProductID#62)], Format: CSV, Location: InMemoryFileIndex[file:/csproject/msbd5003/public_html/data/Product.csv], PartitionFilters: [], PushedFilters: [IsNotNull(Color), EqualTo(Color,Black), IsNotNull(ProductID)], ReadSchema: struct<ProductID:int,Name:string,Color:string> # This will report an error: d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) d1 . write . csv ( 'temp.csv' , mode = 'overwrite' , header = True ) d2 = spark . read . csv ( 'temp.csv' , header = True , inferSchema = True ) d2 . filter ( \"Color = 'Black'\" ) . show () --------------------------------------------------------------------------- AnalysisException Traceback (most recent call last) <ipython-input-18-168595bb0376> in <module> 5 d1.write.csv('temp.csv', mode = 'overwrite', header = True) 6 d2 = spark.read.csv('temp.csv', header = True, inferSchema = True) ----> 7 d2.filter(\"Color = 'Black'\").show() /csproject/msbd5003/python/pyspark/sql/dataframe.py in filter(self, condition) 1457 \"\"\" 1458 if isinstance(condition, basestring): -> 1459 jdf = self._jdf.filter(condition) 1460 elif isinstance(condition, Column): 1461 jdf = self._jdf.filter(condition._jc) /csproject/msbd5003/python/lib/py4j-0.10.9-src.zip/py4j/java_gateway.py in __call__(self, *args) 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( -> 1305 answer, self.gateway_client, self.target_id, self.name) 1306 1307 for temp_arg in temp_args: /csproject/msbd5003/python/pyspark/sql/utils.py in deco(*a, **kw) 135 # Hide where the exception came from that shows a non-Pythonic 136 # JVM exception message. --> 137 raise_from(converted) 138 else: 139 raise /csproject/msbd5003/python/pyspark/sql/utils.py in raise_from(e) AnalysisException: cannot resolve '`Color`' given input columns: [Name, OrderQty, SalesOrderDetailID, SalesOrderID, UnitPrice]; line 1 pos 0; 'Filter ('Color = Black) +- Relation[SalesOrderID#580,SalesOrderDetailID#581,Name#582,UnitPrice#583,OrderQty#584] csv # Find all orders that include at least one black product, # return the product SalesOrderID, Name, UnitPrice, and OrderQty # SELECT DISTINCT SalesOrderID # FROM SalesLT.SalesOrderDetail # JOIN SalesLT.Product ON SalesOrderDetail.ProductID = Product.ProductID # WHERE Color = 'Black' dfDetail . join ( dfProduct . filter ( \"Color='Black'\" ), 'ProductID' ) \\ . select ( 'SalesOrderID' ) \\ . distinct () \\ . show () +------------+ |SalesOrderID| +------------+ | 71902| | 71832| | 71915| | 71831| | 71898| | 71935| | 71938| | 71845| | 71783| | 71815| | 71936| | 71863| | 71780| | 71782| | 71899| | 71784| | 71797| +------------+ # How many colors in the products? # SELECT COUNT(DISTINCT Color) # FROM SalesLT.Product dfProduct . select ( 'Color' ) . distinct () . count () # It's 1 more than standard SQL. In standard SQL, COUNT() does not count NULLs. 10 # Find the total price of each order, # return SalesOrderID and total price (column name should be \u2018totalprice\u2019) # SELECT SalesOrderID, SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) AS TotalPrice # FROM SalesLT.SalesOrderDetail # GROUP BY SalesOrderID dfDetail . select ( '*' , ( dfDetail . UnitPrice * dfDetail . OrderQty * ( 1 - dfDetail . UnitPriceDiscount )) . alias ( 'netprice' )) \\ . groupBy ( 'SalesOrderID' ) . sum ( 'netprice' ) \\ . withColumnRenamed ( 'sum(netprice)' , 'TotalPrice' ) \\ . show () +------------+------------------+ |SalesOrderID| sum(netprice)| +------------+------------------+ | 71867| 858.9| | 71902|59894.209199999976| | 71832| 28950.678108| | 71915|1732.8899999999999| | 71946| 31.584| | 71895|221.25600000000003| | 71816|2847.4079999999994| | 71831| 1712.946| | 71923| 96.108824| | 71858|11528.844000000001| | 71917| 37.758| | 71897| 10585.05| | 71885| 524.664| | 71856|500.30400000000003| | 71898| 53248.69200000002| | 71774| 713.796| | 71796| 47848.02600000001| | 71935|5533.8689079999995| | 71938| 74160.228| | 71845| 34118.5356| +------------+------------------+ only showing top 20 rows # Find the total price of each order where the total price > 10000 # SELECT SalesOrderID, SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) AS TotalPrice # FROM SalesLT.SalesOrderDetail # GROUP BY SalesOrderID # HAVING SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) > 10000 dfDetail . select ( '*' , ( dfDetail . UnitPrice * dfDetail . OrderQty * ( 1 - dfDetail . UnitPriceDiscount )) . alias ( 'netprice' )) \\ . groupBy ( 'SalesOrderID' ) . sum ( 'netprice' ) \\ . withColumnRenamed ( 'sum(netprice)' , 'TotalPrice' ) \\ . where ( 'TotalPrice > 10000' ) \\ . show () +------------+------------------+ |SalesOrderID| TotalPrice| +------------+------------------+ | 71902|59894.209199999976| | 71832| 28950.678108| | 71858|11528.844000000001| | 71897| 10585.05| | 71898| 53248.69200000002| | 71796| 47848.02600000001| | 71938| 74160.228| | 71845| 34118.5356| | 71783| 65683.367986| | 71936| 79589.61602399996| | 71780|29923.007999999998| | 71782| 33319.98600000001| | 71784| 89869.27631400003| | 71797| 65123.46341800001| +------------+------------------+ # Find the total price on the black products of each order where the total price > 10000 # SELECT SalesOrderID, SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) AS TotalPrice # FROM SalesLT.SalesOrderDetail, SalesLT.Product # WHERE SalesLT.SalesOrderDetail.ProductID = SalesLT.Product.ProductID AND Color = 'Black' # GROUP BY SalesOrderID # HAVING SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) > 10000 dfDetail . select ( '*' , ( dfDetail . UnitPrice * dfDetail . OrderQty * ( 1 - dfDetail . UnitPriceDiscount )) . alias ( 'netprice' )) \\ . join ( dfProduct , 'ProductID' ) \\ . where ( \"Color = 'Black'\" ) \\ . groupBy ( 'SalesOrderID' ) . sum ( 'netprice' ) \\ . withColumnRenamed ( 'sum(netprice)' , 'TotalPrice' ) \\ . where ( 'TotalPrice > 10000' ) \\ . show () +------------+------------------+ |SalesOrderID| TotalPrice| +------------+------------------+ | 71902|26677.883999999995| | 71832| 16883.748108| | 71938| 33779.448| | 71845| 18109.836| | 71783|15524.117476000003| | 71936| 44490.290424| | 71780| 16964.322| | 71797| 27581.613792| +------------+------------------+ # For each customer, find the total quantity of black products bought. # Report CustomerID, FirstName, LastName, and total quantity # select saleslt.customer.customerid, FirstName, LastName, sum(orderqty) # from saleslt.customer # left outer join # ( # saleslt.salesorderheader # join saleslt.salesorderdetail # on saleslt.salesorderdetail.salesorderid = saleslt.salesorderheader.salesorderid # join saleslt.product # on saleslt.product.productid = saleslt.salesorderdetail.productid and color = 'black' # ) # on saleslt.customer.customerid = saleslt.salesorderheader.customerid # group by saleslt.customer.customerid, FirstName, LastName # order by sum(orderqty) desc d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . where ( 'Color = \"Black\"' ) \\ . join ( dfHeader , 'SalesOrderID' ) \\ . groupBy ( 'CustomerID' ) . sum ( 'OrderQty' ) dfCustomer . join ( d1 , 'CustomerID' , 'left_outer' ) \\ . select ( 'CustomerID' , 'FirstName' , 'LastName' , 'sum(OrderQty)' ) \\ . orderBy ( 'sum(OrderQty)' , ascending = False ) \\ . show () +----------+------------+------------+-------------+ |CustomerID| FirstName| LastName|sum(OrderQty)| +----------+------------+------------+-------------+ | 30050| Krishna|Sunkammurali| 89| | 29796| Jon| Grande| 65| | 29957| Kevin| Liu| 62| | 29929| Jeffrey| Kurtz| 46| | 29546| Christopher| Beck| 45| | 29922| Pamala| Kotc| 34| | 30113| Raja| Venugopal| 34| | 29938| Frank| Campbell| 29| | 29736| Terry| Eminhizer| 23| | 29485| Catherine| Abel| 10| | 30019| Matthew| Miller| 9| | 29932| Rebecca| Laszlo| 7| | 29975| Walter| Mays| 5| | 29638| Rosmarie| Carroll| 2| | 29531| Cory| Booth| 1| | 30089|Michael John| Troyer| 1| | 29568| Donald| Blanton| 1| | 29868| Denean| Ison| null| | 29646| Stacey| Cereghino| null| | 29905| Elizabeth| Keyser| null| +----------+------------+------------+-------------+ only showing top 20 rows Embed SQL queries \u00b6 You can also run SQL queries over dataframes once you register them as temporary tables within the SparkSession. # Register the dataframe as a temporary view called HVAC df . createOrReplaceTempView ( 'HVAC' ) spark . sql ( 'SELECT * FROM HVAC WHERE BuildingAge >= 10' ) . show () +----------+-----------+-----------+-----------+------------+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country| +----------+-----------+-----------+-----------+------------+ | 1| M1| 25| AC1000| USA| | 2| M2| 27| FN39TG| France| | 3| M3| 28| JDNS77| Brazil| | 4| M4| 17| GG1919| Finland| | 7| M7| 13| FN39TG|South Africa| | 8| M8| 25| JDNS77| Australia| | 9| M9| 11| GG1919| Mexico| | 10| M10| 23| ACMAX22| China| | 11| M11| 14| AC1000| Belgium| | 12| M12| 26| FN39TG| Finland| | 13| M13| 25| JDNS77|Saudi Arabia| | 14| M14| 17| GG1919| Germany| | 15| M15| 19| ACMAX22| Israel| | 16| M16| 23| AC1000| Turkey| | 17| M17| 11| FN39TG| Egypt| | 18| M18| 25| JDNS77| Indonesia| | 19| M19| 14| GG1919| Canada| | 20| M20| 19| ACMAX22| Argentina| +----------+-----------+-----------+-----------+------------+ # Can even mix DataFrame API with SQL: df . where ( 'BuildingAge >= 10' ) . createOrReplaceTempView ( 'OldBuildings' ) spark . sql ( 'SELECT HVACproduct, COUNT(*) FROM OldBuildings GROUP BY HVACproduct' ) . show () +-----------+--------+ |HVACproduct|count(1)| +-----------+--------+ | ACMAX22| 3| | AC1000| 3| | JDNS77| 4| | FN39TG| 4| | GG1919| 4| +-----------+--------+ d1 = spark . sql ( 'SELECT * FROM HVAC WHERE BuildingAge >= 10' ) d1 . groupBy ( 'HVACproduct' ) . count () . show () +-----------+-----+ |HVACproduct|count| +-----------+-----+ | ACMAX22| 3| | AC1000| 3| | JDNS77| 4| | FN39TG| 4| | GG1919| 4| +-----------+-----+ # UDF from pyspark.sql.functions import udf from pyspark.sql.types import IntegerType slen = udf ( lambda s : len ( s ) + 2 , IntegerType ()) df . select ( '*' , slen ( df [ 'Country' ]) . alias ( 'slen' )) . show () +----------+-----------+-----------+-----------+------------+----+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country|slen| +----------+-----------+-----------+-----------+------------+----+ | 1| M1| 25| AC1000| USA| 5| | 2| M2| 27| FN39TG| France| 8| | 3| M3| 28| JDNS77| Brazil| 8| | 4| M4| 17| GG1919| Finland| 9| | 5| M5| 3| ACMAX22| Hong Kong| 11| | 6| M6| 9| AC1000| Singapore| 11| | 7| M7| 13| FN39TG|South Africa| 14| | 8| M8| 25| JDNS77| Australia| 11| | 9| M9| 11| GG1919| Mexico| 8| | 10| M10| 23| ACMAX22| China| 7| | 11| M11| 14| AC1000| Belgium| 9| | 12| M12| 26| FN39TG| Finland| 9| | 13| M13| 25| JDNS77|Saudi Arabia| 14| | 14| M14| 17| GG1919| Germany| 9| | 15| M15| 19| ACMAX22| Israel| 8| | 16| M16| 23| AC1000| Turkey| 8| | 17| M17| 11| FN39TG| Egypt| 7| | 18| M18| 25| JDNS77| Indonesia| 11| | 19| M19| 14| GG1919| Canada| 8| | 20| M20| 19| ACMAX22| Argentina| 11| +----------+-----------+-----------+-----------+------------+----+ spark . udf . register ( 'slen' , lambda s : len ( s ), IntegerType ()) spark . sql ( 'SELECT *, slen(Country) AS slen FROM HVAC' ) . show () +----------+-----------+-----------+-----------+------------+----+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country|slen| +----------+-----------+-----------+-----------+------------+----+ | 1| M1| 25| AC1000| USA| 3| | 2| M2| 27| FN39TG| France| 6| | 3| M3| 28| JDNS77| Brazil| 6| | 4| M4| 17| GG1919| Finland| 7| | 5| M5| 3| ACMAX22| Hong Kong| 9| | 6| M6| 9| AC1000| Singapore| 9| | 7| M7| 13| FN39TG|South Africa| 12| | 8| M8| 25| JDNS77| Australia| 9| | 9| M9| 11| GG1919| Mexico| 6| | 10| M10| 23| ACMAX22| China| 5| | 11| M11| 14| AC1000| Belgium| 7| | 12| M12| 26| FN39TG| Finland| 7| | 13| M13| 25| JDNS77|Saudi Arabia| 12| | 14| M14| 17| GG1919| Germany| 7| | 15| M15| 19| ACMAX22| Israel| 6| | 16| M16| 23| AC1000| Turkey| 6| | 17| M17| 11| FN39TG| Egypt| 5| | 18| M18| 25| JDNS77| Indonesia| 9| | 19| M19| 14| GG1919| Canada| 6| | 20| M20| 19| ACMAX22| Argentina| 9| +----------+-----------+-----------+-----------+------------+----+ Flexible Data Model \u00b6 Sample data file at https://www.cse.ust.hk/msbd5003/data/products.json df = spark . read . json ( '../data/products.json' ) df . printSchema () root |-- dimensions: struct (nullable = true) | |-- height: double (nullable = true) | |-- length: double (nullable = true) | |-- width: double (nullable = true) |-- id: long (nullable = true) |-- name: string (nullable = true) |-- price: double (nullable = true) |-- tags: array (nullable = true) | |-- element: string (containsNull = true) |-- warehouseLocation: struct (nullable = true) | |-- latitude: double (nullable = true) | |-- longitude: double (nullable = true) df . show () +----------------+---+----------------+-----+-----------+-----------------+ | dimensions| id| name|price| tags|warehouseLocation| +----------------+---+----------------+-----+-----------+-----------------+ |[9.5, 7.0, 12.0]| 2|An ice sculpture| 12.5|[cold, ice]| [-78.75, 20.4]| | [1.0, 3.1, 1.0]| 3| A blue mouse| 25.5| null| [54.4, -32.7]| +----------------+---+----------------+-----+-----------+-----------------+ # Accessing nested fields df . select ( df [ 'dimensions.height' ]) . show () +------+ |height| +------+ | 9.5| | 1.0| +------+ df . select ( 'dimensions.height' ) . show () +------+ |height| +------+ | 9.5| | 1.0| +------+ df . select ( 'dimensions.height' ) \\ . filter ( \"tags[0] = 'cold' AND warehouseLocation.latitude < 0\" ) \\ . show () +------+ |height| +------+ | 9.5| +------+ df . rdd . take ( 3 ) [Row(dimensions=Row(height=9.5, length=7.0, width=12.0), id=2, name='An ice sculpture', price=12.5, tags=['cold', 'ice'], warehouseLocation=Row(latitude=-78.75, longitude=20.4)), Row(dimensions=Row(height=1.0, length=3.1, width=1.0), id=3, name='A blue mouse', price=25.5, tags=None, warehouseLocation=Row(latitude=54.4, longitude=-32.7))] Converting between RDD and DataFrame \u00b6 Sample data file at: https://www.cse.ust.hk/msbd5003/data/people.txt # Load a text file and convert each line to a Row. lines = sc . textFile ( \"../data/people.txt\" ) def parse ( l ): a = l . split ( ',' ) return ( a [ 0 ], int ( a [ 1 ])) rdd = lines . map ( parse ) rdd . collect () [('Michael', 29), ('Andy', 30), ('Justin', 19)] # Create the DataFrame from an RDD of tuples, schema is inferred df = spark . createDataFrame ( rdd ) df . printSchema () df . show () root |-- _1: string (nullable = true) |-- _2: long (nullable = true) +-------+---+ | _1| _2| +-------+---+ |Michael| 29| | Andy| 30| | Justin| 19| +-------+---+ # Create the DataFrame from an RDD of tuples with column names, type is inferred df = spark . createDataFrame ( rdd , [ 'name' , 'age' ]) df . printSchema () df . show () root |-- name: string (nullable = true) |-- age: long (nullable = true) +-------+---+ | name|age| +-------+---+ |Michael| 29| | Andy| 30| | Justin| 19| +-------+---+ # Create the DataFrame from an RDD of Rows, type is given in the Row objects from pyspark.sql import Row rdd_rows = rdd . map ( lambda p : Row ( name = p [ 0 ], age = p [ 1 ])) df = spark . createDataFrame ( rdd_rows ) df . printSchema () df . show () root |-- name: string (nullable = true) |-- age: long (nullable = true) +-------+---+ | name|age| +-------+---+ |Michael| 29| | Andy| 30| | Justin| 19| +-------+---+ # Row fields with types incompatible with that of previous rows will be turned into nulls row1 = Row ( name = \"Alice\" , age = 11 ) row2 = Row ( name = \"Bob\" , age = '12' ) rdd_rows = sc . parallelize ([ row1 , row2 ]) df1 = spark . createDataFrame ( rdd_rows ) df1 . show () +-----+----+ | name| age| +-----+----+ |Alice| 11| | Bob|null| +-----+----+ # rdd returns the content as an RDD of Rows teenagers = df . filter ( 'age >= 13 and age <= 19' ) teenNames = teenagers . rdd . map ( lambda p : \"Name: \" + p . name ) teenNames . collect () ['Name: Justin'] Note: \u00b6 DataFrames are stored using columnar storage with compression RDDs are stored using row storage without compression The RDD view of DataFrame just provides an interface, the Row objects are constructed on the fly and do not necessarily represent the internal storage format of the data Closure in DataFrames \u00b6 data = range ( 10 ) df = spark . createDataFrame ( zip ( data , data )) df . printSchema () df . show () root |-- _1: long (nullable = true) |-- _2: long (nullable = true) +---+---+ | _1| _2| +---+---+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| | 5| 5| | 6| 6| | 7| 7| | 8| 8| | 9| 9| +---+---+ # The 'closure' behaviour in RDD doesn't seem to exist for DataFrames x = 5 df1 = df . filter ( df . _1 < x ) df1 . show () x = 3 df1 . show () +---+---+ | _1| _2| +---+---+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| +---+---+ +---+---+ | _1| _2| +---+---+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| +---+---+ # Because of the Catalyst optimizer ! df1 . explain () == Physical Plan == *(1) Filter (isnotnull(_1#1265L) AND (_1#1265L < 5)) +- *(1) Scan ExistingRDD[_1#1265L,_2#1266L] def f (): return x / 2 x = 5 df1 = df . select ( df . _1 * 2 + f () + 1 + 1 ) df1 . explain () df1 . show () == Physical Plan == *(1) Project [(((cast((_1#1265L * 2) as double) + 2.5) + 1.0) + 1.0) AS ((((_1 * 2) + 2.5) + 1) + 1)#1296] +- *(1) Scan ExistingRDD[_1#1265L,_2#1266L] +----------------------------+ |((((_1 * 2) + 2.5) + 1) + 1)| +----------------------------+ | 4.5| | 6.5| | 8.5| | 10.5| | 12.5| | 14.5| | 16.5| | 18.5| | 20.5| | 22.5| +----------------------------+ rdd = sc . parallelize ( range ( 10 )) x = 5 a = rdd . filter ( lambda z : z < x ) print ( a . take ( 10 )) x = 3 print ( a . take ( 10 )) [0, 1, 2, 3, 4] [0, 1, 2] counter = 0 def increment_counter ( x ): global counter counter += 1 df . foreach ( increment_counter ) print ( counter ) 0","title":"Sparksql"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#dataframe-operations","text":"from pyspark.sql import Row row = Row ( name = \"Alice\" , age = 11 ) print ( row ) print ( row [ 'name' ], row [ 'age' ]) print ( row . name , row . age ) row = Row ( name = \"Alice\" , age = 11 , count = 1 ) print ( row . count ) print ( row [ 'count' ]) Row(name='Alice', age=11) Alice 11 Alice 11 <built-in method count of Row object at 0x7f3384ce6e08> 1 ! wget https : // www . cse . ust . hk / msbd5003 / data / building . csv --2020-10-06 11:49:18-- https://www.cse.ust.hk/msbd5003/data/building.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 544 [text/plain] Saving to: \u2018building.csv.1\u2019 building.csv.1 100%[===================>] 544 --.-KB/s in 0s 2020-10-06 11:49:20 (30.9 MB/s) - \u2018building.csv.1\u2019 saved [544/544] # Data file at https://www.cse.ust.hk/msbd5003/data/building.csv df = spark . read . csv ( 'building.csv' , header = True , inferSchema = True ) # show the content of the dataframe df . show () +----------+-----------+-----------+-----------+------------+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country| +----------+-----------+-----------+-----------+------------+ | 1| M1| 25| AC1000| USA| | 2| M2| 27| FN39TG| France| | 3| M3| 28| JDNS77| Brazil| | 4| M4| 17| GG1919| Finland| | 5| M5| 3| ACMAX22| Hong Kong| | 6| M6| 9| AC1000| Singapore| | 7| M7| 13| FN39TG|South Africa| | 8| M8| 25| JDNS77| Australia| | 9| M9| 11| GG1919| Mexico| | 10| M10| 23| ACMAX22| China| | 11| M11| 14| AC1000| Belgium| | 12| M12| 26| FN39TG| Finland| | 13| M13| 25| JDNS77|Saudi Arabia| | 14| M14| 17| GG1919| Germany| | 15| M15| 19| ACMAX22| Israel| | 16| M16| 23| AC1000| Turkey| | 17| M17| 11| FN39TG| Egypt| | 18| M18| 25| JDNS77| Indonesia| | 19| M19| 14| GG1919| Canada| | 20| M20| 19| ACMAX22| Argentina| +----------+-----------+-----------+-----------+------------+ # Print the dataframe schema in a tree format df . printSchema () root |-- BuildingID: integer (nullable = true) |-- BuildingMgr: string (nullable = true) |-- BuildingAge: integer (nullable = true) |-- HVACproduct: string (nullable = true) |-- Country: string (nullable = true) # Create an RDD from the dataframe dfrdd = df . rdd dfrdd . take ( 3 ) [Row(BuildingID=1, BuildingMgr='M1', BuildingAge=25, HVACproduct='AC1000', Country='USA'), Row(BuildingID=2, BuildingMgr='M2', BuildingAge=27, HVACproduct='FN39TG', Country='France'), Row(BuildingID=3, BuildingMgr='M3', BuildingAge=28, HVACproduct='JDNS77', Country='Brazil')] # Retrieve specific columns from the dataframe df . select ( 'BuildingID' , 'Country' ) . show () +----------+------------+ |BuildingID| Country| +----------+------------+ | 1| USA| | 2| France| | 3| Brazil| | 4| Finland| | 5| Hong Kong| | 6| Singapore| | 7|South Africa| | 8| Australia| | 9| Mexico| | 10| China| | 11| Belgium| | 12| Finland| | 13|Saudi Arabia| | 14| Germany| | 15| Israel| | 16| Turkey| | 17| Egypt| | 18| Indonesia| | 19| Canada| | 20| Argentina| +----------+------------+ from pyspark.sql.functions import * df . where ( \"Country<'USA'\" ) . select ( 'BuildingID' , lit ( 'OK' )) . show () +----------+---+ |BuildingID| OK| +----------+---+ | 2| OK| | 3| OK| | 4| OK| | 5| OK| | 6| OK| | 7| OK| | 8| OK| | 9| OK| | 10| OK| | 11| OK| | 12| OK| | 13| OK| | 14| OK| | 15| OK| | 16| OK| | 17| OK| | 18| OK| | 19| OK| | 20| OK| +----------+---+ # Use GroupBy clause with dataframe df . groupBy ( 'HVACProduct' ) . count () . show () +-----------+-----+ |HVACProduct|count| +-----------+-----+ | ACMAX22| 4| | AC1000| 4| | JDNS77| 4| | FN39TG| 4| | GG1919| 4| +-----------+-----+ ! wget https : // www . cse . ust . hk / msbd5003 / data / Customer . csv ! wget https : // www . cse . ust . hk / msbd5003 / data / Product . csv ! wget https : // www . cse . ust . hk / msbd5003 / data / SalesOrderDetail . csv ! wget https : // www . cse . ust . hk / msbd5003 / data / SalesOrderHeader . csv --2020-10-06 11:51:08-- https://www.cse.ust.hk/msbd5003/data/Customer.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 199491 (195K) [text/plain] Saving to: \u2018Customer.csv\u2019 Customer.csv 100%[===================>] 194.82K 320KB/s in 0.6s 2020-10-06 11:51:11 (320 KB/s) - \u2018Customer.csv\u2019 saved [199491/199491] --2020-10-06 11:51:12-- https://www.cse.ust.hk/msbd5003/data/Product.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 1355634 (1.3M) [text/plain] Saving to: \u2018Product.csv\u2019 Product.csv 100%[===================>] 1.29M 1.05MB/s in 1.2s 2020-10-06 11:51:15 (1.05 MB/s) - \u2018Product.csv\u2019 saved [1355634/1355634] --2020-10-06 11:51:15-- https://www.cse.ust.hk/msbd5003/data/SalesOrderDetail.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 56766 (55K) [text/plain] Saving to: \u2018SalesOrderDetail.csv\u2019 SalesOrderDetail.cs 100%[===================>] 55.44K 137KB/s in 0.4s 2020-10-06 11:51:18 (137 KB/s) - \u2018SalesOrderDetail.csv\u2019 saved [56766/56766] --2020-10-06 11:51:18-- https://www.cse.ust.hk/msbd5003/data/SalesOrderHeader.csv Resolving www.cse.ust.hk (www.cse.ust.hk)... 143.89.40.27 Connecting to www.cse.ust.hk (www.cse.ust.hk)|143.89.40.27|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 8680 (8.5K) [text/plain] Saving to: \u2018SalesOrderHeader.csv\u2019 SalesOrderHeader.cs 100%[===================>] 8.48K --.-KB/s in 0s 2020-10-06 11:51:19 (79.4 MB/s) - \u2018SalesOrderHeader.csv\u2019 saved [8680/8680]","title":"Dataframe operations"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#rewriting-sql-with-dataframe-api","text":"# Load data from csv files # Data files at https://www.cse.ust.hk/msbd5003/data dfCustomer = spark . read . csv ( 'Customer.csv' , header = True , inferSchema = True ) dfProduct = spark . read . csv ( 'Product.csv' , header = True , inferSchema = True ) dfDetail = spark . read . csv ( 'SalesOrderDetail.csv' , header = True , inferSchema = True ) dfHeader = spark . read . csv ( 'SalesOrderHeader.csv' , header = True , inferSchema = True ) # SELECT ProductID, Name, ListPrice # FROM Product # WHERE Color = 'black' dfProduct . filter ( \"Color = 'Black'\" ) \\ . select ( 'ProductID' , 'Name' , 'ListPrice' ) \\ . show ( truncate = False ) +---------+-----------------------------+---------+ |ProductID|Name |ListPrice| +---------+-----------------------------+---------+ |680 |HL Road Frame - Black, 58 |1431.5 | |708 |Sport-100 Helmet, Black |34.99 | |722 |LL Road Frame - Black, 58 |337.22 | |723 |LL Road Frame - Black, 60 |337.22 | |724 |LL Road Frame - Black, 62 |337.22 | |736 |LL Road Frame - Black, 44 |337.22 | |737 |LL Road Frame - Black, 48 |337.22 | |738 |LL Road Frame - Black, 52 |337.22 | |743 |HL Mountain Frame - Black, 42|1349.6 | |744 |HL Mountain Frame - Black, 44|1349.6 | |745 |HL Mountain Frame - Black, 48|1349.6 | |746 |HL Mountain Frame - Black, 46|1349.6 | |747 |HL Mountain Frame - Black, 38|1349.6 | |765 |Road-650 Black, 58 |782.99 | |766 |Road-650 Black, 60 |782.99 | |767 |Road-650 Black, 62 |782.99 | |768 |Road-650 Black, 44 |782.99 | |769 |Road-650 Black, 48 |782.99 | |770 |Road-650 Black, 52 |782.99 | |775 |Mountain-100 Black, 38 |3374.99 | +---------+-----------------------------+---------+ only showing top 20 rows dfProduct . where ( dfProduct . Color == 'Black' ) \\ . select ( dfProduct . ProductID , dfProduct [ 'Name' ], ( dfProduct [ 'ListPrice' ] * 2 ) . alias ( 'Double price' )) \\ . show ( truncate = False ) +---------+-----------------------------+------------+ |ProductID|Name |Double price| +---------+-----------------------------+------------+ |680 |HL Road Frame - Black, 58 |2863.0 | |708 |Sport-100 Helmet, Black |69.98 | |722 |LL Road Frame - Black, 58 |674.44 | |723 |LL Road Frame - Black, 60 |674.44 | |724 |LL Road Frame - Black, 62 |674.44 | |736 |LL Road Frame - Black, 44 |674.44 | |737 |LL Road Frame - Black, 48 |674.44 | |738 |LL Road Frame - Black, 52 |674.44 | |743 |HL Mountain Frame - Black, 42|2699.2 | |744 |HL Mountain Frame - Black, 44|2699.2 | |745 |HL Mountain Frame - Black, 48|2699.2 | |746 |HL Mountain Frame - Black, 46|2699.2 | |747 |HL Mountain Frame - Black, 38|2699.2 | |765 |Road-650 Black, 58 |1565.98 | |766 |Road-650 Black, 60 |1565.98 | |767 |Road-650 Black, 62 |1565.98 | |768 |Road-650 Black, 44 |1565.98 | |769 |Road-650 Black, 48 |1565.98 | |770 |Road-650 Black, 52 |1565.98 | |775 |Mountain-100 Black, 38 |6749.98 | +---------+-----------------------------+------------+ only showing top 20 rows dfProduct . where ( dfProduct . ListPrice * 2 > 100 ) \\ . select ( dfProduct . ProductID , dfProduct [ 'Name' ], dfProduct . ListPrice * 2 ) \\ . show ( truncate = False ) +---------+-------------------------+---------------+ |ProductID|Name |(ListPrice * 2)| +---------+-------------------------+---------------+ |680 |HL Road Frame - Black, 58|2863.0 | |706 |HL Road Frame - Red, 58 |2863.0 | |717 |HL Road Frame - Red, 62 |2863.0 | |718 |HL Road Frame - Red, 44 |2863.0 | |719 |HL Road Frame - Red, 48 |2863.0 | |720 |HL Road Frame - Red, 52 |2863.0 | |721 |HL Road Frame - Red, 56 |2863.0 | |722 |LL Road Frame - Black, 58|674.44 | |723 |LL Road Frame - Black, 60|674.44 | |724 |LL Road Frame - Black, 62|674.44 | |725 |LL Road Frame - Red, 44 |674.44 | |726 |LL Road Frame - Red, 48 |674.44 | |727 |LL Road Frame - Red, 52 |674.44 | |728 |LL Road Frame - Red, 58 |674.44 | |729 |LL Road Frame - Red, 60 |674.44 | |730 |LL Road Frame - Red, 62 |674.44 | |731 |ML Road Frame - Red, 44 |1189.66 | |732 |ML Road Frame - Red, 48 |1189.66 | |733 |ML Road Frame - Red, 52 |1189.66 | |734 |ML Road Frame - Red, 58 |1189.66 | +---------+-------------------------+---------------+ only showing top 20 rows # SELECT ProductID, Name, ListPrice # FROM Product # WHERE Color = 'black' # ORDER BY ProductID dfProduct . filter ( \"Color = 'Black'\" ) \\ . select ( 'ProductID' , 'Name' , 'ListPrice' ) \\ . orderBy ( 'ListPrice' ) \\ . show ( truncate = False ) +---------+--------------------------+---------+ |ProductID|Name |ListPrice| +---------+--------------------------+---------+ |860 |Half-Finger Gloves, L |24.49 | |859 |Half-Finger Gloves, M |24.49 | |858 |Half-Finger Gloves, S |24.49 | |708 |Sport-100 Helmet, Black |34.99 | |862 |Full-Finger Gloves, M |37.99 | |861 |Full-Finger Gloves, S |37.99 | |863 |Full-Finger Gloves, L |37.99 | |841 |Men's Sports Shorts, S |59.99 | |849 |Men's Sports Shorts, M |59.99 | |851 |Men's Sports Shorts, XL |59.99 | |850 |Men's Sports Shorts, L |59.99 | |815 |LL Mountain Front Wheel |60.745 | |868 |Women's Mountain Shorts, M|69.99 | |869 |Women's Mountain Shorts, L|69.99 | |867 |Women's Mountain Shorts, S|69.99 | |853 |Women's Tights, M |74.99 | |854 |Women's Tights, L |74.99 | |852 |Women's Tights, S |74.99 | |818 |LL Road Front Wheel |85.565 | |823 |LL Mountain Rear Wheel |87.745 | +---------+--------------------------+---------+ only showing top 20 rows # Find all orders and details on black product, # return the product SalesOrderID, SalesOrderDetailID, Name, UnitPrice, and OrderQty # SELECT SalesOrderID, SalesOrderDetailID, Name, UnitPrice, OrderQty # FROM SalesLT.SalesOrderDetail, SalesLT.Product # WHERE SalesOrderDetail.ProductID = Product.ProductID AND Color = 'Black' # SELECT SalesOrderID, SalesOrderDetailID, Name, UnitPrice, OrderQty # FROM SalesLT.SalesOrderDetail # JOIN SalesLT.Product ON SalesOrderDetail.ProductID = Product.ProductID # WHERE Color = 'Black' # Spark SQL supports natural joins dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) \\ . filter ( \"Color='Black'\" ) \\ . show () # If we move the filter to after select, it still works. Why? +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71797| 111045|LL Road Frame - B...| 202.332| 3| | 71783| 110730|LL Road Frame - B...| 202.332| 6| | 71938| 113297|LL Road Frame - B...| 202.332| 3| | 71915| 113090|LL Road Frame - B...| 202.332| 2| | 71815| 111451|LL Road Frame - B...| 202.332| 1| | 71797| 111044|LL Road Frame - B...| 202.332| 1| | 71783| 110710|LL Road Frame - B...| 202.332| 4| | 71936| 113260|HL Mountain Frame...| 809.76| 4| | 71899| 112937|HL Mountain Frame...| 809.76| 1| | 71845| 112137|HL Mountain Frame...| 809.76| 2| | 71832| 111806|HL Mountain Frame...| 809.76| 4| | 71780| 110622|HL Mountain Frame...| 809.76| 1| | 71936| 113235|HL Mountain Frame...| 809.76| 4| | 71845| 112134|HL Mountain Frame...| 809.76| 3| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows # This also works: d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) d1 . show () d2 = d1 . filter ( \"Color = 'Black'\" ) d2 . show () d2 . explain () +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113278|Sport-100 Helmet,...| 20.994| 3| | 71936| 113228|Sport-100 Helmet,...| 20.994| 1| | 71902| 112980|Sport-100 Helmet,...| 20.994| 2| | 71797| 111075|Sport-100 Helmet,...| 20.994| 6| | 71784| 110794|Sport-100 Helmet,...| 20.994| 10| | 71783| 110751|Sport-100 Helmet,...| 20.994| 10| | 71782| 110709|Sport-100 Helmet,...| 20.994| 3| | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71938| 113282|Sport-100 Helmet,...| 20.994| 3| | 71902| 112995|Sport-100 Helmet,...| 20.994| 7| | 71863| 112395|Sport-100 Helmet,...| 20.994| 1| | 71797| 111038|Sport-100 Helmet,...| 20.994| 4| | 71784| 110753|Sport-100 Helmet,...| 20.994| 2| | 71783| 110749|Sport-100 Helmet,...| 19.2445| 15| | 71782| 110708|Sport-100 Helmet,...| 20.994| 6| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71797| 111045|LL Road Frame - B...| 202.332| 3| | 71783| 110730|LL Road Frame - B...| 202.332| 6| | 71938| 113297|LL Road Frame - B...| 202.332| 3| | 71915| 113090|LL Road Frame - B...| 202.332| 2| | 71815| 111451|LL Road Frame - B...| 202.332| 1| | 71797| 111044|LL Road Frame - B...| 202.332| 1| | 71783| 110710|LL Road Frame - B...| 202.332| 4| | 71936| 113260|HL Mountain Frame...| 809.76| 4| | 71899| 112937|HL Mountain Frame...| 809.76| 1| | 71845| 112137|HL Mountain Frame...| 809.76| 2| | 71832| 111806|HL Mountain Frame...| 809.76| 4| | 71780| 110622|HL Mountain Frame...| 809.76| 1| | 71936| 113235|HL Mountain Frame...| 809.76| 4| | 71845| 112134|HL Mountain Frame...| 809.76| 3| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows == Physical Plan == *(2) Project [SalesOrderID#217, SalesOrderDetailID#218, Name#168, UnitPrice#221, OrderQty#219] +- *(2) BroadcastHashJoin [ProductID#220], [ProductID#167], Inner, BuildLeft :- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[3, int, true] as bigint))), [id=#380] : +- *(1) Project [SalesOrderID#217, SalesOrderDetailID#218, OrderQty#219, ProductID#220, UnitPrice#221] : +- *(1) Filter isnotnull(ProductID#220) : +- FileScan csv [SalesOrderID#217,SalesOrderDetailID#218,OrderQty#219,ProductID#220,UnitPrice#221] Batched: false, DataFilters: [isnotnull(ProductID#220)], Format: CSV, Location: InMemoryFileIndex[file:/content/SalesOrderDetail.csv], PartitionFilters: [], PushedFilters: [IsNotNull(ProductID)], ReadSchema: struct<SalesOrderID:int,SalesOrderDetailID:int,OrderQty:int,ProductID:int,UnitPrice:double> +- *(2) Project [ProductID#167, Name#168] +- *(2) Filter ((isnotnull(Color#170) AND (Color#170 = Black)) AND isnotnull(ProductID#167)) +- FileScan csv [ProductID#167,Name#168,Color#170] Batched: false, DataFilters: [isnotnull(Color#170), (Color#170 = Black), isnotnull(ProductID#167)], Format: CSV, Location: InMemoryFileIndex[file:/content/Product.csv], PartitionFilters: [], PushedFilters: [IsNotNull(Color), EqualTo(Color,Black), IsNotNull(ProductID)], ReadSchema: struct<ProductID:int,Name:string,Color:string> # SparkSQL performs optimization depending on whether intermediate dataframe are cached or not: d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) d1 . persist () d1 . show () +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113278|Sport-100 Helmet,...| 20.994| 3| | 71936| 113228|Sport-100 Helmet,...| 20.994| 1| | 71902| 112980|Sport-100 Helmet,...| 20.994| 2| | 71797| 111075|Sport-100 Helmet,...| 20.994| 6| | 71784| 110794|Sport-100 Helmet,...| 20.994| 10| | 71783| 110751|Sport-100 Helmet,...| 20.994| 10| | 71782| 110709|Sport-100 Helmet,...| 20.994| 3| | 71938| 113295|Sport-100 Helmet,...| 20.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71938| 113282|Sport-100 Helmet,...| 20.994| 3| | 71902| 112995|Sport-100 Helmet,...| 20.994| 7| | 71863| 112395|Sport-100 Helmet,...| 20.994| 1| | 71797| 111038|Sport-100 Helmet,...| 20.994| 4| | 71784| 110753|Sport-100 Helmet,...| 20.994| 2| | 71783| 110749|Sport-100 Helmet,...| 19.2445| 15| | 71782| 110708|Sport-100 Helmet,...| 20.994| 6| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows d2 = d1 . filter ( \"Color = 'Black'\" ) #d2 = d1.filter(\"OrderQty >= 10\") d2 . show () d2 . explain () +------------+------------------+--------------------+---------+--------+ |SalesOrderID|SalesOrderDetailID| Name|UnitPrice|OrderQty| +------------+------------------+--------------------+---------+--------+ | 71938| 113295|Sport-100 Helmet,...| 29.994| 5| | 71902| 112988|Sport-100 Helmet,...| 20.994| 4| | 71797| 111082|Sport-100 Helmet,...| 20.2942| 12| | 71784| 110795|Sport-100 Helmet,...| 20.2942| 12| | 71783| 110752|Sport-100 Helmet,...| 20.2942| 11| | 71782| 110690|Sport-100 Helmet,...| 20.994| 7| | 71797| 111045|LL Road Frame - B...| 202.332| 3| | 71783| 110730|LL Road Frame - B...| 202.332| 6| | 71938| 113297|LL Road Frame - B...| 202.332| 3| | 71915| 113090|LL Road Frame - B...| 202.332| 2| | 71815| 111451|LL Road Frame - B...| 202.332| 1| | 71797| 111044|LL Road Frame - B...| 202.332| 1| | 71783| 110710|LL Road Frame - B...| 202.332| 4| | 71936| 113260|HL Mountain Frame...| 809.76| 4| | 71899| 112937|HL Mountain Frame...| 809.76| 1| | 71845| 112137|HL Mountain Frame...| 809.76| 2| | 71832| 111806|HL Mountain Frame...| 809.76| 4| | 71780| 110622|HL Mountain Frame...| 809.76| 1| | 71936| 113235|HL Mountain Frame...| 809.76| 4| | 71845| 112134|HL Mountain Frame...| 809.76| 3| +------------+------------------+--------------------+---------+--------+ only showing top 20 rows == Physical Plan == *(2) Project [SalesOrderID#112, SalesOrderDetailID#113, Name#63, UnitPrice#116, OrderQty#114] +- *(2) BroadcastHashJoin [ProductID#115], [ProductID#62], Inner, BuildLeft :- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[3, int, true] as bigint))), [id=#280] : +- *(1) Project [SalesOrderID#112, SalesOrderDetailID#113, OrderQty#114, ProductID#115, UnitPrice#116] : +- *(1) Filter isnotnull(ProductID#115) : +- FileScan csv [SalesOrderID#112,SalesOrderDetailID#113,OrderQty#114,ProductID#115,UnitPrice#116] Batched: false, DataFilters: [isnotnull(ProductID#115)], Format: CSV, Location: InMemoryFileIndex[file:/csproject/msbd5003/public_html/data/SalesOrderDetail.csv], PartitionFilters: [], PushedFilters: [IsNotNull(ProductID)], ReadSchema: struct<SalesOrderID:int,SalesOrderDetailID:int,OrderQty:int,ProductID:int,UnitPrice:double> +- *(2) Project [ProductID#62, Name#63] +- *(2) Filter ((isnotnull(Color#65) AND (Color#65 = Black)) AND isnotnull(ProductID#62)) +- FileScan csv [ProductID#62,Name#63,Color#65] Batched: false, DataFilters: [isnotnull(Color#65), (Color#65 = Black), isnotnull(ProductID#62)], Format: CSV, Location: InMemoryFileIndex[file:/csproject/msbd5003/public_html/data/Product.csv], PartitionFilters: [], PushedFilters: [IsNotNull(Color), EqualTo(Color,Black), IsNotNull(ProductID)], ReadSchema: struct<ProductID:int,Name:string,Color:string> # This will report an error: d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . select ( 'SalesOrderID' , 'SalesOrderDetailID' , 'Name' , 'UnitPrice' , 'OrderQty' ) d1 . write . csv ( 'temp.csv' , mode = 'overwrite' , header = True ) d2 = spark . read . csv ( 'temp.csv' , header = True , inferSchema = True ) d2 . filter ( \"Color = 'Black'\" ) . show () --------------------------------------------------------------------------- AnalysisException Traceback (most recent call last) <ipython-input-18-168595bb0376> in <module> 5 d1.write.csv('temp.csv', mode = 'overwrite', header = True) 6 d2 = spark.read.csv('temp.csv', header = True, inferSchema = True) ----> 7 d2.filter(\"Color = 'Black'\").show() /csproject/msbd5003/python/pyspark/sql/dataframe.py in filter(self, condition) 1457 \"\"\" 1458 if isinstance(condition, basestring): -> 1459 jdf = self._jdf.filter(condition) 1460 elif isinstance(condition, Column): 1461 jdf = self._jdf.filter(condition._jc) /csproject/msbd5003/python/lib/py4j-0.10.9-src.zip/py4j/java_gateway.py in __call__(self, *args) 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( -> 1305 answer, self.gateway_client, self.target_id, self.name) 1306 1307 for temp_arg in temp_args: /csproject/msbd5003/python/pyspark/sql/utils.py in deco(*a, **kw) 135 # Hide where the exception came from that shows a non-Pythonic 136 # JVM exception message. --> 137 raise_from(converted) 138 else: 139 raise /csproject/msbd5003/python/pyspark/sql/utils.py in raise_from(e) AnalysisException: cannot resolve '`Color`' given input columns: [Name, OrderQty, SalesOrderDetailID, SalesOrderID, UnitPrice]; line 1 pos 0; 'Filter ('Color = Black) +- Relation[SalesOrderID#580,SalesOrderDetailID#581,Name#582,UnitPrice#583,OrderQty#584] csv # Find all orders that include at least one black product, # return the product SalesOrderID, Name, UnitPrice, and OrderQty # SELECT DISTINCT SalesOrderID # FROM SalesLT.SalesOrderDetail # JOIN SalesLT.Product ON SalesOrderDetail.ProductID = Product.ProductID # WHERE Color = 'Black' dfDetail . join ( dfProduct . filter ( \"Color='Black'\" ), 'ProductID' ) \\ . select ( 'SalesOrderID' ) \\ . distinct () \\ . show () +------------+ |SalesOrderID| +------------+ | 71902| | 71832| | 71915| | 71831| | 71898| | 71935| | 71938| | 71845| | 71783| | 71815| | 71936| | 71863| | 71780| | 71782| | 71899| | 71784| | 71797| +------------+ # How many colors in the products? # SELECT COUNT(DISTINCT Color) # FROM SalesLT.Product dfProduct . select ( 'Color' ) . distinct () . count () # It's 1 more than standard SQL. In standard SQL, COUNT() does not count NULLs. 10 # Find the total price of each order, # return SalesOrderID and total price (column name should be \u2018totalprice\u2019) # SELECT SalesOrderID, SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) AS TotalPrice # FROM SalesLT.SalesOrderDetail # GROUP BY SalesOrderID dfDetail . select ( '*' , ( dfDetail . UnitPrice * dfDetail . OrderQty * ( 1 - dfDetail . UnitPriceDiscount )) . alias ( 'netprice' )) \\ . groupBy ( 'SalesOrderID' ) . sum ( 'netprice' ) \\ . withColumnRenamed ( 'sum(netprice)' , 'TotalPrice' ) \\ . show () +------------+------------------+ |SalesOrderID| sum(netprice)| +------------+------------------+ | 71867| 858.9| | 71902|59894.209199999976| | 71832| 28950.678108| | 71915|1732.8899999999999| | 71946| 31.584| | 71895|221.25600000000003| | 71816|2847.4079999999994| | 71831| 1712.946| | 71923| 96.108824| | 71858|11528.844000000001| | 71917| 37.758| | 71897| 10585.05| | 71885| 524.664| | 71856|500.30400000000003| | 71898| 53248.69200000002| | 71774| 713.796| | 71796| 47848.02600000001| | 71935|5533.8689079999995| | 71938| 74160.228| | 71845| 34118.5356| +------------+------------------+ only showing top 20 rows # Find the total price of each order where the total price > 10000 # SELECT SalesOrderID, SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) AS TotalPrice # FROM SalesLT.SalesOrderDetail # GROUP BY SalesOrderID # HAVING SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) > 10000 dfDetail . select ( '*' , ( dfDetail . UnitPrice * dfDetail . OrderQty * ( 1 - dfDetail . UnitPriceDiscount )) . alias ( 'netprice' )) \\ . groupBy ( 'SalesOrderID' ) . sum ( 'netprice' ) \\ . withColumnRenamed ( 'sum(netprice)' , 'TotalPrice' ) \\ . where ( 'TotalPrice > 10000' ) \\ . show () +------------+------------------+ |SalesOrderID| TotalPrice| +------------+------------------+ | 71902|59894.209199999976| | 71832| 28950.678108| | 71858|11528.844000000001| | 71897| 10585.05| | 71898| 53248.69200000002| | 71796| 47848.02600000001| | 71938| 74160.228| | 71845| 34118.5356| | 71783| 65683.367986| | 71936| 79589.61602399996| | 71780|29923.007999999998| | 71782| 33319.98600000001| | 71784| 89869.27631400003| | 71797| 65123.46341800001| +------------+------------------+ # Find the total price on the black products of each order where the total price > 10000 # SELECT SalesOrderID, SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) AS TotalPrice # FROM SalesLT.SalesOrderDetail, SalesLT.Product # WHERE SalesLT.SalesOrderDetail.ProductID = SalesLT.Product.ProductID AND Color = 'Black' # GROUP BY SalesOrderID # HAVING SUM(UnitPrice*OrderQty*(1-UnitPriceDiscount)) > 10000 dfDetail . select ( '*' , ( dfDetail . UnitPrice * dfDetail . OrderQty * ( 1 - dfDetail . UnitPriceDiscount )) . alias ( 'netprice' )) \\ . join ( dfProduct , 'ProductID' ) \\ . where ( \"Color = 'Black'\" ) \\ . groupBy ( 'SalesOrderID' ) . sum ( 'netprice' ) \\ . withColumnRenamed ( 'sum(netprice)' , 'TotalPrice' ) \\ . where ( 'TotalPrice > 10000' ) \\ . show () +------------+------------------+ |SalesOrderID| TotalPrice| +------------+------------------+ | 71902|26677.883999999995| | 71832| 16883.748108| | 71938| 33779.448| | 71845| 18109.836| | 71783|15524.117476000003| | 71936| 44490.290424| | 71780| 16964.322| | 71797| 27581.613792| +------------+------------------+ # For each customer, find the total quantity of black products bought. # Report CustomerID, FirstName, LastName, and total quantity # select saleslt.customer.customerid, FirstName, LastName, sum(orderqty) # from saleslt.customer # left outer join # ( # saleslt.salesorderheader # join saleslt.salesorderdetail # on saleslt.salesorderdetail.salesorderid = saleslt.salesorderheader.salesorderid # join saleslt.product # on saleslt.product.productid = saleslt.salesorderdetail.productid and color = 'black' # ) # on saleslt.customer.customerid = saleslt.salesorderheader.customerid # group by saleslt.customer.customerid, FirstName, LastName # order by sum(orderqty) desc d1 = dfDetail . join ( dfProduct , 'ProductID' ) \\ . where ( 'Color = \"Black\"' ) \\ . join ( dfHeader , 'SalesOrderID' ) \\ . groupBy ( 'CustomerID' ) . sum ( 'OrderQty' ) dfCustomer . join ( d1 , 'CustomerID' , 'left_outer' ) \\ . select ( 'CustomerID' , 'FirstName' , 'LastName' , 'sum(OrderQty)' ) \\ . orderBy ( 'sum(OrderQty)' , ascending = False ) \\ . show () +----------+------------+------------+-------------+ |CustomerID| FirstName| LastName|sum(OrderQty)| +----------+------------+------------+-------------+ | 30050| Krishna|Sunkammurali| 89| | 29796| Jon| Grande| 65| | 29957| Kevin| Liu| 62| | 29929| Jeffrey| Kurtz| 46| | 29546| Christopher| Beck| 45| | 29922| Pamala| Kotc| 34| | 30113| Raja| Venugopal| 34| | 29938| Frank| Campbell| 29| | 29736| Terry| Eminhizer| 23| | 29485| Catherine| Abel| 10| | 30019| Matthew| Miller| 9| | 29932| Rebecca| Laszlo| 7| | 29975| Walter| Mays| 5| | 29638| Rosmarie| Carroll| 2| | 29531| Cory| Booth| 1| | 30089|Michael John| Troyer| 1| | 29568| Donald| Blanton| 1| | 29868| Denean| Ison| null| | 29646| Stacey| Cereghino| null| | 29905| Elizabeth| Keyser| null| +----------+------------+------------+-------------+ only showing top 20 rows","title":"Rewriting SQL with DataFrame API"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#embed-sql-queries","text":"You can also run SQL queries over dataframes once you register them as temporary tables within the SparkSession. # Register the dataframe as a temporary view called HVAC df . createOrReplaceTempView ( 'HVAC' ) spark . sql ( 'SELECT * FROM HVAC WHERE BuildingAge >= 10' ) . show () +----------+-----------+-----------+-----------+------------+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country| +----------+-----------+-----------+-----------+------------+ | 1| M1| 25| AC1000| USA| | 2| M2| 27| FN39TG| France| | 3| M3| 28| JDNS77| Brazil| | 4| M4| 17| GG1919| Finland| | 7| M7| 13| FN39TG|South Africa| | 8| M8| 25| JDNS77| Australia| | 9| M9| 11| GG1919| Mexico| | 10| M10| 23| ACMAX22| China| | 11| M11| 14| AC1000| Belgium| | 12| M12| 26| FN39TG| Finland| | 13| M13| 25| JDNS77|Saudi Arabia| | 14| M14| 17| GG1919| Germany| | 15| M15| 19| ACMAX22| Israel| | 16| M16| 23| AC1000| Turkey| | 17| M17| 11| FN39TG| Egypt| | 18| M18| 25| JDNS77| Indonesia| | 19| M19| 14| GG1919| Canada| | 20| M20| 19| ACMAX22| Argentina| +----------+-----------+-----------+-----------+------------+ # Can even mix DataFrame API with SQL: df . where ( 'BuildingAge >= 10' ) . createOrReplaceTempView ( 'OldBuildings' ) spark . sql ( 'SELECT HVACproduct, COUNT(*) FROM OldBuildings GROUP BY HVACproduct' ) . show () +-----------+--------+ |HVACproduct|count(1)| +-----------+--------+ | ACMAX22| 3| | AC1000| 3| | JDNS77| 4| | FN39TG| 4| | GG1919| 4| +-----------+--------+ d1 = spark . sql ( 'SELECT * FROM HVAC WHERE BuildingAge >= 10' ) d1 . groupBy ( 'HVACproduct' ) . count () . show () +-----------+-----+ |HVACproduct|count| +-----------+-----+ | ACMAX22| 3| | AC1000| 3| | JDNS77| 4| | FN39TG| 4| | GG1919| 4| +-----------+-----+ # UDF from pyspark.sql.functions import udf from pyspark.sql.types import IntegerType slen = udf ( lambda s : len ( s ) + 2 , IntegerType ()) df . select ( '*' , slen ( df [ 'Country' ]) . alias ( 'slen' )) . show () +----------+-----------+-----------+-----------+------------+----+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country|slen| +----------+-----------+-----------+-----------+------------+----+ | 1| M1| 25| AC1000| USA| 5| | 2| M2| 27| FN39TG| France| 8| | 3| M3| 28| JDNS77| Brazil| 8| | 4| M4| 17| GG1919| Finland| 9| | 5| M5| 3| ACMAX22| Hong Kong| 11| | 6| M6| 9| AC1000| Singapore| 11| | 7| M7| 13| FN39TG|South Africa| 14| | 8| M8| 25| JDNS77| Australia| 11| | 9| M9| 11| GG1919| Mexico| 8| | 10| M10| 23| ACMAX22| China| 7| | 11| M11| 14| AC1000| Belgium| 9| | 12| M12| 26| FN39TG| Finland| 9| | 13| M13| 25| JDNS77|Saudi Arabia| 14| | 14| M14| 17| GG1919| Germany| 9| | 15| M15| 19| ACMAX22| Israel| 8| | 16| M16| 23| AC1000| Turkey| 8| | 17| M17| 11| FN39TG| Egypt| 7| | 18| M18| 25| JDNS77| Indonesia| 11| | 19| M19| 14| GG1919| Canada| 8| | 20| M20| 19| ACMAX22| Argentina| 11| +----------+-----------+-----------+-----------+------------+----+ spark . udf . register ( 'slen' , lambda s : len ( s ), IntegerType ()) spark . sql ( 'SELECT *, slen(Country) AS slen FROM HVAC' ) . show () +----------+-----------+-----------+-----------+------------+----+ |BuildingID|BuildingMgr|BuildingAge|HVACproduct| Country|slen| +----------+-----------+-----------+-----------+------------+----+ | 1| M1| 25| AC1000| USA| 3| | 2| M2| 27| FN39TG| France| 6| | 3| M3| 28| JDNS77| Brazil| 6| | 4| M4| 17| GG1919| Finland| 7| | 5| M5| 3| ACMAX22| Hong Kong| 9| | 6| M6| 9| AC1000| Singapore| 9| | 7| M7| 13| FN39TG|South Africa| 12| | 8| M8| 25| JDNS77| Australia| 9| | 9| M9| 11| GG1919| Mexico| 6| | 10| M10| 23| ACMAX22| China| 5| | 11| M11| 14| AC1000| Belgium| 7| | 12| M12| 26| FN39TG| Finland| 7| | 13| M13| 25| JDNS77|Saudi Arabia| 12| | 14| M14| 17| GG1919| Germany| 7| | 15| M15| 19| ACMAX22| Israel| 6| | 16| M16| 23| AC1000| Turkey| 6| | 17| M17| 11| FN39TG| Egypt| 5| | 18| M18| 25| JDNS77| Indonesia| 9| | 19| M19| 14| GG1919| Canada| 6| | 20| M20| 19| ACMAX22| Argentina| 9| +----------+-----------+-----------+-----------+------------+----+","title":"Embed SQL queries"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#flexible-data-model","text":"Sample data file at https://www.cse.ust.hk/msbd5003/data/products.json df = spark . read . json ( '../data/products.json' ) df . printSchema () root |-- dimensions: struct (nullable = true) | |-- height: double (nullable = true) | |-- length: double (nullable = true) | |-- width: double (nullable = true) |-- id: long (nullable = true) |-- name: string (nullable = true) |-- price: double (nullable = true) |-- tags: array (nullable = true) | |-- element: string (containsNull = true) |-- warehouseLocation: struct (nullable = true) | |-- latitude: double (nullable = true) | |-- longitude: double (nullable = true) df . show () +----------------+---+----------------+-----+-----------+-----------------+ | dimensions| id| name|price| tags|warehouseLocation| +----------------+---+----------------+-----+-----------+-----------------+ |[9.5, 7.0, 12.0]| 2|An ice sculpture| 12.5|[cold, ice]| [-78.75, 20.4]| | [1.0, 3.1, 1.0]| 3| A blue mouse| 25.5| null| [54.4, -32.7]| +----------------+---+----------------+-----+-----------+-----------------+ # Accessing nested fields df . select ( df [ 'dimensions.height' ]) . show () +------+ |height| +------+ | 9.5| | 1.0| +------+ df . select ( 'dimensions.height' ) . show () +------+ |height| +------+ | 9.5| | 1.0| +------+ df . select ( 'dimensions.height' ) \\ . filter ( \"tags[0] = 'cold' AND warehouseLocation.latitude < 0\" ) \\ . show () +------+ |height| +------+ | 9.5| +------+ df . rdd . take ( 3 ) [Row(dimensions=Row(height=9.5, length=7.0, width=12.0), id=2, name='An ice sculpture', price=12.5, tags=['cold', 'ice'], warehouseLocation=Row(latitude=-78.75, longitude=20.4)), Row(dimensions=Row(height=1.0, length=3.1, width=1.0), id=3, name='A blue mouse', price=25.5, tags=None, warehouseLocation=Row(latitude=54.4, longitude=-32.7))]","title":"Flexible Data Model"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#converting-between-rdd-and-dataframe","text":"Sample data file at: https://www.cse.ust.hk/msbd5003/data/people.txt # Load a text file and convert each line to a Row. lines = sc . textFile ( \"../data/people.txt\" ) def parse ( l ): a = l . split ( ',' ) return ( a [ 0 ], int ( a [ 1 ])) rdd = lines . map ( parse ) rdd . collect () [('Michael', 29), ('Andy', 30), ('Justin', 19)] # Create the DataFrame from an RDD of tuples, schema is inferred df = spark . createDataFrame ( rdd ) df . printSchema () df . show () root |-- _1: string (nullable = true) |-- _2: long (nullable = true) +-------+---+ | _1| _2| +-------+---+ |Michael| 29| | Andy| 30| | Justin| 19| +-------+---+ # Create the DataFrame from an RDD of tuples with column names, type is inferred df = spark . createDataFrame ( rdd , [ 'name' , 'age' ]) df . printSchema () df . show () root |-- name: string (nullable = true) |-- age: long (nullable = true) +-------+---+ | name|age| +-------+---+ |Michael| 29| | Andy| 30| | Justin| 19| +-------+---+ # Create the DataFrame from an RDD of Rows, type is given in the Row objects from pyspark.sql import Row rdd_rows = rdd . map ( lambda p : Row ( name = p [ 0 ], age = p [ 1 ])) df = spark . createDataFrame ( rdd_rows ) df . printSchema () df . show () root |-- name: string (nullable = true) |-- age: long (nullable = true) +-------+---+ | name|age| +-------+---+ |Michael| 29| | Andy| 30| | Justin| 19| +-------+---+ # Row fields with types incompatible with that of previous rows will be turned into nulls row1 = Row ( name = \"Alice\" , age = 11 ) row2 = Row ( name = \"Bob\" , age = '12' ) rdd_rows = sc . parallelize ([ row1 , row2 ]) df1 = spark . createDataFrame ( rdd_rows ) df1 . show () +-----+----+ | name| age| +-----+----+ |Alice| 11| | Bob|null| +-----+----+ # rdd returns the content as an RDD of Rows teenagers = df . filter ( 'age >= 13 and age <= 19' ) teenNames = teenagers . rdd . map ( lambda p : \"Name: \" + p . name ) teenNames . collect () ['Name: Justin']","title":"Converting between RDD and DataFrame"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#note","text":"DataFrames are stored using columnar storage with compression RDDs are stored using row storage without compression The RDD view of DataFrame just provides an interface, the Row objects are constructed on the fly and do not necessarily represent the internal storage format of the data","title":"Note:"},{"location":"MSBD5003/notebooks%20in%20class/sparksql/#closure-in-dataframes","text":"data = range ( 10 ) df = spark . createDataFrame ( zip ( data , data )) df . printSchema () df . show () root |-- _1: long (nullable = true) |-- _2: long (nullable = true) +---+---+ | _1| _2| +---+---+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| | 5| 5| | 6| 6| | 7| 7| | 8| 8| | 9| 9| +---+---+ # The 'closure' behaviour in RDD doesn't seem to exist for DataFrames x = 5 df1 = df . filter ( df . _1 < x ) df1 . show () x = 3 df1 . show () +---+---+ | _1| _2| +---+---+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| +---+---+ +---+---+ | _1| _2| +---+---+ | 0| 0| | 1| 1| | 2| 2| | 3| 3| | 4| 4| +---+---+ # Because of the Catalyst optimizer ! df1 . explain () == Physical Plan == *(1) Filter (isnotnull(_1#1265L) AND (_1#1265L < 5)) +- *(1) Scan ExistingRDD[_1#1265L,_2#1266L] def f (): return x / 2 x = 5 df1 = df . select ( df . _1 * 2 + f () + 1 + 1 ) df1 . explain () df1 . show () == Physical Plan == *(1) Project [(((cast((_1#1265L * 2) as double) + 2.5) + 1.0) + 1.0) AS ((((_1 * 2) + 2.5) + 1) + 1)#1296] +- *(1) Scan ExistingRDD[_1#1265L,_2#1266L] +----------------------------+ |((((_1 * 2) + 2.5) + 1) + 1)| +----------------------------+ | 4.5| | 6.5| | 8.5| | 10.5| | 12.5| | 14.5| | 16.5| | 18.5| | 20.5| | 22.5| +----------------------------+ rdd = sc . parallelize ( range ( 10 )) x = 5 a = rdd . filter ( lambda z : z < x ) print ( a . take ( 10 )) x = 3 print ( a . take ( 10 )) [0, 1, 2, 3, 4] [0, 1, 2] counter = 0 def increment_counter ( x ): global counter counter += 1 df . foreach ( increment_counter ) print ( counter ) 0","title":"Closure in DataFrames"},{"location":"MSBD5003/projects/Project/","text":"Install dependencies \u00b6 !pip install googletrans Collecting googletrans Downloading https://files.pythonhosted.org/packages/71/3a/3b19effdd4c03958b90f40fe01c93de6d5280e03843cc5adf6956bfc9512/googletrans-3.0.0.tar.gz Collecting httpx==0.13.3 \u001b[?25l Downloading https://files.pythonhosted.org/packages/54/b4/698b284c6aed4d7c2b4fe3ba5df1fcf6093612423797e76fbb24890dd22f/httpx-0.13.3-py3-none-any.whl (55kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 3.2MB/s \u001b[?25hCollecting rfc3986<2,>=1.3 Downloading https://files.pythonhosted.org/packages/78/be/7b8b99fd74ff5684225f50dd0e865393d2265656ef3b4ba9eaaaffe622b8/rfc3986-1.4.0-py2.py3-none-any.whl Collecting httpcore==0.9.* \u001b[?25l Downloading https://files.pythonhosted.org/packages/dd/d5/e4ff9318693ac6101a2095e580908b591838c6f33df8d3ee8dd953ba96a8/httpcore-0.9.1-py3-none-any.whl (42kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 51kB 4.3MB/s \u001b[?25hRequirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from httpx==0.13.3->googletrans) (2020.11.8) Requirement already satisfied: idna==2.* in /usr/local/lib/python3.6/dist-packages (from httpx==0.13.3->googletrans) (2.10) Collecting hstspreload \u001b[?25l Downloading https://files.pythonhosted.org/packages/d3/3c/cdeaf9ab0404853e77c45d9e8021d0d2c01f70a1bb26e460090926fe2a5e/hstspreload-2020.11.21-py3-none-any.whl (981kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 983kB 6.4MB/s \u001b[?25hRequirement already satisfied: chardet==3.* in /usr/local/lib/python3.6/dist-packages (from httpx==0.13.3->googletrans) (3.0.4) Collecting sniffio Downloading https://files.pythonhosted.org/packages/52/b0/7b2e028b63d092804b6794595871f936aafa5e9322dcaaad50ebf67445b3/sniffio-1.2.0-py3-none-any.whl Collecting h11<0.10,>=0.8 \u001b[?25l Downloading https://files.pythonhosted.org/packages/5a/fd/3dad730b0f95e78aeeb742f96fa7bbecbdd56a58e405d3da440d5bfb90c6/h11-0.9.0-py2.py3-none-any.whl (53kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.0MB/s \u001b[?25hCollecting h2==3.* \u001b[?25l Downloading https://files.pythonhosted.org/packages/25/de/da019bcc539eeab02f6d45836f23858ac467f584bfec7a526ef200242afe/h2-3.2.0-py2.py3-none-any.whl (65kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 71kB 6.7MB/s \u001b[?25hCollecting contextvars>=2.1; python_version < \"3.7\" Downloading https://files.pythonhosted.org/packages/83/96/55b82d9f13763be9d672622e1b8106c85acb83edd7cc2fa5bc67cd9877e9/contextvars-2.4.tar.gz Collecting hyperframe<6,>=5.2.0 Downloading https://files.pythonhosted.org/packages/19/0c/bf88182bcb5dce3094e2f3e4fe20db28a9928cb7bd5b08024030e4b140db/hyperframe-5.2.0-py2.py3-none-any.whl Collecting hpack<4,>=3.0 Downloading https://files.pythonhosted.org/packages/8a/cc/e53517f4a1e13f74776ca93271caef378dadec14d71c61c949d759d3db69/hpack-3.0.0-py2.py3-none-any.whl Collecting immutables>=0.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/99/e0/ea6fd4697120327d26773b5a84853f897a68e33d3f9376b00a8ff96e4f63/immutables-0.14-cp36-cp36m-manylinux1_x86_64.whl (98kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 102kB 7.1MB/s \u001b[?25hBuilding wheels for collected packages: googletrans, contextvars Building wheel for googletrans (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for googletrans: filename=googletrans-3.0.0-cp36-none-any.whl size=15736 sha256=41d6607e625fb84483fb92ce5870ff80dce825ee8cdee5d005a6f66ac2b4f9a6 Stored in directory: /root/.cache/pip/wheels/28/1a/a7/eaf4d7a3417a0c65796c547cff4deb6d79c7d14c2abd29273e Building wheel for contextvars (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for contextvars: filename=contextvars-2.4-cp36-none-any.whl size=7666 sha256=bac0c5e9bd7288c7b7f764befbcfe3747b54567305e833c1eaceb02301a456d8 Stored in directory: /root/.cache/pip/wheels/a5/7d/68/1ebae2668bda2228686e3c1cf16f2c2384cea6e9334ad5f6de Successfully built googletrans contextvars Installing collected packages: rfc3986, h11, hyperframe, hpack, h2, immutables, contextvars, sniffio, httpcore, hstspreload, httpx, googletrans Successfully installed contextvars-2.4 googletrans-3.0.0 h11-0.9.0 h2-3.2.0 hpack-3.0.0 hstspreload-2020.11.21 httpcore-0.9.1 httpx-0.13.3 hyperframe-5.2.0 immutables-0.14 rfc3986-1.4.0 sniffio-1.2.0 !pip install jieba Requirement already satisfied: jieba in /usr/local/lib/python3.6/dist-packages (0.42.1) !pip install snownlp Collecting snownlp \u001b[?25l Downloading https://files.pythonhosted.org/packages/3d/b3/37567686662100d3bce62d3b0f2adec18ab4b9ff2b61abd7a61c39343c1d/snownlp-0.12.3.tar.gz (37.6MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 37.6MB 1.2MB/s \u001b[?25hBuilding wheels for collected packages: snownlp Building wheel for snownlp (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for snownlp: filename=snownlp-0.12.3-cp36-none-any.whl size=37760959 sha256=a9e56804b51b20b5955ed305562310e2cffd780244fcb895b08cbbef094e126c Stored in directory: /root/.cache/pip/wheels/f3/81/25/7c197493bd7daf177016f1a951c5c3a53b1c7e9339fd11ec8f Successfully built snownlp Installing collected packages: snownlp Successfully installed snownlp-0.12.3 !pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 39kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 50.5MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=ff2703910c5d2146d9e5eb2fe81cfb913b4ef6e0f9485fbd4a600fe77ed82946 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.context import SparkContext from pyspark.sql.session import SparkSession from pyspark.sql.types import Row # NLP Module from snownlp import SnowNLP import jieba # translation from googletrans import Translator import matplotlib.pyplot as plt import pandas as pd sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) import urllib.request file_url = \"https://github.com/sirily11/hot-keywords/releases/download/master/Sina_keyword.csv\" file_name = \"Sina_keyword.csv\" urllib . request . urlretrieve ( file_url , file_name ) ('Sina_keyword.csv', <http.client.HTTPMessage at 0x7f58c7be1b38>) Read csv file \u00b6 from pyspark.sql.types import StructType , StructField , IntegerType , StringType , TimestampType schema = StructType ([ StructField ( 'keyword' , StringType (), False ), StructField ( \"content\" , StringType (), False ), StructField ( \"time\" , TimestampType (), False ), StructField ( \"rank\" , IntegerType (), False ), StructField ( \"numbers\" , IntegerType (), False ), ]) df = spark.read.csv(file_name, schema=schema, lineSep=\";\") df.show() --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) <ipython-input-13-a4fd1b0edcab> in <module>() 1 df = spark.read.csv(file_name, schema=schema, lineSep=\";\") ----> 2 df.show() /usr/local/lib/python3.6/dist-packages/pyspark/sql/dataframe.py in show(self, n, truncate, vertical) 438 \"\"\" 439 if isinstance(truncate, bool) and truncate: --> 440 print(self._jdf.showString(n, 20, vertical)) 441 else: 442 print(self._jdf.showString(n, int(truncate), vertical)) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in __call__(self, *args) 1301 proto.END_COMMAND_PART 1302 -> 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( 1305 answer, self.gateway_client, self.target_id, self.name) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command, retry, binary) 1031 connection = self._get_connection() 1032 try: -> 1033 response = connection.send_command(command) 1034 if binary: 1035 return response, self._create_connection_guard(connection) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command) 1198 1199 try: -> 1200 answer = smart_decode(self.stream.readline()[:-1]) 1201 logger.debug(\"Answer received: {0}\".format(answer)) 1202 if answer.startswith(proto.RETURN_MESSAGE): /usr/lib/python3.6/socket.py in readinto(self, b) 584 while True: 585 try: --> 586 return self._sock.recv_into(b) 587 except timeout: 588 self._timeout_occurred = True KeyboardInterrupt: rdd = df.rdd rdd.take(10) [Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u6fb3\u4e9a\u3010\u8d44\u8baf\u3011# #\u4e0a\u6d77\u75ab\u60c5# #\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b \u8ffd\u8e2a\u5bc6\u63a5\u800583\u4eba#\u5e02\u536b\u5065\u59d4\u4eca\u65e9\uff0821\u65e5\uff09\u901a\u62a5\uff1a11\u670820\u65e50\u201424\u65f6\uff0c\u901a\u8fc7\u53e3\u5cb8\u8054\u9632\u8054\u63a7\u673a\u5236\uff0c\u62a5\u544a9\u4f8b\u5883\u5916\u8f93\u5165\u6027\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\u65b0\u589e\u6cbb\u6108\u51fa\u96628\u4f8b\uff0c\u5176\u4e2d\u6765\u81ea\u963f\u8054\u914b1\u4f8b\uff0c\u6765\u81ea\u4fc4\u7f57\u65af1\u4f8b\uff0c\u6765\u81ea\u52a0\u62ff\u59271\u4f8b\uff0c\u6765\u81ea\u9a6c\u91cc1\u4f8b\uff0c\u6765\u81ea\u7f8e\u56fd1\u4f8b\uff0c\u6765\u81ea\u585e\u5c14\u7ef4\u4e9a1\u4f8b\uff0c\u6765\u81ea\u4e4c\u514b\u51701\u4f8b\uff0c\u6765\u81ea\u4e4c\u5179\u522b\u514b\u65af\u57661\u4f8b\u3002\\n11\u670820\u65e50\u201424\u65f6\uff0c\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\\n\u75c5\u4f8b1\u3001\u75c5\u4f8b2\u4e3a\u592b\u59bb\u5173\u7cfb\uff0c\u5e38\u4f4f\u6d66\u4e1c\u65b0\u533a\uff0c\u56e0\u5148\u540e\u51fa\u73b0\u53d1\u70ed\u75c7\u72b6\uff0c\u524d\u5f80\u533b\u7597\u673a\u6784\u53d1\u70ed\u95e8\u8bca\u5c31\u8bca\uff0c\u5373\u88ab\u9694\u79bb\u7559\u89c2\u300211\u670820\u65e5\uff0c\u5e02\u3001\u533a\u75be\u63a7\u4e2d\u5fc3\u6838\u9178\u68c0\u6d4b\u7ed3\u679c\u4e3a\u9633\u6027\u3002\u7ecf\u4e13\u5bb6\u4f1a\u8bca\uff0c\u7efc\u5408\u4e34\u5e8a\u3001\u5f71\u50cf\u5b66\u8868\u73b0\u548c\u5b9e\u9a8c\u5ba4\u6838\u9178\u68c0\u6d4b\u7ed3\u679c\uff0c\u8bca\u65ad\u4e3a\u786e\u8bca\u75c5\u4f8b\u3002\\n\u76ee\u524d\uff0c\u5df2\u8ffd\u8e2a\u5230\u5176\u5728\u672c\u5e02\u7684\u5bc6\u5207\u63a5\u89e6\u800583\u4eba\uff0c\u5747\u5df2\u843d\u5b9e\u96c6\u4e2d\u9694\u79bb\u89c2\u5bdf\u3002\u5bf9\u75c5\u4f8b\u66fe\u6d3b\u52a8\u8fc7\u7684\u573a\u6240\u5df2\u8fdb\u884c\u7ec8\u672b\u6d88\u6bd2\u3002\\n\u622a\u81f311\u670820\u65e524\u65f6\uff0c\u7d2f\u8ba1\u62a5\u544a\u5883\u5916\u8f93\u5165\u6027\u786e\u8bca\u75c5\u4f8b956\u4f8b\uff0c\u51fa\u9662896\u4f8b\uff0c\u5728\u9662\u6cbb\u759760\u4f8b\uff0c\u65e0\u91cd\u75c7\u548c\u5371\u91cd\u75c7\u3002\u73b0\u6709\u5f85\u6392\u67e5\u7684\u7591\u4f3c\u75c5\u4f8b0\u4f8b\u3002\\n\u622a\u81f311\u670820\u65e524\u65f6\uff0c\u7d2f\u8ba1\u62a5\u544a\u672c\u5730\u786e\u8bca\u75c5\u4f8b345\u4f8b\uff0c\u6cbb\u6108\u51fa\u9662335\u4f8b\uff0c\u5728\u9662\u6cbb\u75973\u4f8b\uff0c\u6b7b\u4ea17\u4f8b\u3002\u73b0\u6709\u5f85\u6392\u67e5\u7684\u7591\u4f3c\u75c5\u4f8b0\u4f8b\u3002\\n\u622a\u81f311\u670820\u65e524\u65f6\uff0c\u5c1a\u5728\u533b\u5b66\u89c2\u5bdf\u4e2d\u7684\u65e0\u75c7\u72b6\u611f\u67d3\u80050\u4f8b\u3002 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u3010#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\uff0c\u6b63\u5168\u9762\u5f00\u5c55\u6d41\u884c\u75c5\u5b66\u8c03\u67e5\u3011\u4eca\u5929\u4e0b\u5348\uff0c\u4e0a\u6d77\u6d66\u4e1c\u65b0\u533a\u536b\u5065\u59d4\u62a5\u544a\u4e24\u4f8b\u7591\u4f3c\u65b0\u51a0\u80ba\u708e\u75c5\u4f8b\u3002\u75c5\u4f8b1\uff0c\u7537\uff0c39\u5c81\uff1b\u75c5\u4f8b2\uff0c\u5973\uff0c34\u5c81\uff0c\u4e24\u8005\u7cfb\u592b\u59bb\u5173\u7cfb\u3002\u56e0\u5148\u540e\u51fa\u73b0\u53d1\u70ed\uff0c\u5230\u533b\u9662\u53d1\u70ed\u95e8\u8bca\u5c31\u533b\uff0c\u5373\u88ab\u9694\u79bb\u6392\u67e5\u3002\u4eca\u665a21\u65f6\uff0c\u7ecf\u4e0a\u6d77\u5e02\u75be\u63a7\u4e2d\u5fc3\u65b0\u51a0\u75c5\u6bd2\u6838\u9178\u68c0\u6d4b\uff0c\u7ed3\u679c\u5747\u4e3a\u9633\u6027\u3002\u7ecf\u5e02\u7ea7\u4e13\u5bb6\u4f1a\u8bca\uff0c\u7ed3\u5408\u4e34\u5e8a\u3001\u5f71\u50cf\u5b66\u8868\u73b0\u548c\u5b9e\u9a8c\u5ba4\u6838\u9178\u68c0\u6d4b\u7ed3\u679c\uff0c\u8bca\u65ad\u4e3a\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\\n\u76ee\u524d\uff0c\u4e0a\u6d77\u5e02\u3001\u533a\u76f8\u5173\u90e8\u95e8\u5df2\u7ec4\u6210\u8054\u5408\u6d41\u8c03\u4e13\u5bb6\u961f\u4f0d\uff0c\u5168\u9762\u5f00\u5c55\u6d41\u884c\u75c5\u5b66\u8c03\u67e5\uff0c\u6b63\u5728\u8ffd\u8e2a\u6392\u67e5\u76f8\u5173\u4eba\u5458\uff0c\u5bf9\u76f8\u5173\u4eba\u5458\u548c\u73af\u5883\u91c7\u53d6\u76f8\u5e94\u7684\u9632\u75ab\u63aa\u65bd\u3002\u540e\u7eed\u6392\u67e5\u60c5\u51b5\u548c\u76f8\u5173\u4eba\u5458\u7684\u68c0\u6d4b\u7ed3\u679c\uff0c\u5c06\u7b2c\u4e00\u65f6\u95f4\u5411\u793e\u4f1a\u53d1\u5e03\u3002\uff08\u603b\u53f0\u592e\u89c6\u8bb0\u8005\u9646\u5b66\u8d24\uff09 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u3010#\u5f20\u6587\u5b8f\u79f0\u4e0a\u6d77\u65b0\u589e\u75c5\u4f8b\u4ecd\u5c5e\u6563\u53d1\u75c5\u4f8b#\u3011\\n11\u670821\u65e5\uff0c\u4e0a\u6d77\u5e02\u4e3e\u884c\u65b0\u51a0\u80ba\u708e\u75ab\u60c5\u9632\u63a7\u65b0\u95fb\u53d1\u5e03\u4f1a\u3002\u5f20\u6587\u5b8f\u5728\u4f1a\u4e0a\u8bf4\uff0c\u4e0a\u6d77\u4e0a\u4e00\u4f8b\u6563\u53d1\u75c5\u4f8b\u7684\u5904\u7406\u5df2\u5b8c\u6ee1\u7ed3\u675f\uff0c\u8fd9\u610f\u5473\u7740\uff0c\u6b64\u524d\u4e0a\u6d77\u9488\u5bf9\u75c5\u4f8b\u7684\u5168\u9762\u5e03\u63a7\u3001\u5feb\u901f\u53cd\u5e94\u3001\u7cbe\u51c6\u9632\u63a7\u975e\u5e38\u6709\u6548\u3002\u6309\u716711\u670820\u65e5#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\u7684\u8f68\u8ff9\uff0c\u76ee\u524d\u6ca1\u6709\u770b\u5230\u4ea4\u53c9\u70b9\uff0c\u8fd92\u4f8b\u75c5\u4f8b\u7684\u51fa\u73b0\u4e0e\u6d66\u4e1c\u673a\u573a\u7269\u6d41\u6709\u5173\uff0c\u4e25\u683c\u610f\u4e49\u4e0a\u8fd9\u4e0d\u80fd\u8bf4\u662f\u4e24\u6ce2\uff0c\u5e94\u8be5\u7cbe\u786e\u5b9a\u4e49\u4e3a2\u4e2a\u6563\u53d1\u75c5\u4f8b\u3002L\u4e2d\u65b0\u89c6\u9891\u7684\u5fae\u535a\u89c6\u9891 #\u75be\u75c5\u9884\u9632# \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u3010#\u5f20\u6587\u5b8f\u79f0\u4e0a\u6d77\u65b0\u589e\u75c5\u4f8b\u4ecd\u5c5e\u6563\u53d1\u75c5\u4f8b#\u3011\\n11\u670821\u65e5\uff0c\u4e0a\u6d77\u5e02\u4e3e\u884c\u65b0\u51a0\u80ba\u708e\u75ab\u60c5\u9632\u63a7\u65b0\u95fb\u53d1\u5e03\u4f1a\u3002\u5f20\u6587\u5b8f\u5728\u4f1a\u4e0a\u8bf4\uff0c\u4e0a\u6d77\u4e0a\u4e00\u4f8b\u6563\u53d1\u75c5\u4f8b\u7684\u5904\u7406\u5df2\u5b8c\u6ee1\u7ed3\u675f\uff0c\u8fd9\u610f\u5473\u7740\uff0c\u6b64\u524d\u4e0a\u6d77\u9488\u5bf9\u75c5\u4f8b\u7684\u5168\u9762\u5e03\u63a7\u3001\u5feb\u901f\u53cd\u5e94\u3001\u7cbe\u51c6\u9632\u63a7\u975e\u5e38\u6709\u6548\u3002\u6309\u716711\u670820\u65e5#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\u7684\u8f68\u8ff9\uff0c\u76ee\u524d\u6ca1\u6709\u770b\u5230\u4ea4\u53c9\u70b9\uff0c\u8fd92\u4f8b\u75c5\u4f8b \u5c55\u5f00\u5168\u6587c', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u6700\u8fd1\u4e00\u6bb5\u65f6\u95f4\uff0c\u56fd\u5185\u672c\u571f\u65b0\u589e\u786e\u8bca\u75c5\u4f8b\u7565\u6709\u53cd\u5f39\uff0c\u76ee\u524d\u4f20\u67d3\u6e90\u6682\u65f6\u6ca1\u6709\u516c\u5e03\u884c\u7a0b\u8f68\u8ff9\u5462\u4e5f\u8981\u5c3d\u5feb\u516c\u5e03\u51fa\u6765\uff0c\u51ac\u5929\u4e86\uff0c\u5efa\u8bae\u5927\u5bb6\u5462\u53e3\u7f69\u6234\u4e0a\u3002#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\\n\u8d76\u7d27\u6253\u5f00\u7535\u89c6\u5173\u6ce8\u4e0a\u6d77\u75ab\u60c5\uff01\\n\u76ee\u524d\u4e8b\u53d1\u5c0f\u533a\u8fd8\u672a\u5c01\u95ed\uff01\\n\u53ea\u662f\u505a\u4eba\u5458\u9694\u79bb\u548c\u6838\u9178\u68c0\u6d4b\uff01', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u73b0\u5728\u5df2\u7ecf\u6709\u4e86\u6d88\u606f\uff0c\u8bf4\u662f\u8fd9\u4e24\u4e2a\u75c5\u5386\u548c\u4ee5\u524d\u7684\u75c5\u4f8b\u6ca1\u6709\u5173\u8054\uff0c\u800c\u4e14\u8fd9\u75c5\u5386\u4e2d\u7684\u5973\u65b9\u662f\u533b\u9662\u7684\u62a4\u7406\u4eba\u5458\u3002\u8fd9\u6837\u5c31\u9ebb\u70e6\u4e86\uff0c\u8bf4\u660e\u8fd8\u6709\u65b0\u7684\u4f20\u67d3\u6e90\u3002\\n#\u4e0a\u6d77\u6d66\u4e1c\u533b\u96624015\u4eba\u88ab\u9694\u79bb# \u8d76\u5feb\u627e\u51c6\u6e90\u5934\uff0c\u5207\u65ad\u4f20\u64ad\u9014\u5f84\uff0c\u4e0d\u7136\u9690\u60a3\u592a\u5927\u3002\u4f46\u4e5f\u4e0d\u8981\u8fc7\u4e8e\u7d27\u5f20\uff0c\u6bd5\u7adf\u53ea\u662f\u53d1\u73b0\u4e2a\u522b\u75c5\u4f8b\uff0c\u6ca1\u6709\u5927\u8303\u56f4\u8513\u5ef6\u5f00\u3002\\n\u4e0a\u6d77\u771f\u7684\u592a\u96be\u4e86\uff0c\u8981\u63a5\u5f85\u8fd9\u4e48\u591a\u56fd\u5916\u7684\u611f\u67d3\u8005\uff0c\u53c8\u8981\u627f\u8fd0\u90a3\u4e48\u591a\u7684\u8fdb\u53e3\u51b7\u94fe\u6d77\u9c9c\uff0c\u671f\u5f85\u4e0a\u6d77\u6062\u590d\uff0c\u4e0a\u6d77\u52a0\u6cb9\uff01 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u73b0\u5728\u5df2\u7ecf\u6709\u4e86\u6d88\u606f\uff0c\u8bf4\u662f\u8fd9\u4e24\u4e2a\u75c5\u5386\u548c\u4ee5\u524d\u7684\u75c5\u4f8b\u6ca1\u6709\u5173\u8054\uff0c\u800c\u4e14\u8fd9\u75c5\u5386\u4e2d\u7684\u5973\u65b9\u662f\u533b\u9662\u7684\u62a4\u7406\u4eba\u5458\u3002\u8fd9\u6837\u5c31\u9ebb\u70e6\u4e86\uff0c\u8bf4\u660e\u8fd8\u6709\u65b0\u7684\u4f20\u67d3\u6e90\u3002\\n#\u4e0a\u6d77\u6d66\u4e1c\u533b\u96624015\u4eba\u88ab\u9694\u79bb# \u8d76\u5feb\u627e\u51c6\u6e90\u5934\uff0c\u5207\u65ad\u4f20\u64ad\u9014\u5f84\uff0c\u4e0d\u7136\u9690\u60a3\u592a\u5927\u3002\u4f46\u4e5f\u4e0d\u8981\u8fc7\u4e8e\u7d27\u5f20\uff0c\u6bd5\u7adf\u53ea\u662f\u53d1\u73b0\u4e2a\u522b\u75c5\u4f8b\uff0c\u6ca1\u6709\u5927\u8303\u56f4\u8513\u5ef6\u5f00\u3002 \u5c55\u5f00\u5168\u6587c', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u3010\u4e0a\u6d77\u6628\u65e5\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b \u65b0\u589e\u5883\u5916\u8f93\u51659\u4f8b\u3011\u636e\u4e0a\u6d77\u5e02\u536b\u5065\u59d4\u901a\u62a5\uff0c11\u670820\u65e50\u201424\u65f6\uff0c\u901a\u8fc7\u53e3\u5cb8\u8054\u9632\u8054\u63a7\u673a\u5236\uff0c\u62a5\u544a9\u4f8b\u5883\u5916\u8f93\u5165\u6027\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u300211\u670820\u65e50\u201424\u65f6\uff0c\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\u76ee\u524d\uff0c\u5df2\u8ffd\u8e2a\u5230\u5176\u5728\u672c\u5e02\u7684\u5bc6\u5207\u63a5\u89e6\u800583\u4eba\uff0c\u5747\u5df2\u843d\u5b9e\u96c6\u4e2d\u9694\u79bb\u89c2\u5bdf\u3002\u5bf9\u75c5\u4f8b\u66fe\u6d3b\u52a8\u8fc7\u7684\u573a\u6240\u5df2\u8fdb\u884c\u7ec8\u672b\u6d88\u6bd2\u3002 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u3010\u4e0a\u6d77\u6628\u65e5\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b \u65b0\u589e\u5883\u5916\u8f93\u51659\u4f8b\u3011\u636e\u4e0a\u6d77\u5e02\u536b\u5065\u59d4\u901a\u62a5\uff0c11\u670820\u65e50\u201424\u65f6\uff0c\u901a\u8fc7\u53e3\u5cb8\u8054\u9632\u8054\u63a7\u673a\u5236\uff0c\u62a5\u544a9\u4f8b\u5883\u5916\u8f93\u5165\u6027\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u300211\u670820\u65e50\u201424\u65f6\uff0c\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\u76ee\u524d\uff0c\u5df2\u8ffd\u8e2a\u5230\u5176\u5728\u672c\u5e02\u7684\u5bc6\u5207\u63a5\u89e6\u800583\u4eba\uff0c\u5747\u5df2\u843d\u5b9e\u96c6\u4e2d\u9694\u79bb \u5c55\u5f00\u5168\u6587c', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658)] from time import sleep Translation \u00b6 data = pd.read_csv(\"Sina_keyword.csv\", error_bad_lines=False, names=['Keyword', 'Content', 'Time', 'Rank', 'Number']) data = data[:100] from time import sleep from tqdm.auto import tqdm tqdm . pandas () translator = Translator () translator.translate(\"\u4f60\u597d\").text '\u4f60\u597d' def translate ( index : str , content : str ): has_translated = False while not has_translated : try : return translator . translate ( content ) except Exception : sleep ( 1 ) continue data [ 'Content_Translation' ] = data . progress_apply ( lambda row : translate ( row . name , row [ 'Content' ]), axis = 1 ) HBox(children=(FloatProgress(value=0.0, max=333717.0), HTML(value=''))) --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) <ipython-input-51-28c2eb176f38> in <module>() 9 10 ---> 11 data['Content_Translation'] = data.progress_apply(lambda row: translate(row.name, row['Content']), axis=1) /usr/local/lib/python3.6/dist-packages/tqdm/std.py in inner(df, func, *args, **kwargs) 751 # Apply the provided function (in **kwargs) 752 # on the df using our wrapper (which provides bar updating) --> 753 result = getattr(df, df_function)(wrapper, **kwargs) 754 755 # Close bar and return pandas calculation result /usr/local/lib/python3.6/dist-packages/pandas/core/frame.py in apply(self, func, axis, raw, result_type, args, **kwds) 7550 kwds=kwds, 7551 ) -> 7552 return op.get_result() 7553 7554 def applymap(self, func) -> \"DataFrame\": /usr/local/lib/python3.6/dist-packages/pandas/core/apply.py in get_result(self) 178 return self.apply_raw() 179 --> 180 return self.apply_standard() 181 182 def apply_empty_result(self): /usr/local/lib/python3.6/dist-packages/pandas/core/apply.py in apply_standard(self) 269 270 def apply_standard(self): --> 271 results, res_index = self.apply_series_generator() 272 273 # wrap results /usr/local/lib/python3.6/dist-packages/pandas/core/apply.py in apply_series_generator(self) 298 for i, v in enumerate(series_gen): 299 # ignore SettingWithCopy here in case the user mutates --> 300 results[i] = self.f(v) 301 if isinstance(results[i], ABCSeries): 302 # If we have a view on v, we need to make a copy because /usr/local/lib/python3.6/dist-packages/tqdm/std.py in wrapper(*args, **kwargs) 747 # take a fast or slow code path; so stop when t.total==t.n 748 t.update(n=1 if not t.total or t.n < t.total else 0) --> 749 return func(*args, **kwargs) 750 751 # Apply the provided function (in **kwargs) <ipython-input-51-28c2eb176f38> in <lambda>(row) 9 10 ---> 11 data['Content_Translation'] = data.progress_apply(lambda row: translate(row.name, row['Content']), axis=1) <ipython-input-51-28c2eb176f38> in translate(index, content) 3 while not has_translated: 4 try: ----> 5 return translator.translate(content) 6 except Exception: 7 sleep(1) /usr/local/lib/python3.6/dist-packages/googletrans/client.py in translate(self, text, dest, src, **kwargs) 180 181 origin = text --> 182 data = self._translate(text, dest, src, kwargs) 183 184 # this code will be updated when the format is changed. /usr/local/lib/python3.6/dist-packages/googletrans/client.py in _translate(self, text, dest, src, override) 81 82 url = urls.TRANSLATE.format(host=self._pick_service_url()) ---> 83 r = self.client.get(url, params=params) 84 85 if r.status_code == 200: /usr/local/lib/python3.6/dist-packages/httpx/_client.py in get(self, url, params, headers, cookies, auth, allow_redirects, timeout) 761 auth=auth, 762 allow_redirects=allow_redirects, --> 763 timeout=timeout, 764 ) 765 /usr/local/lib/python3.6/dist-packages/httpx/_client.py in request(self, method, url, data, files, json, params, headers, cookies, auth, allow_redirects, timeout) 599 ) 600 return self.send( --> 601 request, auth=auth, allow_redirects=allow_redirects, timeout=timeout, 602 ) 603 /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send(self, request, stream, auth, allow_redirects, timeout) 619 620 response = self.send_handling_redirects( --> 621 request, auth=auth, timeout=timeout, allow_redirects=allow_redirects, 622 ) 623 /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send_handling_redirects(self, request, auth, timeout, allow_redirects, history) 646 647 response = self.send_handling_auth( --> 648 request, auth=auth, timeout=timeout, history=history 649 ) 650 response.history = list(history) /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send_handling_auth(self, request, history, auth, timeout) 682 request = next(auth_flow) 683 while True: --> 684 response = self.send_single_request(request, timeout) 685 if auth.requires_response_body: 686 response.read() /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send_single_request(self, request, timeout) 717 headers=request.headers.raw, 718 stream=request.stream, --> 719 timeout=timeout.as_dict(), 720 ) 721 except HTTPError as exc: /usr/local/lib/python3.6/dist-packages/httpcore/_sync/connection_pool.py in request(self, method, url, headers, stream, timeout) 151 try: 152 response = connection.request( --> 153 method, url, headers=headers, stream=stream, timeout=timeout 154 ) 155 except NewConnectionRequired: /usr/local/lib/python3.6/dist-packages/httpcore/_sync/connection.py in request(self, method, url, headers, stream, timeout) 76 \"connection.request method=%r url=%r headers=%r\", method, url, headers 77 ) ---> 78 return self.connection.request(method, url, headers, stream, timeout) 79 80 def _open_socket(self, timeout: TimeoutDict = None) -> SyncSocketStream: /usr/local/lib/python3.6/dist-packages/httpcore/_sync/http11.py in request(self, method, url, headers, stream, timeout) 60 reason_phrase, 61 headers, ---> 62 ) = self._receive_response(timeout) 63 stream = SyncByteStream( 64 iterator=self._receive_response_data(timeout), /usr/local/lib/python3.6/dist-packages/httpcore/_sync/http11.py in _receive_response(self, timeout) 113 \"\"\" 114 while True: --> 115 event = self._receive_event(timeout) 116 if isinstance(event, h11.Response): 117 break /usr/local/lib/python3.6/dist-packages/httpcore/_sync/http11.py in _receive_event(self, timeout) 143 144 if event is h11.NEED_DATA: --> 145 data = self.socket.read(self.READ_NUM_BYTES, timeout) 146 self.h11_state.receive_data(data) 147 else: /usr/local/lib/python3.6/dist-packages/httpcore/_backends/sync.py in read(self, n, timeout) 60 with map_exceptions(exc_map): 61 self.sock.settimeout(read_timeout) ---> 62 return self.sock.recv(n) 63 64 def write(self, data: bytes, timeout: TimeoutDict) -> None: /usr/lib/python3.6/ssl.py in recv(self, buflen, flags) 995 \"non-zero flags not allowed in calls to recv() on %s\" % 996 self.__class__) --> 997 return self.read(buflen) 998 else: 999 return socket.recv(self, buflen, flags) /usr/lib/python3.6/ssl.py in read(self, len, buffer) 872 raise ValueError(\"Read on closed or unwrapped SSL socket.\") 873 try: --> 874 return self._sslobj.read(len, buffer) 875 except SSLError as x: 876 if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs: /usr/lib/python3.6/ssl.py in read(self, len, buffer) 631 v = self._sslobj.read(len, buffer) 632 else: --> 633 v = self._sslobj.read(len) 634 return v 635 KeyboardInterrupt: data.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Keyword Content Time Rank Number Content_Translation 0 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u4e94\u53f7\u8981\u5954\u6708\u5566# \u3010\u5ae6\u5a25\u4e94\u53f7\u63a2\u6d4b\u5668\u5b8c\u6210\u7b2c\u4e00\u6b21\u8f68\u9053\u4fee\u6b63\u3011\u8bb0\u8005\u4ece\u56fd\u5bb6\u822a\u5929\u5c40\u83b7\u6089\uff0c\u5317\u4eac\u65f6\u95f411... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u4e94\u53f7\u8981\u5954\u6708\u5566# \u3010\u5ae6\u5a25\u4e94\u53f7\u63a2\u6d4b\u5668\u5b8c\u6210\u7b2c\u4e00\u6b21\u8f68\u9053\u4fee\u6b63\u3011\u8bb0\u8005\u4ece\u56fd\u5bb6\u822a\u5929\u5c40\u83b7\u6089\uff0c\u5317\u4eac\u65f6\u95f411... 1 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u63a2\u6708#\u3010\u52a0\u6cb9\uff0c\u5ae6\u5a25\u4e94\u53f7\uff01\u52a0\u6cb9\uff0c\u4e2d\u56fd\u822a\u5929\uff01\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c#\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u4efb... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u63a2\u6708#\u3010\u52a0\u6cb9\uff0c\u5ae6\u5a25\u4e94\u53f7\uff01\u52a0\u6cb9\uff0c\u4e2d\u56fd\u822a\u5929\uff01\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c#\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u4efb... 2 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 3 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 4 \u5ae6\u5a25\u4e94\u53f7 \u5f88\u597d\u7684\u79d1\u666e\u8bdd\u9898\uff0c\u6da8\u77e5\u8bc6\u3002\\n\u300c\u5ae6\u5a25\u4e94\u53f7\u300d\u642d\u4e58\u300c\u957f\u5f81\u4e94\u53f7\u300d\u706b\u7bad\u53d1\u5c04\u6210\u529f\uff0c\u6267\u884c\u6211\u56fd\u9996\u6b21\u6708\u7403\u91c7\u6837\u8fd4... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u5f88\u597d\u7684\u79d1\u666e\u8bdd\u9898\uff0c\u6da8\u77e5\u8bc6\u3002\\n\u300c\u5ae6\u5a25\u4e94\u53f7\u300d\u642d\u4e58\u300c\u957f\u5f81\u4e94\u53f7\u300d\u706b\u7bad\u53d1\u5c04\u6210\u529f\uff0c\u6267\u884c\u6211\u56fd\u9996\u6b21\u6708\u7403\u91c7\u6837\u8fd4... 5 \u5ae6\u5a25\u4e94\u53f7 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 6 \u5ae6\u5a25\u4e94\u53f7 \u3010\u4e2d\u56fd\u63a2\u6708\u5de5\u7a0b\u201c\u4e09\u6b65\u8d70\u201d\u7684\u6536\u5b98\u4e4b\u6218\u6253\u54cd\u301111\u670824\u65e5\u51cc\u6668\uff0c\u4e2d\u56fd\u6587\u660c\u822a\u5929\u53d1\u5c04\u573a\u3002\u957f\u5f81\u4e94\u53f7\u9065\u4e94\u8fd0... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u3010\u4e2d\u56fd\u63a2\u6708\u5de5\u7a0b\u201c\u4e09\u6b65\u8d70\u201d\u7684\u6536\u5b98\u4e4b\u6218\u6253\u54cd\u301111\u670824\u65e5\u51cc\u6668\uff0c\u4e2d\u56fd\u6587\u660c\u822a\u5929\u53d1\u5c04\u573a\u3002\u957f\u5f81\u4e94\u53f7\u9065\u4e94\u8fd0... 7 \u5ae6\u5a25\u4e94\u53f7 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 8 \u5ae6\u5a25\u4e94\u53f7 \u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301O\u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301O\u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301 9 \u5ae6\u5a25\u4e94\u53f7 \u5173\u4e8e\u5ae6\u5a25\u767b\u6708\uff0c\u505a\u79d1\u7814\uff0c\u539f\u6765\u591a\u5e74\u524d\u8001\u592b\u5b50\u6f2b\u753b\u91cc\u4e5f\u5199\u4e86\\n@Steed\u7684\u56f4\u8116 #\u5ae6\u5a25\u4e94\u53f7# 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u5173\u4e8e\u5ae6\u5a25\u767b\u6708\uff0c\u505a\u79d1\u7814\uff0c\u539f\u6765\u591a\u5e74\u524d\u8001\u592b\u5b50\u6f2b\u753b\u91cc\u4e5f\u5199\u4e86\\n@Steed\u7684\u56f4\u8116 #\u5ae6\u5a25\u4e94\u53f7# preprocess data \u00b6 def preprocess ( row ): d = row . asDict () if d [ 'content' ]: d [ 'content' ] = d [ 'content' ]. replace ( \"\u5c55\u5f00\u5168\u6587c\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( \"\u6536\u8d77\u5168\u6587d\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( f \"{d['keyword']}\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( \"#\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( \"\\n\" , \"\" ) new_row = Row ( ** d ) return new_row new_data = rdd . map ( preprocess ) print ( new_data . take ( 10 )) new_data . cache () [Row(keyword='aespa\u51fa\u9053\u66f2\u521d\u821e\u53f0', content='\u6211\u5bf9aespa\u771f\u9999\u4e86', time=datetime.datetime(2020, 11, 19, 13, 4, 5, 14218), rank=41, numbers=206090), Row(keyword='\u5929\u6d25\u5927\u5b66\u4e00\u6559\u6388\u88ab\u5b9e\u540d\u4e3e\u62a5\u5b66\u672f\u9020\u5047', content='\u521a\u521a\u5403\u996d\u7684\u65f6\u5019\u770b\u7740\u5929\u5927\u8001\u5e08\u9020\u5047\u7684\u4e8b\uff0c\u6c14\u6124\u7684\u4e0d\u884c\uff0c\u7136\u540e\u5c31\u6536\u5230\u4e86\u6211\u5e08\u59b9\u7684\u6d88\u606f\uff0c\u7b11\u7684\u4e0d\u884c\uff0c\u5206\u4eab\u4e00\u4e2a\u6211\u8ff7\u7cca\u8001\u5e08\u7684\u65e5\u5e38\uff0c\u6211\u4eec\u5e73\u5e38\u6bd4\u505a\u5b9e\u9a8c\u66f4\u91cd\u8981\u7684\u4e8b\u5c31\u662f\u5e26\u94a5\u5319\ud83d\udd11\uff0c\u4e0d\u7136\u53ef\u80fd\u51fa\u53bb\u4e0a\u4e2a\u5395\u6240\uff0c\u5c31\u8fdb\u4e0d\u53bb\u5b9e\u9a8c\u5ba4\u4e86\u53e6\u5916\u8bf7\u5927\u5bb6\u4e0d\u8981\u56e0\u4e3a\u5404\u522b\u8001\u5e08\uff0c\u800c\u5bf9\u6574\u4e2a\u5b66\u672f\u4e1a\u5931\u671b\uff0c\u8fd8\u662f\u6709\u5f88\u591a\u8001\u5e08\uff0c\u5f88\u591a\u5b66\u751f\u5728\u4e3a\u8fd9\u4e2a\u884c ', time=datetime.datetime(2020, 11, 20, 5, 4, 30, 310980), rank=9, numbers=1043499), Row(keyword='\u9009\u79c0\u4e2d\u7684\u5fc3\u810f\u72d9\u51fb\u540d\u573a\u9762', content='\\ue627\u4efb\u8c6aPOI rh\u65e2\u7136\u63d0\u5230\u4e86\u8c6a\u8c6a\uff0c\u90a3\u5c31\u6765\u770b\u770b\u5427\uff01@R1SE-\u4efb\u8c6a', time=datetime.datetime(2020, 11, 20, 20, 4, 20, 475064), rank=47, numbers=21300), Row(keyword='\u7535\u89c6\u5267\u534a\u751f\u7f18\u6539\u540d\u60c5\u6df1\u7f18\u8d77', content='\u4e0d\u77e5\u9053\u662f\u5e7f\u7535\u6709\u6bdb\u75c5\u8fd8\u662f\u600e\u6837\uff0c\u52a8\u4e0d\u52a8\u7ed9\u4eba\u7535\u89c6\u5267\u8d50\u540d\u6539\u540d\uff0c\u5b64\u57ce\u95ed\uff0c\u6492\u91ce\uff0c\u534a\u751f\u7f18\uff0c\u638c\u4e2d\u4e4b\u7269\uff0c\u4eba\u5bb6\u540d\u5b57\u591a\u597d\u542c\uff0c\u6539\u4f60\ud83d\udc34 \u54e6\uff0c\u5c31\u77e5\u9053\u778e\u6539\uff0c\u7535\u89c6\u5267\u8fd0\u6c14\u90fd\u7ed9\u4f60\u6539\u6389\u4e00\u534a\u2026', time=datetime.datetime(2020, 11, 20, 22, 5, 5, 155120), rank=16, numbers=67914), Row(keyword='\u8df3\u5316\u7caa\u6c60\u6551\u5a03\u9000\u5f79\u519b\u4eba\u6536\u5230\u6551\u52a9\u91d1', content='\u4ee5\u540e\u8fd8\u4f1a\u7ee7\u7eed\u505a\u597d\u4e8b\u3001\u597d\u6837\u7684\uff01\u771f\u7684\u4ee4\u4eba\u656c\u4f69\uff01', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 624606), rank=10, numbers=714340), Row(keyword='\u6b66\u5219\u5929\u5979\u5988\u5728\u94a6\u5dde\u7814\u7a76\u5de5\u4f5c\u7ec4\u66f4\u540d', content='\u767d\u5bcc\u7f8e\u66f9\u8bd1\u6587\u7684\u65b0\u74dc\u6295\u7a3f\uff0c\u6ce2\u58eb\u987f\u5927\u5b66gpa\u4f4e\u4e8e2.0\u88ab\u9000\u5b66\uff0c\u5728\u7f8e\u56fd\u8bfb\u7814\u671f\u95f4\u8fd8\u88ab\u8bc8\u9a97\u5dee\u70b9\u88ab\u7ed1\u67b6..\u9a97\u5b50\u5927\u6982\u5c31\u662f\u9a97\u5979\uff1a\u4f60\u7239\u5728\u56fd\u5185\u60f9\u4e0a\u4e86\u5927\u9ebb\u70e6 \u53eb\u5979\u5207\u65ad\u548c\u5bb6\u4eba\u7684\u4e00\u5207\u8054\u7cfb\u5e76\u4e14\u8eb2\u5728\u9152\u5e97\u91cc\u2026\u7ed3\u679c\u5979\u4e0d\u4f46\u4fe1\u4e86 \u8fd8\u62d4\u4e86sim\u5361 \u4e56\u4e56\u7167\u505a \u5979\u7239\u5f53\u65f6\u7740\u5b9e\u88ab\u5413\u5230 \u5979\u7239\u8fd8\u662f\u6709\u70b9\u4eba\u8109\u5427 \u52a8\u7528\u4e86\u5f88\u591a\u5173\u7cfb \u51e0\u4e4e\u53d1\u52a8\u4e86\u76f8\u5f53\u5927 ', time=datetime.datetime(2020, 11, 19, 22, 4, 52, 666638), rank=1, numbers=291907), Row(keyword='\u79cb\u65e5\u6817\u6817\u6392\u9aa8\u996d', content='\u3010\u677f\u6817\u7096\u6392\u9aa8\u3011\u677f\u6817\u8f6f\u7cef\u9999\u751c\uff0c\u548c\u6392\u9aa8\u4e00\u8d77\u7096\u5230\u8f6f\u70c2\uff0c\u9171\u6cb9\u7684\u54b8\u5473\u548c\u677f\u6817\u7684\u751c\u5473\u878d\u5408\u5728\u4e00\u8d77\uff0c\u8ba9\u4eba\u65e0\u6cd5\u6297\u62d2\uff5e\u5fae\u535a\u53a8\u623f\u5927\u8d5b via\uff1a\u597d\u597d\u5403 L\u6700\u7231\u5b66\u505a\u996d\u7684\u5fae\u535a\u89c6\u9891', time=datetime.datetime(2020, 11, 20, 19, 3, 55, 682688), rank=48, numbers=29242), Row(keyword='\u9690\u79d8\u800c\u4f1f\u5927', content='\\ue627\u91d1\u6668\u4e25\u91cd\u5267\u900f\u614e\u5165\uff0c\u90fd\u662f\u8d85\u7ea7\u559c\u6b22\u7684\u7247\u6bb5\u7535\u89c6\u5267', time=datetime.datetime(2020, 11, 19, 17, 4, 54, 423157), rank=30, numbers=197616), Row(keyword='\u5355\u4f9d\u7eaf\u597d\u58f0\u97f3\u51a0\u519b', content=' \u545c\u545c\u545c\u545c\u4e0d\u6127\u662f\u6211\u6ef4\u5973\u795e\u592a\u68d2\u5566\uff01\uff01\uff01\uff01\uff01\u867d\u7136\u662f\u610f\u6599\u4e4b\u4e2d \u4f46\u662f\u8fd8\u662f\u5fcd\u4e0d\u4f4f\u975e\u5e38\u6fc0\u52a8', time=datetime.datetime(2020, 11, 21, 3, 4, 26, 288909), rank=12, numbers=379689), Row(keyword='\u4e01\u653e\u80cc\u53db\u987e\u8000\u4e1c', content='\u9690\u79d8\u800c\u4f1f\u5927 \u7b2c37-38\u96c6\u9884\u544a\uff1a\u987e\u8000\u4e1c\u9009\u62e9\u4e3b\u52a8\u56de\u8b66\u5c40\uff0c\u56de\u8b66\u5c40\u4e4b\u540e\u987e\u8000\u4e1c\u88ab\u6307\u8ba4\u901a\u5171\uff0c\u5728\u8b66\u5c40\u60e8\u906d\u9177\u5211\uff0c\u5fc3\u75bc\u4e1c\u9e45\u674e\u6613\u5cf0/\u91d1\u6668/ L\u5f71\u89c6\u5c0f\u679c\u9171\u7684\u5fae\u535a\u89c6\u9891', time=datetime.datetime(2020, 11, 19, 23, 3, 58, 114273), rank=37, numbers=90071)] PythonRDD[33] at RDD at PythonRDD.scala:53 jieba.initialize() tokenizer = jieba.Tokenizer() def sentiment ( row ): try : s = SnowNLP ( row . content ) return ( row . keyword , ( s . sentiments , row . content )) except Exception : return ( \"error\" , \"nil\" ) def keyword ( row ): return jieba . lcut ( row . keyword , cut_all = False ), row sentiments = new_data . map ( sentiment ). filter ( lambda x : x [ 0 ] != \"error\" and x [ 1 ] != \"nil\" ) sentiments . cache (). take ( 10 ) [('aespa\u51fa\u9053\u66f2\u521d\u821e\u53f0', (0.6292287669391688, '\u6211\u5bf9aespa\u771f\u9999\u4e86')), ('\u5929\u6d25\u5927\u5b66\u4e00\u6559\u6388\u88ab\u5b9e\u540d\u4e3e\u62a5\u5b66\u672f\u9020\u5047', (0.9952895196778796, '\u521a\u521a\u5403\u996d\u7684\u65f6\u5019\u770b\u7740\u5929\u5927\u8001\u5e08\u9020\u5047\u7684\u4e8b\uff0c\u6c14\u6124\u7684\u4e0d\u884c\uff0c\u7136\u540e\u5c31\u6536\u5230\u4e86\u6211\u5e08\u59b9\u7684\u6d88\u606f\uff0c\u7b11\u7684\u4e0d\u884c\uff0c\u5206\u4eab\u4e00\u4e2a\u6211\u8ff7\u7cca\u8001\u5e08\u7684\u65e5\u5e38\uff0c\u6211\u4eec\u5e73\u5e38\u6bd4\u505a\u5b9e\u9a8c\u66f4\u91cd\u8981\u7684\u4e8b\u5c31\u662f\u5e26\u94a5\u5319\ud83d\udd11\uff0c\u4e0d\u7136\u53ef\u80fd\u51fa\u53bb\u4e0a\u4e2a\u5395\u6240\uff0c\u5c31\u8fdb\u4e0d\u53bb\u5b9e\u9a8c\u5ba4\u4e86\u53e6\u5916\u8bf7\u5927\u5bb6\u4e0d\u8981\u56e0\u4e3a\u5404\u522b\u8001\u5e08\uff0c\u800c\u5bf9\u6574\u4e2a\u5b66\u672f\u4e1a\u5931\u671b\uff0c\u8fd8\u662f\u6709\u5f88\u591a\u8001\u5e08\uff0c\u5f88\u591a\u5b66\u751f\u5728\u4e3a\u8fd9\u4e2a\u884c ')), ('\u9009\u79c0\u4e2d\u7684\u5fc3\u810f\u72d9\u51fb\u540d\u573a\u9762', (0.8225709747637443, '\\ue627\u4efb\u8c6aPOI rh\u65e2\u7136\u63d0\u5230\u4e86\u8c6a\u8c6a\uff0c\u90a3\u5c31\u6765\u770b\u770b\u5427\uff01@R1SE-\u4efb\u8c6a')), ('\u7535\u89c6\u5267\u534a\u751f\u7f18\u6539\u540d\u60c5\u6df1\u7f18\u8d77', (0.6790462184223255, '\u4e0d\u77e5\u9053\u662f\u5e7f\u7535\u6709\u6bdb\u75c5\u8fd8\u662f\u600e\u6837\uff0c\u52a8\u4e0d\u52a8\u7ed9\u4eba\u7535\u89c6\u5267\u8d50\u540d\u6539\u540d\uff0c\u5b64\u57ce\u95ed\uff0c\u6492\u91ce\uff0c\u534a\u751f\u7f18\uff0c\u638c\u4e2d\u4e4b\u7269\uff0c\u4eba\u5bb6\u540d\u5b57\u591a\u597d\u542c\uff0c\u6539\u4f60\ud83d\udc34 \u54e6\uff0c\u5c31\u77e5\u9053\u778e\u6539\uff0c\u7535\u89c6\u5267\u8fd0\u6c14\u90fd\u7ed9\u4f60\u6539\u6389\u4e00\u534a\u2026')), ('\u8df3\u5316\u7caa\u6c60\u6551\u5a03\u9000\u5f79\u519b\u4eba\u6536\u5230\u6551\u52a9\u91d1', (0.824867218915397, '\u4ee5\u540e\u8fd8\u4f1a\u7ee7\u7eed\u505a\u597d\u4e8b\u3001\u597d\u6837\u7684\uff01\u771f\u7684\u4ee4\u4eba\u656c\u4f69\uff01')), ('\u6b66\u5219\u5929\u5979\u5988\u5728\u94a6\u5dde\u7814\u7a76\u5de5\u4f5c\u7ec4\u66f4\u540d', (0.37617857183276393, '\u767d\u5bcc\u7f8e\u66f9\u8bd1\u6587\u7684\u65b0\u74dc\u6295\u7a3f\uff0c\u6ce2\u58eb\u987f\u5927\u5b66gpa\u4f4e\u4e8e2.0\u88ab\u9000\u5b66\uff0c\u5728\u7f8e\u56fd\u8bfb\u7814\u671f\u95f4\u8fd8\u88ab\u8bc8\u9a97\u5dee\u70b9\u88ab\u7ed1\u67b6..\u9a97\u5b50\u5927\u6982\u5c31\u662f\u9a97\u5979\uff1a\u4f60\u7239\u5728\u56fd\u5185\u60f9\u4e0a\u4e86\u5927\u9ebb\u70e6 \u53eb\u5979\u5207\u65ad\u548c\u5bb6\u4eba\u7684\u4e00\u5207\u8054\u7cfb\u5e76\u4e14\u8eb2\u5728\u9152\u5e97\u91cc\u2026\u7ed3\u679c\u5979\u4e0d\u4f46\u4fe1\u4e86 \u8fd8\u62d4\u4e86sim\u5361 \u4e56\u4e56\u7167\u505a \u5979\u7239\u5f53\u65f6\u7740\u5b9e\u88ab\u5413\u5230 \u5979\u7239\u8fd8\u662f\u6709\u70b9\u4eba\u8109\u5427 \u52a8\u7528\u4e86\u5f88\u591a\u5173\u7cfb \u51e0\u4e4e\u53d1\u52a8\u4e86\u76f8\u5f53\u5927 ')), ('\u79cb\u65e5\u6817\u6817\u6392\u9aa8\u996d', (0.9999301000032879, '\u3010\u677f\u6817\u7096\u6392\u9aa8\u3011\u677f\u6817\u8f6f\u7cef\u9999\u751c\uff0c\u548c\u6392\u9aa8\u4e00\u8d77\u7096\u5230\u8f6f\u70c2\uff0c\u9171\u6cb9\u7684\u54b8\u5473\u548c\u677f\u6817\u7684\u751c\u5473\u878d\u5408\u5728\u4e00\u8d77\uff0c\u8ba9\u4eba\u65e0\u6cd5\u6297\u62d2\uff5e\u5fae\u535a\u53a8\u623f\u5927\u8d5b via\uff1a\u597d\u597d\u5403 L\u6700\u7231\u5b66\u505a\u996d\u7684\u5fae\u535a\u89c6\u9891')), ('\u9690\u79d8\u800c\u4f1f\u5927', (0.9961075258005379, '\\ue627\u91d1\u6668\u4e25\u91cd\u5267\u900f\u614e\u5165\uff0c\u90fd\u662f\u8d85\u7ea7\u559c\u6b22\u7684\u7247\u6bb5\u7535\u89c6\u5267')), ('\u5355\u4f9d\u7eaf\u597d\u58f0\u97f3\u51a0\u519b', (0.9996645862980169, ' \u545c\u545c\u545c\u545c\u4e0d\u6127\u662f\u6211\u6ef4\u5973\u795e\u592a\u68d2\u5566\uff01\uff01\uff01\uff01\uff01\u867d\u7136\u662f\u610f\u6599\u4e4b\u4e2d \u4f46\u662f\u8fd8\u662f\u5fcd\u4e0d\u4f4f\u975e\u5e38\u6fc0\u52a8')), ('\u4e01\u653e\u80cc\u53db\u987e\u8000\u4e1c', (0.9984970249089633, '\u9690\u79d8\u800c\u4f1f\u5927 \u7b2c37-38\u96c6\u9884\u544a\uff1a\u987e\u8000\u4e1c\u9009\u62e9\u4e3b\u52a8\u56de\u8b66\u5c40\uff0c\u56de\u8b66\u5c40\u4e4b\u540e\u987e\u8000\u4e1c\u88ab\u6307\u8ba4\u901a\u5171\uff0c\u5728\u8b66\u5c40\u60e8\u906d\u9177\u5211\uff0c\u5fc3\u75bc\u4e1c\u9e45\u674e\u6613\u5cf0/\u91d1\u6668/ L\u5f71\u89c6\u5c0f\u679c\u9171\u7684\u5fae\u535a\u89c6\u9891'))] def groupValues ( values ): total = 0 i = 0 for v in values : sentiments , content = v total += sentiments i += 1 return total / i grouped = sentiments . groupByKey (). mapValues ( groupValues ) print ( grouped . take ( 10 )) --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) <ipython-input-28-0b92fc34bf9d> in <module>() 10 11 grouped = sentiments.groupByKey().mapValues(groupValues) ---> 12 print(grouped.take(10)) /usr/local/lib/python3.6/dist-packages/pyspark/rdd.py in take(self, num) 1444 1445 p = range(partsScanned, min(partsScanned + numPartsToTry, totalParts)) -> 1446 res = self.context.runJob(self, takeUpToNumLeft, p) 1447 1448 items += res /usr/local/lib/python3.6/dist-packages/pyspark/context.py in runJob(self, rdd, partitionFunc, partitions, allowLocal) 1116 # SparkContext#runJob. 1117 mappedRDD = rdd.mapPartitions(partitionFunc) -> 1118 sock_info = self._jvm.PythonRDD.runJob(self._jsc.sc(), mappedRDD._jrdd, partitions) 1119 return list(_load_from_socket(sock_info, mappedRDD._jrdd_deserializer)) 1120 /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in __call__(self, *args) 1301 proto.END_COMMAND_PART 1302 -> 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( 1305 answer, self.gateway_client, self.target_id, self.name) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command, retry, binary) 1031 connection = self._get_connection() 1032 try: -> 1033 response = connection.send_command(command) 1034 if binary: 1035 return response, self._create_connection_guard(connection) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command) 1198 1199 try: -> 1200 answer = smart_decode(self.stream.readline()[:-1]) 1201 logger.debug(\"Answer received: {0}\".format(answer)) 1202 if answer.startswith(proto.RETURN_MESSAGE): /usr/lib/python3.6/socket.py in readinto(self, b) 584 while True: 585 try: --> 586 return self._sock.recv_into(b) 587 except timeout: 588 self._timeout_occurred = True KeyboardInterrupt: pos = sentiments.filter(lambda x: x[1][0] > 0.75).count() neg = sentiments.filter(lambda x: x[1][0] <= 0.35).count() net = sentiments.filter(lambda x: x[1][0] > 0.35 and x[1][0] <= 0.75).count() plt.figure(figsize=(10,10)) plt.bar(\"Positive\", pos) plt.bar(\"Neutral\", net) plt.bar(\"Negative\", neg) plt.xlabel(\"Sentiment\") plt.ylabel(\"Number of posts\") plt.title(\"Sina Weibo Sentiment\") plt.savefig(\"sina.png\")","title":"Project"},{"location":"MSBD5003/projects/Project/#install-dependencies","text":"!pip install googletrans Collecting googletrans Downloading https://files.pythonhosted.org/packages/71/3a/3b19effdd4c03958b90f40fe01c93de6d5280e03843cc5adf6956bfc9512/googletrans-3.0.0.tar.gz Collecting httpx==0.13.3 \u001b[?25l Downloading https://files.pythonhosted.org/packages/54/b4/698b284c6aed4d7c2b4fe3ba5df1fcf6093612423797e76fbb24890dd22f/httpx-0.13.3-py3-none-any.whl (55kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 3.2MB/s \u001b[?25hCollecting rfc3986<2,>=1.3 Downloading https://files.pythonhosted.org/packages/78/be/7b8b99fd74ff5684225f50dd0e865393d2265656ef3b4ba9eaaaffe622b8/rfc3986-1.4.0-py2.py3-none-any.whl Collecting httpcore==0.9.* \u001b[?25l Downloading https://files.pythonhosted.org/packages/dd/d5/e4ff9318693ac6101a2095e580908b591838c6f33df8d3ee8dd953ba96a8/httpcore-0.9.1-py3-none-any.whl (42kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 51kB 4.3MB/s \u001b[?25hRequirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from httpx==0.13.3->googletrans) (2020.11.8) Requirement already satisfied: idna==2.* in /usr/local/lib/python3.6/dist-packages (from httpx==0.13.3->googletrans) (2.10) Collecting hstspreload \u001b[?25l Downloading https://files.pythonhosted.org/packages/d3/3c/cdeaf9ab0404853e77c45d9e8021d0d2c01f70a1bb26e460090926fe2a5e/hstspreload-2020.11.21-py3-none-any.whl (981kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 983kB 6.4MB/s \u001b[?25hRequirement already satisfied: chardet==3.* in /usr/local/lib/python3.6/dist-packages (from httpx==0.13.3->googletrans) (3.0.4) Collecting sniffio Downloading https://files.pythonhosted.org/packages/52/b0/7b2e028b63d092804b6794595871f936aafa5e9322dcaaad50ebf67445b3/sniffio-1.2.0-py3-none-any.whl Collecting h11<0.10,>=0.8 \u001b[?25l Downloading https://files.pythonhosted.org/packages/5a/fd/3dad730b0f95e78aeeb742f96fa7bbecbdd56a58e405d3da440d5bfb90c6/h11-0.9.0-py2.py3-none-any.whl (53kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.0MB/s \u001b[?25hCollecting h2==3.* \u001b[?25l Downloading https://files.pythonhosted.org/packages/25/de/da019bcc539eeab02f6d45836f23858ac467f584bfec7a526ef200242afe/h2-3.2.0-py2.py3-none-any.whl (65kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 71kB 6.7MB/s \u001b[?25hCollecting contextvars>=2.1; python_version < \"3.7\" Downloading https://files.pythonhosted.org/packages/83/96/55b82d9f13763be9d672622e1b8106c85acb83edd7cc2fa5bc67cd9877e9/contextvars-2.4.tar.gz Collecting hyperframe<6,>=5.2.0 Downloading https://files.pythonhosted.org/packages/19/0c/bf88182bcb5dce3094e2f3e4fe20db28a9928cb7bd5b08024030e4b140db/hyperframe-5.2.0-py2.py3-none-any.whl Collecting hpack<4,>=3.0 Downloading https://files.pythonhosted.org/packages/8a/cc/e53517f4a1e13f74776ca93271caef378dadec14d71c61c949d759d3db69/hpack-3.0.0-py2.py3-none-any.whl Collecting immutables>=0.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/99/e0/ea6fd4697120327d26773b5a84853f897a68e33d3f9376b00a8ff96e4f63/immutables-0.14-cp36-cp36m-manylinux1_x86_64.whl (98kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 102kB 7.1MB/s \u001b[?25hBuilding wheels for collected packages: googletrans, contextvars Building wheel for googletrans (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for googletrans: filename=googletrans-3.0.0-cp36-none-any.whl size=15736 sha256=41d6607e625fb84483fb92ce5870ff80dce825ee8cdee5d005a6f66ac2b4f9a6 Stored in directory: /root/.cache/pip/wheels/28/1a/a7/eaf4d7a3417a0c65796c547cff4deb6d79c7d14c2abd29273e Building wheel for contextvars (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for contextvars: filename=contextvars-2.4-cp36-none-any.whl size=7666 sha256=bac0c5e9bd7288c7b7f764befbcfe3747b54567305e833c1eaceb02301a456d8 Stored in directory: /root/.cache/pip/wheels/a5/7d/68/1ebae2668bda2228686e3c1cf16f2c2384cea6e9334ad5f6de Successfully built googletrans contextvars Installing collected packages: rfc3986, h11, hyperframe, hpack, h2, immutables, contextvars, sniffio, httpcore, hstspreload, httpx, googletrans Successfully installed contextvars-2.4 googletrans-3.0.0 h11-0.9.0 h2-3.2.0 hpack-3.0.0 hstspreload-2020.11.21 httpcore-0.9.1 httpx-0.13.3 hyperframe-5.2.0 immutables-0.14 rfc3986-1.4.0 sniffio-1.2.0 !pip install jieba Requirement already satisfied: jieba in /usr/local/lib/python3.6/dist-packages (0.42.1) !pip install snownlp Collecting snownlp \u001b[?25l Downloading https://files.pythonhosted.org/packages/3d/b3/37567686662100d3bce62d3b0f2adec18ab4b9ff2b61abd7a61c39343c1d/snownlp-0.12.3.tar.gz (37.6MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 37.6MB 1.2MB/s \u001b[?25hBuilding wheels for collected packages: snownlp Building wheel for snownlp (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for snownlp: filename=snownlp-0.12.3-cp36-none-any.whl size=37760959 sha256=a9e56804b51b20b5955ed305562310e2cffd780244fcb895b08cbbef094e126c Stored in directory: /root/.cache/pip/wheels/f3/81/25/7c197493bd7daf177016f1a951c5c3a53b1c7e9339fd11ec8f Successfully built snownlp Installing collected packages: snownlp Successfully installed snownlp-0.12.3 !pip install pyspark Collecting pyspark \u001b[?25l Downloading https://files.pythonhosted.org/packages/f0/26/198fc8c0b98580f617cb03cb298c6056587b8f0447e20fa40c5b634ced77/pyspark-3.0.1.tar.gz (204.2MB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204.2MB 39kB/s \u001b[?25hCollecting py4j==0.10.9 \u001b[?25l Downloading https://files.pythonhosted.org/packages/9e/b6/6a4fb90cd235dc8e265a6a2067f2a2c99f0d91787f06aca4bcf7c23f3f80/py4j-0.10.9-py2.py3-none-any.whl (198kB) \u001b[K |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 204kB 50.5MB/s \u001b[?25hBuilding wheels for collected packages: pyspark Building wheel for pyspark (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for pyspark: filename=pyspark-3.0.1-py2.py3-none-any.whl size=204612243 sha256=ff2703910c5d2146d9e5eb2fe81cfb913b4ef6e0f9485fbd4a600fe77ed82946 Stored in directory: /root/.cache/pip/wheels/5e/bd/07/031766ca628adec8435bb40f0bd83bb676ce65ff4007f8e73f Successfully built pyspark Installing collected packages: py4j, pyspark Successfully installed py4j-0.10.9 pyspark-3.0.1 from pyspark.context import SparkContext from pyspark.sql.session import SparkSession from pyspark.sql.types import Row # NLP Module from snownlp import SnowNLP import jieba # translation from googletrans import Translator import matplotlib.pyplot as plt import pandas as pd sc = SparkContext . getOrCreate () spark = SparkSession ( sc ) import urllib.request file_url = \"https://github.com/sirily11/hot-keywords/releases/download/master/Sina_keyword.csv\" file_name = \"Sina_keyword.csv\" urllib . request . urlretrieve ( file_url , file_name ) ('Sina_keyword.csv', <http.client.HTTPMessage at 0x7f58c7be1b38>)","title":"Install dependencies"},{"location":"MSBD5003/projects/Project/#read-csv-file","text":"from pyspark.sql.types import StructType , StructField , IntegerType , StringType , TimestampType schema = StructType ([ StructField ( 'keyword' , StringType (), False ), StructField ( \"content\" , StringType (), False ), StructField ( \"time\" , TimestampType (), False ), StructField ( \"rank\" , IntegerType (), False ), StructField ( \"numbers\" , IntegerType (), False ), ]) df = spark.read.csv(file_name, schema=schema, lineSep=\";\") df.show() --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) <ipython-input-13-a4fd1b0edcab> in <module>() 1 df = spark.read.csv(file_name, schema=schema, lineSep=\";\") ----> 2 df.show() /usr/local/lib/python3.6/dist-packages/pyspark/sql/dataframe.py in show(self, n, truncate, vertical) 438 \"\"\" 439 if isinstance(truncate, bool) and truncate: --> 440 print(self._jdf.showString(n, 20, vertical)) 441 else: 442 print(self._jdf.showString(n, int(truncate), vertical)) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in __call__(self, *args) 1301 proto.END_COMMAND_PART 1302 -> 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( 1305 answer, self.gateway_client, self.target_id, self.name) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command, retry, binary) 1031 connection = self._get_connection() 1032 try: -> 1033 response = connection.send_command(command) 1034 if binary: 1035 return response, self._create_connection_guard(connection) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command) 1198 1199 try: -> 1200 answer = smart_decode(self.stream.readline()[:-1]) 1201 logger.debug(\"Answer received: {0}\".format(answer)) 1202 if answer.startswith(proto.RETURN_MESSAGE): /usr/lib/python3.6/socket.py in readinto(self, b) 584 while True: 585 try: --> 586 return self._sock.recv_into(b) 587 except timeout: 588 self._timeout_occurred = True KeyboardInterrupt: rdd = df.rdd rdd.take(10) [Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u6fb3\u4e9a\u3010\u8d44\u8baf\u3011# #\u4e0a\u6d77\u75ab\u60c5# #\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b \u8ffd\u8e2a\u5bc6\u63a5\u800583\u4eba#\u5e02\u536b\u5065\u59d4\u4eca\u65e9\uff0821\u65e5\uff09\u901a\u62a5\uff1a11\u670820\u65e50\u201424\u65f6\uff0c\u901a\u8fc7\u53e3\u5cb8\u8054\u9632\u8054\u63a7\u673a\u5236\uff0c\u62a5\u544a9\u4f8b\u5883\u5916\u8f93\u5165\u6027\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\u65b0\u589e\u6cbb\u6108\u51fa\u96628\u4f8b\uff0c\u5176\u4e2d\u6765\u81ea\u963f\u8054\u914b1\u4f8b\uff0c\u6765\u81ea\u4fc4\u7f57\u65af1\u4f8b\uff0c\u6765\u81ea\u52a0\u62ff\u59271\u4f8b\uff0c\u6765\u81ea\u9a6c\u91cc1\u4f8b\uff0c\u6765\u81ea\u7f8e\u56fd1\u4f8b\uff0c\u6765\u81ea\u585e\u5c14\u7ef4\u4e9a1\u4f8b\uff0c\u6765\u81ea\u4e4c\u514b\u51701\u4f8b\uff0c\u6765\u81ea\u4e4c\u5179\u522b\u514b\u65af\u57661\u4f8b\u3002\\n11\u670820\u65e50\u201424\u65f6\uff0c\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\\n\u75c5\u4f8b1\u3001\u75c5\u4f8b2\u4e3a\u592b\u59bb\u5173\u7cfb\uff0c\u5e38\u4f4f\u6d66\u4e1c\u65b0\u533a\uff0c\u56e0\u5148\u540e\u51fa\u73b0\u53d1\u70ed\u75c7\u72b6\uff0c\u524d\u5f80\u533b\u7597\u673a\u6784\u53d1\u70ed\u95e8\u8bca\u5c31\u8bca\uff0c\u5373\u88ab\u9694\u79bb\u7559\u89c2\u300211\u670820\u65e5\uff0c\u5e02\u3001\u533a\u75be\u63a7\u4e2d\u5fc3\u6838\u9178\u68c0\u6d4b\u7ed3\u679c\u4e3a\u9633\u6027\u3002\u7ecf\u4e13\u5bb6\u4f1a\u8bca\uff0c\u7efc\u5408\u4e34\u5e8a\u3001\u5f71\u50cf\u5b66\u8868\u73b0\u548c\u5b9e\u9a8c\u5ba4\u6838\u9178\u68c0\u6d4b\u7ed3\u679c\uff0c\u8bca\u65ad\u4e3a\u786e\u8bca\u75c5\u4f8b\u3002\\n\u76ee\u524d\uff0c\u5df2\u8ffd\u8e2a\u5230\u5176\u5728\u672c\u5e02\u7684\u5bc6\u5207\u63a5\u89e6\u800583\u4eba\uff0c\u5747\u5df2\u843d\u5b9e\u96c6\u4e2d\u9694\u79bb\u89c2\u5bdf\u3002\u5bf9\u75c5\u4f8b\u66fe\u6d3b\u52a8\u8fc7\u7684\u573a\u6240\u5df2\u8fdb\u884c\u7ec8\u672b\u6d88\u6bd2\u3002\\n\u622a\u81f311\u670820\u65e524\u65f6\uff0c\u7d2f\u8ba1\u62a5\u544a\u5883\u5916\u8f93\u5165\u6027\u786e\u8bca\u75c5\u4f8b956\u4f8b\uff0c\u51fa\u9662896\u4f8b\uff0c\u5728\u9662\u6cbb\u759760\u4f8b\uff0c\u65e0\u91cd\u75c7\u548c\u5371\u91cd\u75c7\u3002\u73b0\u6709\u5f85\u6392\u67e5\u7684\u7591\u4f3c\u75c5\u4f8b0\u4f8b\u3002\\n\u622a\u81f311\u670820\u65e524\u65f6\uff0c\u7d2f\u8ba1\u62a5\u544a\u672c\u5730\u786e\u8bca\u75c5\u4f8b345\u4f8b\uff0c\u6cbb\u6108\u51fa\u9662335\u4f8b\uff0c\u5728\u9662\u6cbb\u75973\u4f8b\uff0c\u6b7b\u4ea17\u4f8b\u3002\u73b0\u6709\u5f85\u6392\u67e5\u7684\u7591\u4f3c\u75c5\u4f8b0\u4f8b\u3002\\n\u622a\u81f311\u670820\u65e524\u65f6\uff0c\u5c1a\u5728\u533b\u5b66\u89c2\u5bdf\u4e2d\u7684\u65e0\u75c7\u72b6\u611f\u67d3\u80050\u4f8b\u3002 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u3010#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\uff0c\u6b63\u5168\u9762\u5f00\u5c55\u6d41\u884c\u75c5\u5b66\u8c03\u67e5\u3011\u4eca\u5929\u4e0b\u5348\uff0c\u4e0a\u6d77\u6d66\u4e1c\u65b0\u533a\u536b\u5065\u59d4\u62a5\u544a\u4e24\u4f8b\u7591\u4f3c\u65b0\u51a0\u80ba\u708e\u75c5\u4f8b\u3002\u75c5\u4f8b1\uff0c\u7537\uff0c39\u5c81\uff1b\u75c5\u4f8b2\uff0c\u5973\uff0c34\u5c81\uff0c\u4e24\u8005\u7cfb\u592b\u59bb\u5173\u7cfb\u3002\u56e0\u5148\u540e\u51fa\u73b0\u53d1\u70ed\uff0c\u5230\u533b\u9662\u53d1\u70ed\u95e8\u8bca\u5c31\u533b\uff0c\u5373\u88ab\u9694\u79bb\u6392\u67e5\u3002\u4eca\u665a21\u65f6\uff0c\u7ecf\u4e0a\u6d77\u5e02\u75be\u63a7\u4e2d\u5fc3\u65b0\u51a0\u75c5\u6bd2\u6838\u9178\u68c0\u6d4b\uff0c\u7ed3\u679c\u5747\u4e3a\u9633\u6027\u3002\u7ecf\u5e02\u7ea7\u4e13\u5bb6\u4f1a\u8bca\uff0c\u7ed3\u5408\u4e34\u5e8a\u3001\u5f71\u50cf\u5b66\u8868\u73b0\u548c\u5b9e\u9a8c\u5ba4\u6838\u9178\u68c0\u6d4b\u7ed3\u679c\uff0c\u8bca\u65ad\u4e3a\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\\n\u76ee\u524d\uff0c\u4e0a\u6d77\u5e02\u3001\u533a\u76f8\u5173\u90e8\u95e8\u5df2\u7ec4\u6210\u8054\u5408\u6d41\u8c03\u4e13\u5bb6\u961f\u4f0d\uff0c\u5168\u9762\u5f00\u5c55\u6d41\u884c\u75c5\u5b66\u8c03\u67e5\uff0c\u6b63\u5728\u8ffd\u8e2a\u6392\u67e5\u76f8\u5173\u4eba\u5458\uff0c\u5bf9\u76f8\u5173\u4eba\u5458\u548c\u73af\u5883\u91c7\u53d6\u76f8\u5e94\u7684\u9632\u75ab\u63aa\u65bd\u3002\u540e\u7eed\u6392\u67e5\u60c5\u51b5\u548c\u76f8\u5173\u4eba\u5458\u7684\u68c0\u6d4b\u7ed3\u679c\uff0c\u5c06\u7b2c\u4e00\u65f6\u95f4\u5411\u793e\u4f1a\u53d1\u5e03\u3002\uff08\u603b\u53f0\u592e\u89c6\u8bb0\u8005\u9646\u5b66\u8d24\uff09 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u3010#\u5f20\u6587\u5b8f\u79f0\u4e0a\u6d77\u65b0\u589e\u75c5\u4f8b\u4ecd\u5c5e\u6563\u53d1\u75c5\u4f8b#\u3011\\n11\u670821\u65e5\uff0c\u4e0a\u6d77\u5e02\u4e3e\u884c\u65b0\u51a0\u80ba\u708e\u75ab\u60c5\u9632\u63a7\u65b0\u95fb\u53d1\u5e03\u4f1a\u3002\u5f20\u6587\u5b8f\u5728\u4f1a\u4e0a\u8bf4\uff0c\u4e0a\u6d77\u4e0a\u4e00\u4f8b\u6563\u53d1\u75c5\u4f8b\u7684\u5904\u7406\u5df2\u5b8c\u6ee1\u7ed3\u675f\uff0c\u8fd9\u610f\u5473\u7740\uff0c\u6b64\u524d\u4e0a\u6d77\u9488\u5bf9\u75c5\u4f8b\u7684\u5168\u9762\u5e03\u63a7\u3001\u5feb\u901f\u53cd\u5e94\u3001\u7cbe\u51c6\u9632\u63a7\u975e\u5e38\u6709\u6548\u3002\u6309\u716711\u670820\u65e5#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\u7684\u8f68\u8ff9\uff0c\u76ee\u524d\u6ca1\u6709\u770b\u5230\u4ea4\u53c9\u70b9\uff0c\u8fd92\u4f8b\u75c5\u4f8b\u7684\u51fa\u73b0\u4e0e\u6d66\u4e1c\u673a\u573a\u7269\u6d41\u6709\u5173\uff0c\u4e25\u683c\u610f\u4e49\u4e0a\u8fd9\u4e0d\u80fd\u8bf4\u662f\u4e24\u6ce2\uff0c\u5e94\u8be5\u7cbe\u786e\u5b9a\u4e49\u4e3a2\u4e2a\u6563\u53d1\u75c5\u4f8b\u3002L\u4e2d\u65b0\u89c6\u9891\u7684\u5fae\u535a\u89c6\u9891 #\u75be\u75c5\u9884\u9632# \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u3010#\u5f20\u6587\u5b8f\u79f0\u4e0a\u6d77\u65b0\u589e\u75c5\u4f8b\u4ecd\u5c5e\u6563\u53d1\u75c5\u4f8b#\u3011\\n11\u670821\u65e5\uff0c\u4e0a\u6d77\u5e02\u4e3e\u884c\u65b0\u51a0\u80ba\u708e\u75ab\u60c5\u9632\u63a7\u65b0\u95fb\u53d1\u5e03\u4f1a\u3002\u5f20\u6587\u5b8f\u5728\u4f1a\u4e0a\u8bf4\uff0c\u4e0a\u6d77\u4e0a\u4e00\u4f8b\u6563\u53d1\u75c5\u4f8b\u7684\u5904\u7406\u5df2\u5b8c\u6ee1\u7ed3\u675f\uff0c\u8fd9\u610f\u5473\u7740\uff0c\u6b64\u524d\u4e0a\u6d77\u9488\u5bf9\u75c5\u4f8b\u7684\u5168\u9762\u5e03\u63a7\u3001\u5feb\u901f\u53cd\u5e94\u3001\u7cbe\u51c6\u9632\u63a7\u975e\u5e38\u6709\u6548\u3002\u6309\u716711\u670820\u65e5#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\u7684\u8f68\u8ff9\uff0c\u76ee\u524d\u6ca1\u6709\u770b\u5230\u4ea4\u53c9\u70b9\uff0c\u8fd92\u4f8b\u75c5\u4f8b \u5c55\u5f00\u5168\u6587c', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='\u6700\u8fd1\u4e00\u6bb5\u65f6\u95f4\uff0c\u56fd\u5185\u672c\u571f\u65b0\u589e\u786e\u8bca\u75c5\u4f8b\u7565\u6709\u53cd\u5f39\uff0c\u76ee\u524d\u4f20\u67d3\u6e90\u6682\u65f6\u6ca1\u6709\u516c\u5e03\u884c\u7a0b\u8f68\u8ff9\u5462\u4e5f\u8981\u5c3d\u5feb\u516c\u5e03\u51fa\u6765\uff0c\u51ac\u5929\u4e86\uff0c\u5efa\u8bae\u5927\u5bb6\u5462\u53e3\u7f69\u6234\u4e0a\u3002#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b#\\n\u8d76\u7d27\u6253\u5f00\u7535\u89c6\u5173\u6ce8\u4e0a\u6d77\u75ab\u60c5\uff01\\n\u76ee\u524d\u4e8b\u53d1\u5c0f\u533a\u8fd8\u672a\u5c01\u95ed\uff01\\n\u53ea\u662f\u505a\u4eba\u5458\u9694\u79bb\u548c\u6838\u9178\u68c0\u6d4b\uff01', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u73b0\u5728\u5df2\u7ecf\u6709\u4e86\u6d88\u606f\uff0c\u8bf4\u662f\u8fd9\u4e24\u4e2a\u75c5\u5386\u548c\u4ee5\u524d\u7684\u75c5\u4f8b\u6ca1\u6709\u5173\u8054\uff0c\u800c\u4e14\u8fd9\u75c5\u5386\u4e2d\u7684\u5973\u65b9\u662f\u533b\u9662\u7684\u62a4\u7406\u4eba\u5458\u3002\u8fd9\u6837\u5c31\u9ebb\u70e6\u4e86\uff0c\u8bf4\u660e\u8fd8\u6709\u65b0\u7684\u4f20\u67d3\u6e90\u3002\\n#\u4e0a\u6d77\u6d66\u4e1c\u533b\u96624015\u4eba\u88ab\u9694\u79bb# \u8d76\u5feb\u627e\u51c6\u6e90\u5934\uff0c\u5207\u65ad\u4f20\u64ad\u9014\u5f84\uff0c\u4e0d\u7136\u9690\u60a3\u592a\u5927\u3002\u4f46\u4e5f\u4e0d\u8981\u8fc7\u4e8e\u7d27\u5f20\uff0c\u6bd5\u7adf\u53ea\u662f\u53d1\u73b0\u4e2a\u522b\u75c5\u4f8b\uff0c\u6ca1\u6709\u5927\u8303\u56f4\u8513\u5ef6\u5f00\u3002\\n\u4e0a\u6d77\u771f\u7684\u592a\u96be\u4e86\uff0c\u8981\u63a5\u5f85\u8fd9\u4e48\u591a\u56fd\u5916\u7684\u611f\u67d3\u8005\uff0c\u53c8\u8981\u627f\u8fd0\u90a3\u4e48\u591a\u7684\u8fdb\u53e3\u51b7\u94fe\u6d77\u9c9c\uff0c\u671f\u5f85\u4e0a\u6d77\u6062\u590d\uff0c\u4e0a\u6d77\u52a0\u6cb9\uff01 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u73b0\u5728\u5df2\u7ecf\u6709\u4e86\u6d88\u606f\uff0c\u8bf4\u662f\u8fd9\u4e24\u4e2a\u75c5\u5386\u548c\u4ee5\u524d\u7684\u75c5\u4f8b\u6ca1\u6709\u5173\u8054\uff0c\u800c\u4e14\u8fd9\u75c5\u5386\u4e2d\u7684\u5973\u65b9\u662f\u533b\u9662\u7684\u62a4\u7406\u4eba\u5458\u3002\u8fd9\u6837\u5c31\u9ebb\u70e6\u4e86\uff0c\u8bf4\u660e\u8fd8\u6709\u65b0\u7684\u4f20\u67d3\u6e90\u3002\\n#\u4e0a\u6d77\u6d66\u4e1c\u533b\u96624015\u4eba\u88ab\u9694\u79bb# \u8d76\u5feb\u627e\u51c6\u6e90\u5934\uff0c\u5207\u65ad\u4f20\u64ad\u9014\u5f84\uff0c\u4e0d\u7136\u9690\u60a3\u592a\u5927\u3002\u4f46\u4e5f\u4e0d\u8981\u8fc7\u4e8e\u7d27\u5f20\uff0c\u6bd5\u7adf\u53ea\u662f\u53d1\u73b0\u4e2a\u522b\u75c5\u4f8b\uff0c\u6ca1\u6709\u5927\u8303\u56f4\u8513\u5ef6\u5f00\u3002 \u5c55\u5f00\u5168\u6587c', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u3010\u4e0a\u6d77\u6628\u65e5\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b \u65b0\u589e\u5883\u5916\u8f93\u51659\u4f8b\u3011\u636e\u4e0a\u6d77\u5e02\u536b\u5065\u59d4\u901a\u62a5\uff0c11\u670820\u65e50\u201424\u65f6\uff0c\u901a\u8fc7\u53e3\u5cb8\u8054\u9632\u8054\u63a7\u673a\u5236\uff0c\u62a5\u544a9\u4f8b\u5883\u5916\u8f93\u5165\u6027\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u300211\u670820\u65e50\u201424\u65f6\uff0c\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\u76ee\u524d\uff0c\u5df2\u8ffd\u8e2a\u5230\u5176\u5728\u672c\u5e02\u7684\u5bc6\u5207\u63a5\u89e6\u800583\u4eba\uff0c\u5747\u5df2\u843d\u5b9e\u96c6\u4e2d\u9694\u79bb\u89c2\u5bdf\u3002\u5bf9\u75c5\u4f8b\u66fe\u6d3b\u52a8\u8fc7\u7684\u573a\u6240\u5df2\u8fdb\u884c\u7ec8\u672b\u6d88\u6bd2\u3002 \u6536\u8d77\u5168\u6587d', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658), Row(keyword='\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b', content='#\u4e0a\u6d77\u65b0\u589e2\u4f8b\u672c\u5730\u786e\u8bca\u75c5\u4f8b# \u3010\u4e0a\u6d77\u6628\u65e5\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b \u65b0\u589e\u5883\u5916\u8f93\u51659\u4f8b\u3011\u636e\u4e0a\u6d77\u5e02\u536b\u5065\u59d4\u901a\u62a5\uff0c11\u670820\u65e50\u201424\u65f6\uff0c\u901a\u8fc7\u53e3\u5cb8\u8054\u9632\u8054\u63a7\u673a\u5236\uff0c\u62a5\u544a9\u4f8b\u5883\u5916\u8f93\u5165\u6027\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u300211\u670820\u65e50\u201424\u65f6\uff0c\u65b0\u589e2\u4f8b\u672c\u5730\u65b0\u51a0\u80ba\u708e\u786e\u8bca\u75c5\u4f8b\u3002\u76ee\u524d\uff0c\u5df2\u8ffd\u8e2a\u5230\u5176\u5728\u672c\u5e02\u7684\u5bc6\u5207\u63a5\u89e6\u800583\u4eba\uff0c\u5747\u5df2\u843d\u5b9e\u96c6\u4e2d\u9694\u79bb \u5c55\u5f00\u5168\u6587c', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 673058), rank=49, numbers=108658)] from time import sleep","title":"Read csv file"},{"location":"MSBD5003/projects/Project/#translation","text":"data = pd.read_csv(\"Sina_keyword.csv\", error_bad_lines=False, names=['Keyword', 'Content', 'Time', 'Rank', 'Number']) data = data[:100] from time import sleep from tqdm.auto import tqdm tqdm . pandas () translator = Translator () translator.translate(\"\u4f60\u597d\").text '\u4f60\u597d' def translate ( index : str , content : str ): has_translated = False while not has_translated : try : return translator . translate ( content ) except Exception : sleep ( 1 ) continue data [ 'Content_Translation' ] = data . progress_apply ( lambda row : translate ( row . name , row [ 'Content' ]), axis = 1 ) HBox(children=(FloatProgress(value=0.0, max=333717.0), HTML(value=''))) --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) <ipython-input-51-28c2eb176f38> in <module>() 9 10 ---> 11 data['Content_Translation'] = data.progress_apply(lambda row: translate(row.name, row['Content']), axis=1) /usr/local/lib/python3.6/dist-packages/tqdm/std.py in inner(df, func, *args, **kwargs) 751 # Apply the provided function (in **kwargs) 752 # on the df using our wrapper (which provides bar updating) --> 753 result = getattr(df, df_function)(wrapper, **kwargs) 754 755 # Close bar and return pandas calculation result /usr/local/lib/python3.6/dist-packages/pandas/core/frame.py in apply(self, func, axis, raw, result_type, args, **kwds) 7550 kwds=kwds, 7551 ) -> 7552 return op.get_result() 7553 7554 def applymap(self, func) -> \"DataFrame\": /usr/local/lib/python3.6/dist-packages/pandas/core/apply.py in get_result(self) 178 return self.apply_raw() 179 --> 180 return self.apply_standard() 181 182 def apply_empty_result(self): /usr/local/lib/python3.6/dist-packages/pandas/core/apply.py in apply_standard(self) 269 270 def apply_standard(self): --> 271 results, res_index = self.apply_series_generator() 272 273 # wrap results /usr/local/lib/python3.6/dist-packages/pandas/core/apply.py in apply_series_generator(self) 298 for i, v in enumerate(series_gen): 299 # ignore SettingWithCopy here in case the user mutates --> 300 results[i] = self.f(v) 301 if isinstance(results[i], ABCSeries): 302 # If we have a view on v, we need to make a copy because /usr/local/lib/python3.6/dist-packages/tqdm/std.py in wrapper(*args, **kwargs) 747 # take a fast or slow code path; so stop when t.total==t.n 748 t.update(n=1 if not t.total or t.n < t.total else 0) --> 749 return func(*args, **kwargs) 750 751 # Apply the provided function (in **kwargs) <ipython-input-51-28c2eb176f38> in <lambda>(row) 9 10 ---> 11 data['Content_Translation'] = data.progress_apply(lambda row: translate(row.name, row['Content']), axis=1) <ipython-input-51-28c2eb176f38> in translate(index, content) 3 while not has_translated: 4 try: ----> 5 return translator.translate(content) 6 except Exception: 7 sleep(1) /usr/local/lib/python3.6/dist-packages/googletrans/client.py in translate(self, text, dest, src, **kwargs) 180 181 origin = text --> 182 data = self._translate(text, dest, src, kwargs) 183 184 # this code will be updated when the format is changed. /usr/local/lib/python3.6/dist-packages/googletrans/client.py in _translate(self, text, dest, src, override) 81 82 url = urls.TRANSLATE.format(host=self._pick_service_url()) ---> 83 r = self.client.get(url, params=params) 84 85 if r.status_code == 200: /usr/local/lib/python3.6/dist-packages/httpx/_client.py in get(self, url, params, headers, cookies, auth, allow_redirects, timeout) 761 auth=auth, 762 allow_redirects=allow_redirects, --> 763 timeout=timeout, 764 ) 765 /usr/local/lib/python3.6/dist-packages/httpx/_client.py in request(self, method, url, data, files, json, params, headers, cookies, auth, allow_redirects, timeout) 599 ) 600 return self.send( --> 601 request, auth=auth, allow_redirects=allow_redirects, timeout=timeout, 602 ) 603 /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send(self, request, stream, auth, allow_redirects, timeout) 619 620 response = self.send_handling_redirects( --> 621 request, auth=auth, timeout=timeout, allow_redirects=allow_redirects, 622 ) 623 /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send_handling_redirects(self, request, auth, timeout, allow_redirects, history) 646 647 response = self.send_handling_auth( --> 648 request, auth=auth, timeout=timeout, history=history 649 ) 650 response.history = list(history) /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send_handling_auth(self, request, history, auth, timeout) 682 request = next(auth_flow) 683 while True: --> 684 response = self.send_single_request(request, timeout) 685 if auth.requires_response_body: 686 response.read() /usr/local/lib/python3.6/dist-packages/httpx/_client.py in send_single_request(self, request, timeout) 717 headers=request.headers.raw, 718 stream=request.stream, --> 719 timeout=timeout.as_dict(), 720 ) 721 except HTTPError as exc: /usr/local/lib/python3.6/dist-packages/httpcore/_sync/connection_pool.py in request(self, method, url, headers, stream, timeout) 151 try: 152 response = connection.request( --> 153 method, url, headers=headers, stream=stream, timeout=timeout 154 ) 155 except NewConnectionRequired: /usr/local/lib/python3.6/dist-packages/httpcore/_sync/connection.py in request(self, method, url, headers, stream, timeout) 76 \"connection.request method=%r url=%r headers=%r\", method, url, headers 77 ) ---> 78 return self.connection.request(method, url, headers, stream, timeout) 79 80 def _open_socket(self, timeout: TimeoutDict = None) -> SyncSocketStream: /usr/local/lib/python3.6/dist-packages/httpcore/_sync/http11.py in request(self, method, url, headers, stream, timeout) 60 reason_phrase, 61 headers, ---> 62 ) = self._receive_response(timeout) 63 stream = SyncByteStream( 64 iterator=self._receive_response_data(timeout), /usr/local/lib/python3.6/dist-packages/httpcore/_sync/http11.py in _receive_response(self, timeout) 113 \"\"\" 114 while True: --> 115 event = self._receive_event(timeout) 116 if isinstance(event, h11.Response): 117 break /usr/local/lib/python3.6/dist-packages/httpcore/_sync/http11.py in _receive_event(self, timeout) 143 144 if event is h11.NEED_DATA: --> 145 data = self.socket.read(self.READ_NUM_BYTES, timeout) 146 self.h11_state.receive_data(data) 147 else: /usr/local/lib/python3.6/dist-packages/httpcore/_backends/sync.py in read(self, n, timeout) 60 with map_exceptions(exc_map): 61 self.sock.settimeout(read_timeout) ---> 62 return self.sock.recv(n) 63 64 def write(self, data: bytes, timeout: TimeoutDict) -> None: /usr/lib/python3.6/ssl.py in recv(self, buflen, flags) 995 \"non-zero flags not allowed in calls to recv() on %s\" % 996 self.__class__) --> 997 return self.read(buflen) 998 else: 999 return socket.recv(self, buflen, flags) /usr/lib/python3.6/ssl.py in read(self, len, buffer) 872 raise ValueError(\"Read on closed or unwrapped SSL socket.\") 873 try: --> 874 return self._sslobj.read(len, buffer) 875 except SSLError as x: 876 if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs: /usr/lib/python3.6/ssl.py in read(self, len, buffer) 631 v = self._sslobj.read(len, buffer) 632 else: --> 633 v = self._sslobj.read(len) 634 return v 635 KeyboardInterrupt: data.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Keyword Content Time Rank Number Content_Translation 0 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u4e94\u53f7\u8981\u5954\u6708\u5566# \u3010\u5ae6\u5a25\u4e94\u53f7\u63a2\u6d4b\u5668\u5b8c\u6210\u7b2c\u4e00\u6b21\u8f68\u9053\u4fee\u6b63\u3011\u8bb0\u8005\u4ece\u56fd\u5bb6\u822a\u5929\u5c40\u83b7\u6089\uff0c\u5317\u4eac\u65f6\u95f411... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u4e94\u53f7\u8981\u5954\u6708\u5566# \u3010\u5ae6\u5a25\u4e94\u53f7\u63a2\u6d4b\u5668\u5b8c\u6210\u7b2c\u4e00\u6b21\u8f68\u9053\u4fee\u6b63\u3011\u8bb0\u8005\u4ece\u56fd\u5bb6\u822a\u5929\u5c40\u83b7\u6089\uff0c\u5317\u4eac\u65f6\u95f411... 1 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u63a2\u6708#\u3010\u52a0\u6cb9\uff0c\u5ae6\u5a25\u4e94\u53f7\uff01\u52a0\u6cb9\uff0c\u4e2d\u56fd\u822a\u5929\uff01\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c#\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u4efb... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u63a2\u6708#\u3010\u52a0\u6cb9\uff0c\u5ae6\u5a25\u4e94\u53f7\uff01\u52a0\u6cb9\uff0c\u4e2d\u56fd\u822a\u5929\uff01\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c#\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u4efb... 2 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 3 \u5ae6\u5a25\u4e94\u53f7 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 2020-11-25 04:05:07.419591+00 49.0 107064.0 #\u5ae6\u5a25\u4e94\u53f7# \u7b2c\u4e8c\u6b21\u53c2\u52a0\u957f\u4e94\u4efb\u52a1\uff0c\u53c8\u4e00\u6b21\u5706\u6ee1\u6210\u529f\uff01\u6bcf\u6b21\u5728\u53d1\u5c04\u6210\u529f\u7684\u90a3\u4e00\u523b\u5c31\u975e\u5e38\u575a\u5b9a\u81ea\u5df1\u8981\u5728\u822a... 4 \u5ae6\u5a25\u4e94\u53f7 \u5f88\u597d\u7684\u79d1\u666e\u8bdd\u9898\uff0c\u6da8\u77e5\u8bc6\u3002\\n\u300c\u5ae6\u5a25\u4e94\u53f7\u300d\u642d\u4e58\u300c\u957f\u5f81\u4e94\u53f7\u300d\u706b\u7bad\u53d1\u5c04\u6210\u529f\uff0c\u6267\u884c\u6211\u56fd\u9996\u6b21\u6708\u7403\u91c7\u6837\u8fd4... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u5f88\u597d\u7684\u79d1\u666e\u8bdd\u9898\uff0c\u6da8\u77e5\u8bc6\u3002\\n\u300c\u5ae6\u5a25\u4e94\u53f7\u300d\u642d\u4e58\u300c\u957f\u5f81\u4e94\u53f7\u300d\u706b\u7bad\u53d1\u5c04\u6210\u529f\uff0c\u6267\u884c\u6211\u56fd\u9996\u6b21\u6708\u7403\u91c7\u6837\u8fd4... 5 \u5ae6\u5a25\u4e94\u53f7 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 6 \u5ae6\u5a25\u4e94\u53f7 \u3010\u4e2d\u56fd\u63a2\u6708\u5de5\u7a0b\u201c\u4e09\u6b65\u8d70\u201d\u7684\u6536\u5b98\u4e4b\u6218\u6253\u54cd\u301111\u670824\u65e5\u51cc\u6668\uff0c\u4e2d\u56fd\u6587\u660c\u822a\u5929\u53d1\u5c04\u573a\u3002\u957f\u5f81\u4e94\u53f7\u9065\u4e94\u8fd0... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u3010\u4e2d\u56fd\u63a2\u6708\u5de5\u7a0b\u201c\u4e09\u6b65\u8d70\u201d\u7684\u6536\u5b98\u4e4b\u6218\u6253\u54cd\u301111\u670824\u65e5\u51cc\u6668\uff0c\u4e2d\u56fd\u6587\u660c\u822a\u5929\u53d1\u5c04\u573a\u3002\u957f\u5f81\u4e94\u53f7\u9065\u4e94\u8fd0... 7 \u5ae6\u5a25\u4e94\u53f7 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u3010\u5ae6\u5a25\u4e94\u53f7\u53d1\u5c04\u6210\u529f \u6e56\u5357\u201c\u795e\u7334\u201d\u7535\u7f06\u52a9\u529b\u63a2\u6708\u301111\u670824\u65e5\u51cc\u66684\u65f630\u5206\uff0c\u5728\u4e2d\u56fd\u6d77\u5357\u6587\u660c\u53d1\u5c04... 8 \u5ae6\u5a25\u4e94\u53f7 \u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301O\u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301O\u6b27\u6d32\u822a\u5929\u5c40\uff1a\u5f88\u9ad8\u5174\u4e3a\u5ae6\u5a25\u4e94\u53f7\u63a2\u6708\u63d0\u4f9b\u6570\u636e\u4f20\u8f93\u652f\u6301 9 \u5ae6\u5a25\u4e94\u53f7 \u5173\u4e8e\u5ae6\u5a25\u767b\u6708\uff0c\u505a\u79d1\u7814\uff0c\u539f\u6765\u591a\u5e74\u524d\u8001\u592b\u5b50\u6f2b\u753b\u91cc\u4e5f\u5199\u4e86\\n@Steed\u7684\u56f4\u8116 #\u5ae6\u5a25\u4e94\u53f7# 2020-11-25 04:05:07.419591+00 49.0 107064.0 \u5173\u4e8e\u5ae6\u5a25\u767b\u6708\uff0c\u505a\u79d1\u7814\uff0c\u539f\u6765\u591a\u5e74\u524d\u8001\u592b\u5b50\u6f2b\u753b\u91cc\u4e5f\u5199\u4e86\\n@Steed\u7684\u56f4\u8116 #\u5ae6\u5a25\u4e94\u53f7#","title":"Translation"},{"location":"MSBD5003/projects/Project/#preprocess-data","text":"def preprocess ( row ): d = row . asDict () if d [ 'content' ]: d [ 'content' ] = d [ 'content' ]. replace ( \"\u5c55\u5f00\u5168\u6587c\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( \"\u6536\u8d77\u5168\u6587d\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( f \"{d['keyword']}\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( \"#\" , \"\" ) d [ 'content' ] = d [ 'content' ]. replace ( \"\\n\" , \"\" ) new_row = Row ( ** d ) return new_row new_data = rdd . map ( preprocess ) print ( new_data . take ( 10 )) new_data . cache () [Row(keyword='aespa\u51fa\u9053\u66f2\u521d\u821e\u53f0', content='\u6211\u5bf9aespa\u771f\u9999\u4e86', time=datetime.datetime(2020, 11, 19, 13, 4, 5, 14218), rank=41, numbers=206090), Row(keyword='\u5929\u6d25\u5927\u5b66\u4e00\u6559\u6388\u88ab\u5b9e\u540d\u4e3e\u62a5\u5b66\u672f\u9020\u5047', content='\u521a\u521a\u5403\u996d\u7684\u65f6\u5019\u770b\u7740\u5929\u5927\u8001\u5e08\u9020\u5047\u7684\u4e8b\uff0c\u6c14\u6124\u7684\u4e0d\u884c\uff0c\u7136\u540e\u5c31\u6536\u5230\u4e86\u6211\u5e08\u59b9\u7684\u6d88\u606f\uff0c\u7b11\u7684\u4e0d\u884c\uff0c\u5206\u4eab\u4e00\u4e2a\u6211\u8ff7\u7cca\u8001\u5e08\u7684\u65e5\u5e38\uff0c\u6211\u4eec\u5e73\u5e38\u6bd4\u505a\u5b9e\u9a8c\u66f4\u91cd\u8981\u7684\u4e8b\u5c31\u662f\u5e26\u94a5\u5319\ud83d\udd11\uff0c\u4e0d\u7136\u53ef\u80fd\u51fa\u53bb\u4e0a\u4e2a\u5395\u6240\uff0c\u5c31\u8fdb\u4e0d\u53bb\u5b9e\u9a8c\u5ba4\u4e86\u53e6\u5916\u8bf7\u5927\u5bb6\u4e0d\u8981\u56e0\u4e3a\u5404\u522b\u8001\u5e08\uff0c\u800c\u5bf9\u6574\u4e2a\u5b66\u672f\u4e1a\u5931\u671b\uff0c\u8fd8\u662f\u6709\u5f88\u591a\u8001\u5e08\uff0c\u5f88\u591a\u5b66\u751f\u5728\u4e3a\u8fd9\u4e2a\u884c ', time=datetime.datetime(2020, 11, 20, 5, 4, 30, 310980), rank=9, numbers=1043499), Row(keyword='\u9009\u79c0\u4e2d\u7684\u5fc3\u810f\u72d9\u51fb\u540d\u573a\u9762', content='\\ue627\u4efb\u8c6aPOI rh\u65e2\u7136\u63d0\u5230\u4e86\u8c6a\u8c6a\uff0c\u90a3\u5c31\u6765\u770b\u770b\u5427\uff01@R1SE-\u4efb\u8c6a', time=datetime.datetime(2020, 11, 20, 20, 4, 20, 475064), rank=47, numbers=21300), Row(keyword='\u7535\u89c6\u5267\u534a\u751f\u7f18\u6539\u540d\u60c5\u6df1\u7f18\u8d77', content='\u4e0d\u77e5\u9053\u662f\u5e7f\u7535\u6709\u6bdb\u75c5\u8fd8\u662f\u600e\u6837\uff0c\u52a8\u4e0d\u52a8\u7ed9\u4eba\u7535\u89c6\u5267\u8d50\u540d\u6539\u540d\uff0c\u5b64\u57ce\u95ed\uff0c\u6492\u91ce\uff0c\u534a\u751f\u7f18\uff0c\u638c\u4e2d\u4e4b\u7269\uff0c\u4eba\u5bb6\u540d\u5b57\u591a\u597d\u542c\uff0c\u6539\u4f60\ud83d\udc34 \u54e6\uff0c\u5c31\u77e5\u9053\u778e\u6539\uff0c\u7535\u89c6\u5267\u8fd0\u6c14\u90fd\u7ed9\u4f60\u6539\u6389\u4e00\u534a\u2026', time=datetime.datetime(2020, 11, 20, 22, 5, 5, 155120), rank=16, numbers=67914), Row(keyword='\u8df3\u5316\u7caa\u6c60\u6551\u5a03\u9000\u5f79\u519b\u4eba\u6536\u5230\u6551\u52a9\u91d1', content='\u4ee5\u540e\u8fd8\u4f1a\u7ee7\u7eed\u505a\u597d\u4e8b\u3001\u597d\u6837\u7684\uff01\u771f\u7684\u4ee4\u4eba\u656c\u4f69\uff01', time=datetime.datetime(2020, 11, 21, 6, 5, 1, 624606), rank=10, numbers=714340), Row(keyword='\u6b66\u5219\u5929\u5979\u5988\u5728\u94a6\u5dde\u7814\u7a76\u5de5\u4f5c\u7ec4\u66f4\u540d', content='\u767d\u5bcc\u7f8e\u66f9\u8bd1\u6587\u7684\u65b0\u74dc\u6295\u7a3f\uff0c\u6ce2\u58eb\u987f\u5927\u5b66gpa\u4f4e\u4e8e2.0\u88ab\u9000\u5b66\uff0c\u5728\u7f8e\u56fd\u8bfb\u7814\u671f\u95f4\u8fd8\u88ab\u8bc8\u9a97\u5dee\u70b9\u88ab\u7ed1\u67b6..\u9a97\u5b50\u5927\u6982\u5c31\u662f\u9a97\u5979\uff1a\u4f60\u7239\u5728\u56fd\u5185\u60f9\u4e0a\u4e86\u5927\u9ebb\u70e6 \u53eb\u5979\u5207\u65ad\u548c\u5bb6\u4eba\u7684\u4e00\u5207\u8054\u7cfb\u5e76\u4e14\u8eb2\u5728\u9152\u5e97\u91cc\u2026\u7ed3\u679c\u5979\u4e0d\u4f46\u4fe1\u4e86 \u8fd8\u62d4\u4e86sim\u5361 \u4e56\u4e56\u7167\u505a \u5979\u7239\u5f53\u65f6\u7740\u5b9e\u88ab\u5413\u5230 \u5979\u7239\u8fd8\u662f\u6709\u70b9\u4eba\u8109\u5427 \u52a8\u7528\u4e86\u5f88\u591a\u5173\u7cfb \u51e0\u4e4e\u53d1\u52a8\u4e86\u76f8\u5f53\u5927 ', time=datetime.datetime(2020, 11, 19, 22, 4, 52, 666638), rank=1, numbers=291907), Row(keyword='\u79cb\u65e5\u6817\u6817\u6392\u9aa8\u996d', content='\u3010\u677f\u6817\u7096\u6392\u9aa8\u3011\u677f\u6817\u8f6f\u7cef\u9999\u751c\uff0c\u548c\u6392\u9aa8\u4e00\u8d77\u7096\u5230\u8f6f\u70c2\uff0c\u9171\u6cb9\u7684\u54b8\u5473\u548c\u677f\u6817\u7684\u751c\u5473\u878d\u5408\u5728\u4e00\u8d77\uff0c\u8ba9\u4eba\u65e0\u6cd5\u6297\u62d2\uff5e\u5fae\u535a\u53a8\u623f\u5927\u8d5b via\uff1a\u597d\u597d\u5403 L\u6700\u7231\u5b66\u505a\u996d\u7684\u5fae\u535a\u89c6\u9891', time=datetime.datetime(2020, 11, 20, 19, 3, 55, 682688), rank=48, numbers=29242), Row(keyword='\u9690\u79d8\u800c\u4f1f\u5927', content='\\ue627\u91d1\u6668\u4e25\u91cd\u5267\u900f\u614e\u5165\uff0c\u90fd\u662f\u8d85\u7ea7\u559c\u6b22\u7684\u7247\u6bb5\u7535\u89c6\u5267', time=datetime.datetime(2020, 11, 19, 17, 4, 54, 423157), rank=30, numbers=197616), Row(keyword='\u5355\u4f9d\u7eaf\u597d\u58f0\u97f3\u51a0\u519b', content=' \u545c\u545c\u545c\u545c\u4e0d\u6127\u662f\u6211\u6ef4\u5973\u795e\u592a\u68d2\u5566\uff01\uff01\uff01\uff01\uff01\u867d\u7136\u662f\u610f\u6599\u4e4b\u4e2d \u4f46\u662f\u8fd8\u662f\u5fcd\u4e0d\u4f4f\u975e\u5e38\u6fc0\u52a8', time=datetime.datetime(2020, 11, 21, 3, 4, 26, 288909), rank=12, numbers=379689), Row(keyword='\u4e01\u653e\u80cc\u53db\u987e\u8000\u4e1c', content='\u9690\u79d8\u800c\u4f1f\u5927 \u7b2c37-38\u96c6\u9884\u544a\uff1a\u987e\u8000\u4e1c\u9009\u62e9\u4e3b\u52a8\u56de\u8b66\u5c40\uff0c\u56de\u8b66\u5c40\u4e4b\u540e\u987e\u8000\u4e1c\u88ab\u6307\u8ba4\u901a\u5171\uff0c\u5728\u8b66\u5c40\u60e8\u906d\u9177\u5211\uff0c\u5fc3\u75bc\u4e1c\u9e45\u674e\u6613\u5cf0/\u91d1\u6668/ L\u5f71\u89c6\u5c0f\u679c\u9171\u7684\u5fae\u535a\u89c6\u9891', time=datetime.datetime(2020, 11, 19, 23, 3, 58, 114273), rank=37, numbers=90071)] PythonRDD[33] at RDD at PythonRDD.scala:53 jieba.initialize() tokenizer = jieba.Tokenizer() def sentiment ( row ): try : s = SnowNLP ( row . content ) return ( row . keyword , ( s . sentiments , row . content )) except Exception : return ( \"error\" , \"nil\" ) def keyword ( row ): return jieba . lcut ( row . keyword , cut_all = False ), row sentiments = new_data . map ( sentiment ). filter ( lambda x : x [ 0 ] != \"error\" and x [ 1 ] != \"nil\" ) sentiments . cache (). take ( 10 ) [('aespa\u51fa\u9053\u66f2\u521d\u821e\u53f0', (0.6292287669391688, '\u6211\u5bf9aespa\u771f\u9999\u4e86')), ('\u5929\u6d25\u5927\u5b66\u4e00\u6559\u6388\u88ab\u5b9e\u540d\u4e3e\u62a5\u5b66\u672f\u9020\u5047', (0.9952895196778796, '\u521a\u521a\u5403\u996d\u7684\u65f6\u5019\u770b\u7740\u5929\u5927\u8001\u5e08\u9020\u5047\u7684\u4e8b\uff0c\u6c14\u6124\u7684\u4e0d\u884c\uff0c\u7136\u540e\u5c31\u6536\u5230\u4e86\u6211\u5e08\u59b9\u7684\u6d88\u606f\uff0c\u7b11\u7684\u4e0d\u884c\uff0c\u5206\u4eab\u4e00\u4e2a\u6211\u8ff7\u7cca\u8001\u5e08\u7684\u65e5\u5e38\uff0c\u6211\u4eec\u5e73\u5e38\u6bd4\u505a\u5b9e\u9a8c\u66f4\u91cd\u8981\u7684\u4e8b\u5c31\u662f\u5e26\u94a5\u5319\ud83d\udd11\uff0c\u4e0d\u7136\u53ef\u80fd\u51fa\u53bb\u4e0a\u4e2a\u5395\u6240\uff0c\u5c31\u8fdb\u4e0d\u53bb\u5b9e\u9a8c\u5ba4\u4e86\u53e6\u5916\u8bf7\u5927\u5bb6\u4e0d\u8981\u56e0\u4e3a\u5404\u522b\u8001\u5e08\uff0c\u800c\u5bf9\u6574\u4e2a\u5b66\u672f\u4e1a\u5931\u671b\uff0c\u8fd8\u662f\u6709\u5f88\u591a\u8001\u5e08\uff0c\u5f88\u591a\u5b66\u751f\u5728\u4e3a\u8fd9\u4e2a\u884c ')), ('\u9009\u79c0\u4e2d\u7684\u5fc3\u810f\u72d9\u51fb\u540d\u573a\u9762', (0.8225709747637443, '\\ue627\u4efb\u8c6aPOI rh\u65e2\u7136\u63d0\u5230\u4e86\u8c6a\u8c6a\uff0c\u90a3\u5c31\u6765\u770b\u770b\u5427\uff01@R1SE-\u4efb\u8c6a')), ('\u7535\u89c6\u5267\u534a\u751f\u7f18\u6539\u540d\u60c5\u6df1\u7f18\u8d77', (0.6790462184223255, '\u4e0d\u77e5\u9053\u662f\u5e7f\u7535\u6709\u6bdb\u75c5\u8fd8\u662f\u600e\u6837\uff0c\u52a8\u4e0d\u52a8\u7ed9\u4eba\u7535\u89c6\u5267\u8d50\u540d\u6539\u540d\uff0c\u5b64\u57ce\u95ed\uff0c\u6492\u91ce\uff0c\u534a\u751f\u7f18\uff0c\u638c\u4e2d\u4e4b\u7269\uff0c\u4eba\u5bb6\u540d\u5b57\u591a\u597d\u542c\uff0c\u6539\u4f60\ud83d\udc34 \u54e6\uff0c\u5c31\u77e5\u9053\u778e\u6539\uff0c\u7535\u89c6\u5267\u8fd0\u6c14\u90fd\u7ed9\u4f60\u6539\u6389\u4e00\u534a\u2026')), ('\u8df3\u5316\u7caa\u6c60\u6551\u5a03\u9000\u5f79\u519b\u4eba\u6536\u5230\u6551\u52a9\u91d1', (0.824867218915397, '\u4ee5\u540e\u8fd8\u4f1a\u7ee7\u7eed\u505a\u597d\u4e8b\u3001\u597d\u6837\u7684\uff01\u771f\u7684\u4ee4\u4eba\u656c\u4f69\uff01')), ('\u6b66\u5219\u5929\u5979\u5988\u5728\u94a6\u5dde\u7814\u7a76\u5de5\u4f5c\u7ec4\u66f4\u540d', (0.37617857183276393, '\u767d\u5bcc\u7f8e\u66f9\u8bd1\u6587\u7684\u65b0\u74dc\u6295\u7a3f\uff0c\u6ce2\u58eb\u987f\u5927\u5b66gpa\u4f4e\u4e8e2.0\u88ab\u9000\u5b66\uff0c\u5728\u7f8e\u56fd\u8bfb\u7814\u671f\u95f4\u8fd8\u88ab\u8bc8\u9a97\u5dee\u70b9\u88ab\u7ed1\u67b6..\u9a97\u5b50\u5927\u6982\u5c31\u662f\u9a97\u5979\uff1a\u4f60\u7239\u5728\u56fd\u5185\u60f9\u4e0a\u4e86\u5927\u9ebb\u70e6 \u53eb\u5979\u5207\u65ad\u548c\u5bb6\u4eba\u7684\u4e00\u5207\u8054\u7cfb\u5e76\u4e14\u8eb2\u5728\u9152\u5e97\u91cc\u2026\u7ed3\u679c\u5979\u4e0d\u4f46\u4fe1\u4e86 \u8fd8\u62d4\u4e86sim\u5361 \u4e56\u4e56\u7167\u505a \u5979\u7239\u5f53\u65f6\u7740\u5b9e\u88ab\u5413\u5230 \u5979\u7239\u8fd8\u662f\u6709\u70b9\u4eba\u8109\u5427 \u52a8\u7528\u4e86\u5f88\u591a\u5173\u7cfb \u51e0\u4e4e\u53d1\u52a8\u4e86\u76f8\u5f53\u5927 ')), ('\u79cb\u65e5\u6817\u6817\u6392\u9aa8\u996d', (0.9999301000032879, '\u3010\u677f\u6817\u7096\u6392\u9aa8\u3011\u677f\u6817\u8f6f\u7cef\u9999\u751c\uff0c\u548c\u6392\u9aa8\u4e00\u8d77\u7096\u5230\u8f6f\u70c2\uff0c\u9171\u6cb9\u7684\u54b8\u5473\u548c\u677f\u6817\u7684\u751c\u5473\u878d\u5408\u5728\u4e00\u8d77\uff0c\u8ba9\u4eba\u65e0\u6cd5\u6297\u62d2\uff5e\u5fae\u535a\u53a8\u623f\u5927\u8d5b via\uff1a\u597d\u597d\u5403 L\u6700\u7231\u5b66\u505a\u996d\u7684\u5fae\u535a\u89c6\u9891')), ('\u9690\u79d8\u800c\u4f1f\u5927', (0.9961075258005379, '\\ue627\u91d1\u6668\u4e25\u91cd\u5267\u900f\u614e\u5165\uff0c\u90fd\u662f\u8d85\u7ea7\u559c\u6b22\u7684\u7247\u6bb5\u7535\u89c6\u5267')), ('\u5355\u4f9d\u7eaf\u597d\u58f0\u97f3\u51a0\u519b', (0.9996645862980169, ' \u545c\u545c\u545c\u545c\u4e0d\u6127\u662f\u6211\u6ef4\u5973\u795e\u592a\u68d2\u5566\uff01\uff01\uff01\uff01\uff01\u867d\u7136\u662f\u610f\u6599\u4e4b\u4e2d \u4f46\u662f\u8fd8\u662f\u5fcd\u4e0d\u4f4f\u975e\u5e38\u6fc0\u52a8')), ('\u4e01\u653e\u80cc\u53db\u987e\u8000\u4e1c', (0.9984970249089633, '\u9690\u79d8\u800c\u4f1f\u5927 \u7b2c37-38\u96c6\u9884\u544a\uff1a\u987e\u8000\u4e1c\u9009\u62e9\u4e3b\u52a8\u56de\u8b66\u5c40\uff0c\u56de\u8b66\u5c40\u4e4b\u540e\u987e\u8000\u4e1c\u88ab\u6307\u8ba4\u901a\u5171\uff0c\u5728\u8b66\u5c40\u60e8\u906d\u9177\u5211\uff0c\u5fc3\u75bc\u4e1c\u9e45\u674e\u6613\u5cf0/\u91d1\u6668/ L\u5f71\u89c6\u5c0f\u679c\u9171\u7684\u5fae\u535a\u89c6\u9891'))] def groupValues ( values ): total = 0 i = 0 for v in values : sentiments , content = v total += sentiments i += 1 return total / i grouped = sentiments . groupByKey (). mapValues ( groupValues ) print ( grouped . take ( 10 )) --------------------------------------------------------------------------- KeyboardInterrupt Traceback (most recent call last) <ipython-input-28-0b92fc34bf9d> in <module>() 10 11 grouped = sentiments.groupByKey().mapValues(groupValues) ---> 12 print(grouped.take(10)) /usr/local/lib/python3.6/dist-packages/pyspark/rdd.py in take(self, num) 1444 1445 p = range(partsScanned, min(partsScanned + numPartsToTry, totalParts)) -> 1446 res = self.context.runJob(self, takeUpToNumLeft, p) 1447 1448 items += res /usr/local/lib/python3.6/dist-packages/pyspark/context.py in runJob(self, rdd, partitionFunc, partitions, allowLocal) 1116 # SparkContext#runJob. 1117 mappedRDD = rdd.mapPartitions(partitionFunc) -> 1118 sock_info = self._jvm.PythonRDD.runJob(self._jsc.sc(), mappedRDD._jrdd, partitions) 1119 return list(_load_from_socket(sock_info, mappedRDD._jrdd_deserializer)) 1120 /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in __call__(self, *args) 1301 proto.END_COMMAND_PART 1302 -> 1303 answer = self.gateway_client.send_command(command) 1304 return_value = get_return_value( 1305 answer, self.gateway_client, self.target_id, self.name) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command, retry, binary) 1031 connection = self._get_connection() 1032 try: -> 1033 response = connection.send_command(command) 1034 if binary: 1035 return response, self._create_connection_guard(connection) /usr/local/lib/python3.6/dist-packages/py4j/java_gateway.py in send_command(self, command) 1198 1199 try: -> 1200 answer = smart_decode(self.stream.readline()[:-1]) 1201 logger.debug(\"Answer received: {0}\".format(answer)) 1202 if answer.startswith(proto.RETURN_MESSAGE): /usr/lib/python3.6/socket.py in readinto(self, b) 584 while True: 585 try: --> 586 return self._sock.recv_into(b) 587 except timeout: 588 self._timeout_occurred = True KeyboardInterrupt: pos = sentiments.filter(lambda x: x[1][0] > 0.75).count() neg = sentiments.filter(lambda x: x[1][0] <= 0.35).count() net = sentiments.filter(lambda x: x[1][0] > 0.35 and x[1][0] <= 0.75).count() plt.figure(figsize=(10,10)) plt.bar(\"Positive\", pos) plt.bar(\"Neutral\", net) plt.bar(\"Negative\", neg) plt.xlabel(\"Sentiment\") plt.ylabel(\"Number of posts\") plt.title(\"Sina Weibo Sentiment\") plt.savefig(\"sina.png\")","title":"preprocess data"},{"location":"MSBD5006/Lecture%201/","text":"Asset returns \u00b6 Let \\(p_t\\) be the price of an asset at time t, and assume no dividend. One-period simple return or simple net return. \\[R_t = \\frac{P_t}{P_t-1} - 1 = \\frac{P_t - P_{t-1}}{P_{t-1}} \\] Gross return \\[ 1 + P_t = \\frac{P_t}{P_{t - 1}}\\ or P_t = P_{t-1}(1+P_t) \\] Multi-period simple return or the k-period simple net return \\[R_t(k) = \\frac{P_t}{P_{t-k}}-1\\] Gross return \\[1 + R_t(k) = \\sum^{k -1 }_{j=0}(1+R_{t-j}) \\] Continues Compounding \u00b6 from math import exp def pay_interest ( base , interest , payments ): return base * ( base + interest / payments ) ** payments def pay_interest_continue ( base , interest , number_of_years ): return base * exp ( interest * number_of_years ) pay_interest_continue(1, 0.1, 1) 1.1051709180756477 \\[ R_t = log \\] Log return \u00b6 \\[r_{pt} = \\sum_{i = 1}{n}w_ir_{it}\\] Excess return \u00b6 \\[Z_t = R_t - R_{0t}, z_t = r_t - r_{0t}\\] where \\(r_{0t}\\) denotes the log return of a reference asset (e.g. risk-free interest rate) such as shortterm U.S. Treasury bill return, etc..","title":"Lecture 1"},{"location":"MSBD5006/Lecture%201/#asset-returns","text":"Let \\(p_t\\) be the price of an asset at time t, and assume no dividend. One-period simple return or simple net return. \\[R_t = \\frac{P_t}{P_t-1} - 1 = \\frac{P_t - P_{t-1}}{P_{t-1}} \\] Gross return \\[ 1 + P_t = \\frac{P_t}{P_{t - 1}}\\ or P_t = P_{t-1}(1+P_t) \\] Multi-period simple return or the k-period simple net return \\[R_t(k) = \\frac{P_t}{P_{t-k}}-1\\] Gross return \\[1 + R_t(k) = \\sum^{k -1 }_{j=0}(1+R_{t-j}) \\]","title":"Asset returns"},{"location":"MSBD5006/Lecture%201/#continues-compounding","text":"from math import exp def pay_interest ( base , interest , payments ): return base * ( base + interest / payments ) ** payments def pay_interest_continue ( base , interest , number_of_years ): return base * exp ( interest * number_of_years ) pay_interest_continue(1, 0.1, 1) 1.1051709180756477 \\[ R_t = log \\]","title":"Continues Compounding"},{"location":"MSBD5006/Lecture%201/#log-return","text":"\\[r_{pt} = \\sum_{i = 1}{n}w_ir_{it}\\]","title":"Log return"},{"location":"MSBD5006/Lecture%201/#excess-return","text":"\\[Z_t = R_t - R_{0t}, z_t = r_t - r_{0t}\\] where \\(r_{0t}\\) denotes the log return of a reference asset (e.g. risk-free interest rate) such as shortterm U.S. Treasury bill return, etc..","title":"Excess return"},{"location":"MSBD5006/Lecture%202/","text":"Mean and variance: \u03bcx = E(X) and \u03c3x2 = Var(X) = E(X \u2212 \u03bcx)2 Skewness (symmetry) and kurtosis (fat-tails) Kurtosis: How high is the p High kurtosis implies heavy (or long) tails in dis- tribution. Symmetry has important implications in holding short or long financial positions and in risk man- agement. (X \u2212 \u03bcx)3 (X \u2212 \u03bcx)4 S ( x ) = E \u03c3 x3 , K ( x ) = E \u03c3 x4 . Normal distribution \u00b6 E(X) = \u03bc Var(X) = \u03c32 S(X) = 0 K(X) = 3 ml = 0, for l is odd. T-distribution \u00b6 Symmetry at 0 \\[E(x) > 0, v >1\\] Chi-squared distribution \u00b6 \\[E(X) = k$$ $$Var(X) = 2k\\] Joint Distribution \u00b6 \\[F_{X,Y}(x, y) = P(X\\leq x, Y\\leq y)\\] Marginal Distribution \u00b6 The marginal distribution of X is obtained by integrating out Y . A similar definition applies to the marginal distribution of Y .","title":"Lecture 2"},{"location":"MSBD5006/Lecture%202/#normal-distribution","text":"E(X) = \u03bc Var(X) = \u03c32 S(X) = 0 K(X) = 3 ml = 0, for l is odd.","title":"Normal distribution"},{"location":"MSBD5006/Lecture%202/#t-distribution","text":"Symmetry at 0 \\[E(x) > 0, v >1\\]","title":"T-distribution"},{"location":"MSBD5006/Lecture%202/#chi-squared-distribution","text":"\\[E(X) = k$$ $$Var(X) = 2k\\]","title":"Chi-squared distribution"},{"location":"MSBD5006/Lecture%202/#joint-distribution","text":"\\[F_{X,Y}(x, y) = P(X\\leq x, Y\\leq y)\\]","title":"Joint Distribution"},{"location":"MSBD5006/Lecture%202/#marginal-distribution","text":"The marginal distribution of X is obtained by integrating out Y . A similar definition applies to the marginal distribution of Y .","title":"Marginal Distribution"},{"location":"MSBD5008/Lecture2/","text":"Undirected vs Directed Networks \u00b6 Undirected graph Links: undirected Example Collaborations Friendship on Facebook Directed Links: Directed Example Phone calls (If you want to represent the relationship between caller and callee, then you can use undirected graph) Following on Twitter Connectivity of graphs \u00b6 Undirected graph \u00b6 Connected: Any two vertices can be joined by a path A disconnected graph is made up of two or more connected components. Bridge edge: If we erase it, the graph becomes disconnected. Articulation point: If we erase it, the graph becomes disconnected Isolated node: Node without any connected neighbors. Directed graph \u00b6 Strongly connected directed graph: Has a path from each node to every other node and vice versa Weakly connected directed graph: Is connected if we disregard the edge directions Directed Acyclic Graph: Has no cyclesL if u can reach v, the v cannot reach u. Strongly connected components: is a set of nodes S so that: Every pair of nodes in S can reach each other There is no larger set containing S with this property Node degree: The number of edges adjacent to node i Avg. degree: \\(\\hat{k} = \\frac{1}{N}\\) , \\(K_i = \\frac{2E}{N}\\) In directed networks we define an in-degree and out-degree . The total degree of a node is the sum of in-and out-degrees. Complete Graph \u00b6 Maximum number edges in undirected graph on N nodes. \\[ E_{max} = \\frac{N(N-1)}{2} \\] A graph with the number of edges $E = E_{max} $ is a complete graph and its average degree is N - 1 Unweighted graph \u00b6 Graph without weight. For example, Friendship and sex. Weighted graph \u00b6 Graph with weight. For example collaboration with internet roads. Self-edges (Self-loops) \u00b6 Examples: Proteins, Hyperlinks (A web page link which points to itself) Multigraph \u00b6 Examples: Communication, collaboration Examples \u00b6 Example Type www Directed Facebook friendships Undirected, unweighted Citation networks Unweighted, directed, acyclic Collaboration networks Undirected multigraph or weighted graph Mobile phone calls directed Protein interactions Undirected, unweighted with self-interactions Bipartite Graph \u00b6 A graph whose nodes can be divided into two disjoint sets U and V such that every link connects a node in U to one in V; that is U and V are independent sets. Examples \u00b6 Authors-to-papers Actors-to-movies Degree distribution P(k): \u00b6 Probability that a randomly chosen node has degree k. Normalized histogram: \u00b6 \\(P(k) = N_k / N\\) Distance \u00b6 Between a pair of nodes is defined as the number of edges along the shortest path connecting the nodes In directed graphs paths need to follow the direction of the arrows. So that distance is not symmetric \\(h_{a,c} \\neq h_{c,a}\\) Diameter \u00b6 The maximum distance (shortest graph) between any pair of nodes in a graph. Clustering coefficient \u00b6 \\( \\(C_i = \\frac{2e_i}{k_i(k_i - 1)}\\) \\) where \\(e_i\\) is the number of edges between the neighbors of node i. Web as a graph \u00b6 Nodes = Web pages Edges = hyperlinks Side issues \u00b6 Dynamic pages created on the fly Dark matter - inaccessible database generated pages","title":"Lecture2"},{"location":"MSBD5008/Lecture2/#undirected-vs-directed-networks","text":"Undirected graph Links: undirected Example Collaborations Friendship on Facebook Directed Links: Directed Example Phone calls (If you want to represent the relationship between caller and callee, then you can use undirected graph) Following on Twitter","title":"Undirected vs Directed Networks"},{"location":"MSBD5008/Lecture2/#connectivity-of-graphs","text":"","title":"Connectivity of graphs"},{"location":"MSBD5008/Lecture2/#undirected-graph","text":"Connected: Any two vertices can be joined by a path A disconnected graph is made up of two or more connected components. Bridge edge: If we erase it, the graph becomes disconnected. Articulation point: If we erase it, the graph becomes disconnected Isolated node: Node without any connected neighbors.","title":"Undirected graph"},{"location":"MSBD5008/Lecture2/#directed-graph","text":"Strongly connected directed graph: Has a path from each node to every other node and vice versa Weakly connected directed graph: Is connected if we disregard the edge directions Directed Acyclic Graph: Has no cyclesL if u can reach v, the v cannot reach u. Strongly connected components: is a set of nodes S so that: Every pair of nodes in S can reach each other There is no larger set containing S with this property Node degree: The number of edges adjacent to node i Avg. degree: \\(\\hat{k} = \\frac{1}{N}\\) , \\(K_i = \\frac{2E}{N}\\) In directed networks we define an in-degree and out-degree . The total degree of a node is the sum of in-and out-degrees.","title":"Directed graph"},{"location":"MSBD5008/Lecture2/#complete-graph","text":"Maximum number edges in undirected graph on N nodes. \\[ E_{max} = \\frac{N(N-1)}{2} \\] A graph with the number of edges $E = E_{max} $ is a complete graph and its average degree is N - 1","title":"Complete Graph"},{"location":"MSBD5008/Lecture2/#unweighted-graph","text":"Graph without weight. For example, Friendship and sex.","title":"Unweighted graph"},{"location":"MSBD5008/Lecture2/#weighted-graph","text":"Graph with weight. For example collaboration with internet roads.","title":"Weighted graph"},{"location":"MSBD5008/Lecture2/#self-edges-self-loops","text":"Examples: Proteins, Hyperlinks (A web page link which points to itself)","title":"Self-edges (Self-loops)"},{"location":"MSBD5008/Lecture2/#multigraph","text":"Examples: Communication, collaboration","title":"Multigraph"},{"location":"MSBD5008/Lecture2/#examples","text":"Example Type www Directed Facebook friendships Undirected, unweighted Citation networks Unweighted, directed, acyclic Collaboration networks Undirected multigraph or weighted graph Mobile phone calls directed Protein interactions Undirected, unweighted with self-interactions","title":"Examples"},{"location":"MSBD5008/Lecture2/#bipartite-graph","text":"A graph whose nodes can be divided into two disjoint sets U and V such that every link connects a node in U to one in V; that is U and V are independent sets.","title":"Bipartite Graph"},{"location":"MSBD5008/Lecture2/#examples_1","text":"Authors-to-papers Actors-to-movies","title":"Examples"},{"location":"MSBD5008/Lecture2/#degree-distribution-pk","text":"Probability that a randomly chosen node has degree k.","title":"Degree distribution P(k):"},{"location":"MSBD5008/Lecture2/#normalized-histogram","text":"\\(P(k) = N_k / N\\)","title":"Normalized histogram:"},{"location":"MSBD5008/Lecture2/#distance","text":"Between a pair of nodes is defined as the number of edges along the shortest path connecting the nodes In directed graphs paths need to follow the direction of the arrows. So that distance is not symmetric \\(h_{a,c} \\neq h_{c,a}\\)","title":"Distance"},{"location":"MSBD5008/Lecture2/#diameter","text":"The maximum distance (shortest graph) between any pair of nodes in a graph.","title":"Diameter"},{"location":"MSBD5008/Lecture2/#clustering-coefficient","text":"\\( \\(C_i = \\frac{2e_i}{k_i(k_i - 1)}\\) \\) where \\(e_i\\) is the number of edges between the neighbors of node i.","title":"Clustering coefficient"},{"location":"MSBD5008/Lecture2/#web-as-a-graph","text":"Nodes = Web pages Edges = hyperlinks","title":"Web as a graph"},{"location":"MSBD5008/Lecture2/#side-issues","text":"Dynamic pages created on the fly Dark matter - inaccessible database generated pages","title":"Side issues"},{"location":"MSBD5008/Lecture3/","text":"Representation Learning on networks \u00b6 Why Is It Hard? \u00b6 Modern deep learning toolbox is designed for simple sequences or grids. But networks are far more complex! Complex topographical structure (i.e., NO Spatial locality like grids) Node embeddings \u00b6 Goal is to encode nodes so that similarity in the embedding space (e.g., dot product) approximates similarity in the original network. Setup \u00b6 Assume we have a graph G: V is the vertex set. A is the adjacency matrix (assume binary). No node features or extra information is used! \u201cShallow\u201d Encoding \u00b6 Simplest encoding approach: each node is assigned a unique embedding vector. We will focus on shallow encoding in this section... After the break we will discuss more encoders based on deep neural networks. How to Define Node Similarity? \u00b6 Key distinction between \u201cshallow\u201d methods is how they define node similarity. E.g., should two nodes have similar embeddings if they - are connected? - share neighbors - have similar \u201cstructural roles\u201d? Adjacency-based Similarity \u00b6 Similarity function is just the edge weight between u and v in the original network. Intuition: Dot products between node embeddings approximate edge existence. Drawbacks \u00b6 \\(O(V^2)\\) runtime \\(O(V)\\) paramters Only sonsiders direct, local connections Multihop Similarity \u00b6 Idea: Consider k-hop node neighbors Issues \u00b6 Expensive: Generally \\(O(|V^2|)\\) , since we need to iterate over all pairs of nodes. Brittle: Must hand-design deterministic node similarity measures. Massive parameter space: \\(O(|V|)\\) parameters Randome walk Method \u00b6 Estimate probability of visiting node \\(v\\) on a random walk starting from node \\(u\\) using some random walk strategy \\(R\\) . Optimize embeddings to encode these random walk statistics. Why Random Walks? \u00b6 Expressivity: Flexible stochastic definition of node similarity that incorporates both local and higher- order neighborhood information. Efficiency: Do not need to consider all node pairs when training; only need to consider pairs that co-occur on random walks. Random Walk Optimization \u00b6 Run short random walks starting from each node on the graph using some strategy For each node wu collect \\(N_R(U)\\) , the multiset\u201d of nodes visited on random walks starting rom \\(uw\\) . Optimize embeddings to according to \\[L = \\sum_{u\\in V}\\sum_{v \\in NR(U)} - log(P(v |Z_u))\\] (1) Sum over all nodes u (2) sum over nodes v seen on random walks starting from u (3) Predicted probability if u and v co-occuring on random walk Optimizing random walk embeddings = Finding embeddings \\(Z_u\\) that minimize L Graph neural networks \u00b6 From Shallow to Deep \u00b6 Limitations of shallow encoding: O(|V|) parameters are needed: there no parameter sharing and every node has its own unique embedding vector. Inherently \u201ctransductive\u2019: It is impossible to generate embeddings for nodes that were not seen during training. Do not incorporate node features: Many graphs have features that we can and should leverage. Setup \u00b6 Assume we have a graph G: V is the vertex set. A is the adjacency matrix (assume binary). \\(X\\in R^{m \\times |v|}\\) is a matrix of node features Categorical attributes, text, image data \u2014 E.g., profile information in a social network. Node degrees, clustering coefficients, etc. \" Indicator vectors (i.e., one-hot encoding of each node) Neighborhood aggregation \u00b6 Generate node embeddings based on local neighborhoods NetworkX \u00b6 !pip install networkx Requirement already satisfied: networkx in /usr/local/lib/python3.6/dist-packages (2.5) Requirement already satisfied: decorator>=4.3.0 in /usr/local/lib/python3.6/dist-packages (from networkx) (4.4.2)","title":"Lecture3"},{"location":"MSBD5008/Lecture3/#representation-learning-on-networks","text":"","title":"Representation Learning on networks"},{"location":"MSBD5008/Lecture3/#why-is-it-hard","text":"Modern deep learning toolbox is designed for simple sequences or grids. But networks are far more complex! Complex topographical structure (i.e., NO Spatial locality like grids)","title":"Why Is It Hard?"},{"location":"MSBD5008/Lecture3/#node-embeddings","text":"Goal is to encode nodes so that similarity in the embedding space (e.g., dot product) approximates similarity in the original network.","title":"Node embeddings"},{"location":"MSBD5008/Lecture3/#setup","text":"Assume we have a graph G: V is the vertex set. A is the adjacency matrix (assume binary). No node features or extra information is used!","title":"Setup"},{"location":"MSBD5008/Lecture3/#shallow-encoding","text":"Simplest encoding approach: each node is assigned a unique embedding vector. We will focus on shallow encoding in this section... After the break we will discuss more encoders based on deep neural networks.","title":"\u201cShallow\u201d Encoding"},{"location":"MSBD5008/Lecture3/#how-to-define-node-similarity","text":"Key distinction between \u201cshallow\u201d methods is how they define node similarity. E.g., should two nodes have similar embeddings if they - are connected? - share neighbors - have similar \u201cstructural roles\u201d?","title":"How to Define Node Similarity?"},{"location":"MSBD5008/Lecture3/#adjacency-based-similarity","text":"Similarity function is just the edge weight between u and v in the original network. Intuition: Dot products between node embeddings approximate edge existence.","title":"Adjacency-based Similarity"},{"location":"MSBD5008/Lecture3/#drawbacks","text":"\\(O(V^2)\\) runtime \\(O(V)\\) paramters Only sonsiders direct, local connections","title":"Drawbacks"},{"location":"MSBD5008/Lecture3/#multihop-similarity","text":"Idea: Consider k-hop node neighbors","title":"Multihop Similarity"},{"location":"MSBD5008/Lecture3/#issues","text":"Expensive: Generally \\(O(|V^2|)\\) , since we need to iterate over all pairs of nodes. Brittle: Must hand-design deterministic node similarity measures. Massive parameter space: \\(O(|V|)\\) parameters","title":"Issues"},{"location":"MSBD5008/Lecture3/#randome-walk-method","text":"Estimate probability of visiting node \\(v\\) on a random walk starting from node \\(u\\) using some random walk strategy \\(R\\) . Optimize embeddings to encode these random walk statistics.","title":"Randome walk Method"},{"location":"MSBD5008/Lecture3/#why-random-walks","text":"Expressivity: Flexible stochastic definition of node similarity that incorporates both local and higher- order neighborhood information. Efficiency: Do not need to consider all node pairs when training; only need to consider pairs that co-occur on random walks.","title":"Why Random Walks?"},{"location":"MSBD5008/Lecture3/#random-walk-optimization","text":"Run short random walks starting from each node on the graph using some strategy For each node wu collect \\(N_R(U)\\) , the multiset\u201d of nodes visited on random walks starting rom \\(uw\\) . Optimize embeddings to according to \\[L = \\sum_{u\\in V}\\sum_{v \\in NR(U)} - log(P(v |Z_u))\\] (1) Sum over all nodes u (2) sum over nodes v seen on random walks starting from u (3) Predicted probability if u and v co-occuring on random walk Optimizing random walk embeddings = Finding embeddings \\(Z_u\\) that minimize L","title":"Random Walk Optimization"},{"location":"MSBD5008/Lecture3/#graph-neural-networks","text":"","title":"Graph neural networks"},{"location":"MSBD5008/Lecture3/#from-shallow-to-deep","text":"Limitations of shallow encoding: O(|V|) parameters are needed: there no parameter sharing and every node has its own unique embedding vector. Inherently \u201ctransductive\u2019: It is impossible to generate embeddings for nodes that were not seen during training. Do not incorporate node features: Many graphs have features that we can and should leverage.","title":"From Shallow to Deep"},{"location":"MSBD5008/Lecture3/#setup_1","text":"Assume we have a graph G: V is the vertex set. A is the adjacency matrix (assume binary). \\(X\\in R^{m \\times |v|}\\) is a matrix of node features Categorical attributes, text, image data \u2014 E.g., profile information in a social network. Node degrees, clustering coefficients, etc. \" Indicator vectors (i.e., one-hot encoding of each node)","title":"Setup"},{"location":"MSBD5008/Lecture3/#neighborhood-aggregation","text":"Generate node embeddings based on local neighborhoods","title":"Neighborhood aggregation"},{"location":"MSBD5008/Lecture3/#networkx","text":"!pip install networkx Requirement already satisfied: networkx in /usr/local/lib/python3.6/dist-packages (2.5) Requirement already satisfied: decorator>=4.3.0 in /usr/local/lib/python3.6/dist-packages (from networkx) (4.4.2)","title":"NetworkX"},{"location":"MSBD5008/Lecture4/","text":"Jaccard similarity: \u00b6 measures similarity between sample sets - \\[J(a, b) = \\frac{A \\cap B}{A \\cup B}\\] Problem with previous similarity functions \u00b6 You need to re-run the algorithm again when new node has been added. Graph Neural Network \u00b6 learn the mapping between node and vector. Train the model \u00b6 Directly train the model for a supervised task (e.g., node classification) After K-layers of neighborhood aggregation, we get output embeddings for each node. We can feed these embeddings into any loss function and run stochastic gradient descent to train the aggregation parameters. Granovetter's explaination \u00b6 Define Bridge edge If removed, it disconnects the graph Extremely rare in social networks Define: Local bridge Endpoints have no friends in common a Edge of Span > 2 (Span of an edge is the distance of the edge endpoints if the edge is deleted. Local bridges with long span are like real bridges) Define: Two types of edges: Strong (friend), Weak (acquaintance) Define: Strong triadic closure: Two strong ties imply a third edge","title":"Lecture4"},{"location":"MSBD5008/Lecture4/#jaccard-similarity","text":"measures similarity between sample sets - \\[J(a, b) = \\frac{A \\cap B}{A \\cup B}\\]","title":"Jaccard similarity:"},{"location":"MSBD5008/Lecture4/#problem-with-previous-similarity-functions","text":"You need to re-run the algorithm again when new node has been added.","title":"Problem with previous similarity functions"},{"location":"MSBD5008/Lecture4/#graph-neural-network","text":"learn the mapping between node and vector.","title":"Graph Neural Network"},{"location":"MSBD5008/Lecture4/#train-the-model","text":"Directly train the model for a supervised task (e.g., node classification) After K-layers of neighborhood aggregation, we get output embeddings for each node. We can feed these embeddings into any loss function and run stochastic gradient descent to train the aggregation parameters.","title":"Train the model"},{"location":"MSBD5008/Lecture4/#granovetters-explaination","text":"Define Bridge edge If removed, it disconnects the graph Extremely rare in social networks Define: Local bridge Endpoints have no friends in common a Edge of Span > 2 (Span of an edge is the distance of the edge endpoints if the edge is deleted. Local bridges with long span are like real bridges) Define: Two types of edges: Strong (friend), Weak (acquaintance) Define: Strong triadic closure: Two strong ties imply a third edge","title":"Granovetter's explaination"},{"location":"MSBD5008/Lecture5/","text":"Giravan Newman \u00b6 Divisive hierarchical clustering based on the notion of edge betweenness: - Number of shortest paths passing through the edge Girvan-Newman Algorithm: - Undirected unweighted networks - Repeat until no edges are left: - Calculate betweenness of edges - Remove the edge with the highest betweenness (if two or more edges tie for highest score, remove all of them) Connected components are communities Gives a hierarchical decomposition of the network Betweeness \u00b6 BFS Starting from the node you want to start from typing import List class Node : def __init__ ( self , value ): self . connections : List [ Node ] = [] self . value = value self . distance = 0 3","title":"Lecture5"},{"location":"MSBD5008/Lecture5/#giravan-newman","text":"Divisive hierarchical clustering based on the notion of edge betweenness: - Number of shortest paths passing through the edge Girvan-Newman Algorithm: - Undirected unweighted networks - Repeat until no edges are left: - Calculate betweenness of edges - Remove the edge with the highest betweenness (if two or more edges tie for highest score, remove all of them) Connected components are communities Gives a hierarchical decomposition of the network","title":"Giravan Newman"},{"location":"MSBD5008/Lecture5/#betweeness","text":"BFS Starting from the node you want to start from typing import List class Node : def __init__ ( self , value ): self . connections : List [ Node ] = [] self . value = value self . distance = 0 3","title":"Betweeness"},{"location":"MSBD5008/Lectyre6/","text":"The SIR model \u00b6 S: The number of susceptible individuals. When a susceptible and an infectious individual come into \"infectious contact\", the susceptible individual contracts the disease and transitions to the infectious compartment. I: The number of infectious individuals. These are individuals who have been infected and are capable of infecting susceptible individuals. R for the number of removed (and immune) or deceased individuals. These are individuals who have been infected and have either recovered from the disease and entered the removed compartment, or died. It is assumed that the number of deaths is negligible with respect to the total population. This compartment may also be called \"recovered\" or \"resistant\". The SIS model \u00b6 Some infections, for example, those from the common cold and influenza, do not confer any long-lasting immunity. Such infections do not give immunity upon recovery from infection, and individuals become susceptible again. Decision Based Models \u00b6 Payoffs: Utility of making a particular choice Signals Public information Private Information Scenario: Graph where everyone starts witn b. Small set S of early adopters of A Hard-wire S \u2014 they keep using A no matter what payoffs tell them to do Stopping cascade \u00b6 1 Two facts: - 1) If G\\S contains a cluster of density >= (1-q) then S cannot cause a cascade 2) If S fails to create a cascade, then \u00b0 there is a cluster of density >= (1-q) in G\\S","title":"Lectyre6"},{"location":"MSBD5008/Lectyre6/#the-sir-model","text":"S: The number of susceptible individuals. When a susceptible and an infectious individual come into \"infectious contact\", the susceptible individual contracts the disease and transitions to the infectious compartment. I: The number of infectious individuals. These are individuals who have been infected and are capable of infecting susceptible individuals. R for the number of removed (and immune) or deceased individuals. These are individuals who have been infected and have either recovered from the disease and entered the removed compartment, or died. It is assumed that the number of deaths is negligible with respect to the total population. This compartment may also be called \"recovered\" or \"resistant\".","title":"The SIR model"},{"location":"MSBD5008/Lectyre6/#the-sis-model","text":"Some infections, for example, those from the common cold and influenza, do not confer any long-lasting immunity. Such infections do not give immunity upon recovery from infection, and individuals become susceptible again.","title":"The SIS model"},{"location":"MSBD5008/Lectyre6/#decision-based-models","text":"Payoffs: Utility of making a particular choice Signals Public information Private Information Scenario: Graph where everyone starts witn b. Small set S of early adopters of A Hard-wire S \u2014 they keep using A no matter what payoffs tell them to do","title":"Decision Based Models"},{"location":"MSBD5008/Lectyre6/#stopping-cascade","text":"1 Two facts: - 1) If G\\S contains a cluster of density >= (1-q) then S cannot cause a cascade 2) If S fails to create a cascade, then \u00b0 there is a cluster of density >= (1-q) in G\\S","title":"Stopping cascade"},{"location":"MSBD5008/homework/homework1/","text":"!pip install networkx Requirement already satisfied: networkx in /usr/local/lib/python3.6/dist-packages (2.5) Requirement already satisfied: decorator>=4.3.0 in /usr/local/lib/python3.6/dist-packages (from networkx) (4.4.2)","title":"Homework1"},{"location":"MSBD5012/homework2/","text":"Problem 1 \u00b6 \\[ P(B|A) = \\frac{p(A\\ and\\ B)}{P(A)} $$ $$p(A|B) = \\frac{P(A) \\times P(B|A) }{P(B)} \\] from sklearn.naive_bayes import GaussianNB import numpy as np x1 = [0, 0, 0, 0, 1, 1, 1, 1] x2 = [0, 0, 1, 1, 0, 0, 1, 1] y = [1, 1, 1, 1, 0, 0, 1, 0] X = np.column_stack((x1, x2)) X array([[0, 0], [0, 0], [0, 1], [0, 1], [1, 0], [1, 0], [1, 1], [1, 1]]) gnb = GaussianNB() gnb.fit(X, y) GaussianNB(priors=None, var_smoothing=1e-09) gnb.get_params() {'priors': None, 'var_smoothing': 1e-09} (4/5) * (2/5) 0.32000000000000006 Problem 2 \u00b6 w1 = np.array([[1, -1], [-1, 1]]) w2 = np.array([[-1, -1], [1, 1]]) w3 = np.array([[1], [1]]) x = np.array([1, 2]) import math from numpy import tanh def tanh_derivative ( x ): t = ( np . exp ( x ) - np . exp ( - x )) / ( np . exp ( x ) + np . exp ( - x )) dt = 1 - t ** 2 return dt def sigmoid ( X ): return 1 / ( 1 + np . exp ( - X )) def sigmoid_derivative ( x ): outcome = sigmoid ( x ) return outcome * ( 1 - outcome ) layer1 = x.dot(w1) layer1 = tanh(layer1) layer1 array([-0.76159416, 0.76159416]) layer2 = layer1.dot(w2) print(layer2) layer2 = tanh(layer2) layer2 [1.52318831 1.52318831] array([0.90925167, 0.90925167]) output = layer2.dot(w3) output *2 array([3.6370067]) e = sigmoid(output) e array([0.86038644]) backprop \\[error_{hidden} = w^T * error_{output}\\] b_layer2 = e * tanh_derivative(layer2) b_layer2 array([0.41340402, 0.41340402]) b_layer1_err = b_layer2.dot(w2.T) b_layer1 = b_layer1_err * tanh_derivative(layer1) b_layer1 array([-0.48601162, 0.48601162]) x[1] * b_layer1[0] 0.0 0.76 * b_layer2[1] 0.31418705778577294 w = np.array([[0.1, 0.5], [-0.3, 0.8]]) x = np.array([[0.2], [0.4]]) w.dot(x).dot(2) array([[0.44], [0.52]]) Feedforward Neural Network \u00b6 def relu(n): if n<0: return 0 else: return n def layer(m1, m2, w1, w2): z = m1.dot(w1) + m2.dot(w2) + b array = np.array([[1,1,1], [2, 2, 2]]) array[[0, 1], [1, 1]] - 1 array([0, 1]) def softmax_grad(softmax): s = softmax.reshape(-1,1) return np.diagflat(s) - np.dot(s, s.T) softmax_grad(np.array([[0.5, 0.5]])) array([[ 0.25, -0.25], [-0.25, 0.25]]) (array > 1) * np.array([[1, 1, 1], [1, 1, 1]]) array([[0, 0, 0], [1, 1, 1]]) array - 1 array([[0, 0, 0], [1, 1, 1]])","title":"Problem 1"},{"location":"MSBD5012/homework2/#problem-1","text":"\\[ P(B|A) = \\frac{p(A\\ and\\ B)}{P(A)} $$ $$p(A|B) = \\frac{P(A) \\times P(B|A) }{P(B)} \\] from sklearn.naive_bayes import GaussianNB import numpy as np x1 = [0, 0, 0, 0, 1, 1, 1, 1] x2 = [0, 0, 1, 1, 0, 0, 1, 1] y = [1, 1, 1, 1, 0, 0, 1, 0] X = np.column_stack((x1, x2)) X array([[0, 0], [0, 0], [0, 1], [0, 1], [1, 0], [1, 0], [1, 1], [1, 1]]) gnb = GaussianNB() gnb.fit(X, y) GaussianNB(priors=None, var_smoothing=1e-09) gnb.get_params() {'priors': None, 'var_smoothing': 1e-09} (4/5) * (2/5) 0.32000000000000006","title":"Problem 1"},{"location":"MSBD5012/homework2/#problem-2","text":"w1 = np.array([[1, -1], [-1, 1]]) w2 = np.array([[-1, -1], [1, 1]]) w3 = np.array([[1], [1]]) x = np.array([1, 2]) import math from numpy import tanh def tanh_derivative ( x ): t = ( np . exp ( x ) - np . exp ( - x )) / ( np . exp ( x ) + np . exp ( - x )) dt = 1 - t ** 2 return dt def sigmoid ( X ): return 1 / ( 1 + np . exp ( - X )) def sigmoid_derivative ( x ): outcome = sigmoid ( x ) return outcome * ( 1 - outcome ) layer1 = x.dot(w1) layer1 = tanh(layer1) layer1 array([-0.76159416, 0.76159416]) layer2 = layer1.dot(w2) print(layer2) layer2 = tanh(layer2) layer2 [1.52318831 1.52318831] array([0.90925167, 0.90925167]) output = layer2.dot(w3) output *2 array([3.6370067]) e = sigmoid(output) e array([0.86038644]) backprop \\[error_{hidden} = w^T * error_{output}\\] b_layer2 = e * tanh_derivative(layer2) b_layer2 array([0.41340402, 0.41340402]) b_layer1_err = b_layer2.dot(w2.T) b_layer1 = b_layer1_err * tanh_derivative(layer1) b_layer1 array([-0.48601162, 0.48601162]) x[1] * b_layer1[0] 0.0 0.76 * b_layer2[1] 0.31418705778577294 w = np.array([[0.1, 0.5], [-0.3, 0.8]]) x = np.array([[0.2], [0.4]]) w.dot(x).dot(2) array([[0.44], [0.52]])","title":"Problem 2"},{"location":"MSBD5012/homework2/#feedforward-neural-network","text":"def relu(n): if n<0: return 0 else: return n def layer(m1, m2, w1, w2): z = m1.dot(w1) + m2.dot(w2) + b array = np.array([[1,1,1], [2, 2, 2]]) array[[0, 1], [1, 1]] - 1 array([0, 1]) def softmax_grad(softmax): s = softmax.reshape(-1,1) return np.diagflat(s) - np.dot(s, s.T) softmax_grad(np.array([[0.5, 0.5]])) array([[ 0.25, -0.25], [-0.25, 0.25]]) (array > 1) * np.array([[1, 1, 1], [1, 1, 1]]) array([[0, 0, 0], [1, 1, 1]]) array - 1 array([[0, 0, 0], [1, 1, 1]])","title":"Feedforward Neural Network"},{"location":"MSBD5012/homeworks/Untitled0/","text":"","title":"Untitled0"},{"location":"MSBD5012/homeworks/hw3/","text":"def output_cnn(w1, f, p, s): \"\"\" w1: input size f: filter size p: number of zero padding s: the stride k: number of filters \"\"\" return (w1 - f + 2 * p) / s + 1 def number_of_parameter(f, d, k): return (f * f *d + 1) * k def number_of_flops(f, d, w2, h2, d2): return (f * f * d + 1) * w2 * h2 * d2 number_of_flops(3, 256, 25, 25, 384) 553200000","title":"Hw3"},{"location":"MSBD5012/homeworks/pa3/pa3%20keras/","text":"","title":"Pa3 keras"},{"location":"MSBD5012/homeworks/pa3/pa3/","text":"!pip install cloud-tpu-client==0.10 https://storage.googleapis.com/tpu-pytorch/wheels/torch_xla-1.6-cp36-cp36m-linux_x86_64.whl Requirement already satisfied: cloud-tpu-client==0.10 in /usr/local/lib/python3.6/dist-packages (0.10) Requirement already satisfied: torch-xla==1.6 from https://storage.googleapis.com/tpu-pytorch/wheels/torch_xla-1.6-cp36-cp36m-linux_x86_64.whl in /usr/local/lib/python3.6/dist-packages (1.6) Requirement already satisfied: oauth2client in /usr/local/lib/python3.6/dist-packages (from cloud-tpu-client==0.10) (4.1.3) Requirement already satisfied: google-api-python-client==1.8.0 in /usr/local/lib/python3.6/dist-packages (from cloud-tpu-client==0.10) (1.8.0) Requirement already satisfied: pyasn1-modules>=0.0.5 in /usr/local/lib/python3.6/dist-packages (from oauth2client->cloud-tpu-client==0.10) (0.2.8) Requirement already satisfied: httplib2>=0.9.1 in /usr/local/lib/python3.6/dist-packages (from oauth2client->cloud-tpu-client==0.10) (0.17.4) Requirement already satisfied: six>=1.6.1 in /usr/local/lib/python3.6/dist-packages (from oauth2client->cloud-tpu-client==0.10) (1.15.0) Requirement already satisfied: pyasn1>=0.1.7 in /usr/local/lib/python3.6/dist-packages (from oauth2client->cloud-tpu-client==0.10) (0.4.8) Requirement already satisfied: rsa>=3.1.4 in /usr/local/lib/python3.6/dist-packages (from oauth2client->cloud-tpu-client==0.10) (4.6) Requirement already satisfied: uritemplate<4dev,>=3.0.0 in /usr/local/lib/python3.6/dist-packages (from google-api-python-client==1.8.0->cloud-tpu-client==0.10) (3.0.1) Requirement already satisfied: google-auth-httplib2>=0.0.3 in /usr/local/lib/python3.6/dist-packages (from google-api-python-client==1.8.0->cloud-tpu-client==0.10) (0.0.4) Requirement already satisfied: google-api-core<2dev,>=1.13.0 in /usr/local/lib/python3.6/dist-packages (from google-api-python-client==1.8.0->cloud-tpu-client==0.10) (1.16.0) Requirement already satisfied: google-auth>=1.4.1 in /usr/local/lib/python3.6/dist-packages (from google-api-python-client==1.8.0->cloud-tpu-client==0.10) (1.17.2) Requirement already satisfied: requests<3.0.0dev,>=2.18.0 in /usr/local/lib/python3.6/dist-packages (from google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (2.23.0) Requirement already satisfied: pytz in /usr/local/lib/python3.6/dist-packages (from google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (2018.9) Requirement already satisfied: protobuf>=3.4.0 in /usr/local/lib/python3.6/dist-packages (from google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (3.12.4) Requirement already satisfied: googleapis-common-protos<2.0dev,>=1.6.0 in /usr/local/lib/python3.6/dist-packages (from google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (1.52.0) Requirement already satisfied: setuptools>=34.0.0 in /usr/local/lib/python3.6/dist-packages (from google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (50.3.2) Requirement already satisfied: cachetools<5.0,>=2.0.0 in /usr/local/lib/python3.6/dist-packages (from google-auth>=1.4.1->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (4.1.1) Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,<1.26,>=1.21.1 in /usr/local/lib/python3.6/dist-packages (from requests<3.0.0dev,>=2.18.0->google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (1.24.3) Requirement already satisfied: chardet<4,>=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests<3.0.0dev,>=2.18.0->google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (3.0.4) Requirement already satisfied: idna<3,>=2.5 in /usr/local/lib/python3.6/dist-packages (from requests<3.0.0dev,>=2.18.0->google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (2.10) Requirement already satisfied: certifi>=2017.4.17 in /usr/local/lib/python3.6/dist-packages (from requests<3.0.0dev,>=2.18.0->google-api-core<2dev,>=1.13.0->google-api-python-client==1.8.0->cloud-tpu-client==0.10) (2020.6.20) import torch import torchvision import torchvision.transforms as transforms # import torch_xla # import torch_xla.core.xla_model as xm # device = xm.xla_device() device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\") print(device) cuda:0 Train \u00b6 transform = transforms . Compose ( [ transforms . ToTensor (), transforms . Normalize (( 0.5 , 0.5 , 0.5 ), ( 0.5 , 0.5 , 0.5 ))]) trainset = torchvision . datasets . CIFAR10 ( root = './data' , train = True , download = True , transform = transform ) trainloader = torch . utils . data . DataLoader ( trainset , batch_size = 4 , shuffle = True , num_workers = 2 ) testset = torchvision . datasets . CIFAR10 ( root = './data' , train = False , download = True , transform = transform ) testloader = torch . utils . data . DataLoader ( testset , batch_size = 4 , shuffle = False , num_workers = 2 ) classes = ( 'plane' , 'car' , 'bird' , 'cat' , 'deer' , 'dog' , 'frog' , 'horse' , 'ship' , 'truck' ) Files already downloaded and verified Files already downloaded and verified #import matplotlib.pyplot as plt import numpy as np # get some random training images dataiter = iter ( trainloader ) images , labels = dataiter . next () images [ 0 ] . shape torch.Size([3, 32, 32]) import torch.nn as nn import torch.nn.functional as F class Inception ( nn . Module ): def __init__ ( self , in_planes , n1x1 , n3x3red , n3x3 , n5x5red , n5x5 , pool_planes ): super ( Inception , self ) . __init__ () # 1x1 conv branch self . b1 = nn . Sequential ( nn . Conv2d ( in_planes , n1x1 , kernel_size = 1 ), nn . BatchNorm2d ( n1x1 ), nn . ReLU ( True ), ) # 1x1 conv -> 3x3 conv branch self . b2 = nn . Sequential ( nn . Conv2d ( in_planes , n3x3red , kernel_size = 1 ), nn . BatchNorm2d ( n3x3red ), nn . ReLU ( True ), nn . Conv2d ( n3x3red , n3x3 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( n3x3 ), nn . ReLU ( True ), ) # 1x1 conv -> 5x5 conv branch self . b3 = nn . Sequential ( nn . Conv2d ( in_planes , n5x5red , kernel_size = 1 ), nn . BatchNorm2d ( n5x5red ), nn . ReLU ( True ), nn . Conv2d ( n5x5red , n5x5 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( n5x5 ), nn . ReLU ( True ), nn . Conv2d ( n5x5 , n5x5 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( n5x5 ), nn . ReLU ( True ), ) # 3x3 pool -> 1x1 conv branch self . b4 = nn . Sequential ( nn . MaxPool2d ( 3 , stride = 1 , padding = 1 ), nn . Conv2d ( in_planes , pool_planes , kernel_size = 1 ), nn . BatchNorm2d ( pool_planes ), nn . ReLU ( True ), ) def forward ( self , x ): y1 = self . b1 ( x ) y2 = self . b2 ( x ) y3 = self . b3 ( x ) y4 = self . b4 ( x ) return torch . cat ([ y1 , y2 , y3 , y4 ], 1 ) class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . pre_layers = nn . Sequential ( nn . Conv2d ( 3 , 192 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( 192 ), nn . ReLU ( True ), ) self . a3 = Inception ( 192 , 64 , 96 , 128 , 16 , 32 , 32 ) self . b3 = Inception ( 256 , 128 , 128 , 192 , 32 , 96 , 64 ) self . maxpool = nn . MaxPool2d ( 3 , stride = 2 , padding = 1 ) self . a4 = Inception ( 480 , 192 , 96 , 208 , 16 , 48 , 64 ) self . b4 = Inception ( 512 , 160 , 112 , 224 , 24 , 64 , 64 ) self . c4 = Inception ( 512 , 128 , 128 , 256 , 24 , 64 , 64 ) self . d4 = Inception ( 512 , 112 , 144 , 288 , 32 , 64 , 64 ) self . e4 = Inception ( 528 , 256 , 160 , 320 , 32 , 128 , 128 ) self . a5 = Inception ( 832 , 256 , 160 , 320 , 32 , 128 , 128 ) self . b5 = Inception ( 832 , 384 , 192 , 384 , 48 , 128 , 128 ) self . avgpool = nn . AvgPool2d ( 8 , stride = 1 ) self . linear = nn . Linear ( 1024 , 10 ) def forward ( self , x ): out = self . pre_layers ( x ) out = self . a3 ( out ) out = self . b3 ( out ) out = self . maxpool ( out ) out = self . a4 ( out ) out = self . b4 ( out ) out = self . c4 ( out ) out = self . d4 ( out ) out = self . e4 ( out ) out = self . maxpool ( out ) out = self . a5 ( out ) out = self . b5 ( out ) out = self . avgpool ( out ) out = out . view ( out . size ( 0 ), - 1 ) out = self . linear ( out ) return out net = Net () net . to ( device ) Net( (pre_layers): Sequential( (0): Conv2d(3, 192, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (a3): Inception( (b1): Sequential( (0): Conv2d(192, 64, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(192, 96, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(96, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(192, 16, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(16, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(192, 32, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (b3): Inception( (b1): Sequential( (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(128, 192, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(256, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (a4): Inception( (b1): Sequential( (0): Conv2d(480, 192, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(480, 96, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(96, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(480, 16, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(16, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(480, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (b4): Inception( (b1): Sequential( (0): Conv2d(512, 160, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(512, 112, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(112, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(112, 224, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(224, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(512, 24, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(24, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(512, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (c4): Inception( (b1): Sequential( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(512, 24, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(24, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(512, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (d4): Inception( (b1): Sequential( (0): Conv2d(512, 112, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(112, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(512, 144, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(144, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(144, 288, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(288, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(512, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(512, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (e4): Inception( (b1): Sequential( (0): Conv2d(528, 256, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(528, 160, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(160, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(528, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(528, 128, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (a5): Inception( (b1): Sequential( (0): Conv2d(832, 256, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(832, 160, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(160, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(832, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(832, 128, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (b5): Inception( (b1): Sequential( (0): Conv2d(832, 384, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(832, 192, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(192, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(832, 48, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(48, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(832, 128, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (avgpool): AvgPool2d(kernel_size=8, stride=1, padding=0) (linear): Linear(in_features=1024, out_features=10, bias=True) ) import torch.optim as optim criterion = nn . CrossEntropyLoss () optimizer = optim . RMSprop ( net . parameters (), lr = 0.001 ) from time import time start = time () for epoch in range ( 4 ): # loop over the dataset multiple times running_loss = 0.0 for i , data in enumerate ( trainloader , 0 ): # get the inputs; data is a list of [inputs, labels] inputs , labels = data inputs = inputs . to ( device ) labels = labels . to ( device ) # zero the parameter gradients optimizer . zero_grad () # forward + backward + optimize outputs = net ( inputs ) loss = criterion ( outputs , labels ) loss . backward () optimizer . step () # print statistics running_loss += loss . item () if i % 2000 == 1999 : # print every 2000 mini-batches print ( '[ %d , %5d ] loss: %.3f ' % ( epoch + 1 , i + 1 , running_loss / 2000 )) running_loss = 0.0 print ( f 'Finished Training. Time: {time() - start}' ) [1, 2000] loss: 2.149 [1, 4000] loss: 1.826 [1, 6000] loss: 1.675 [1, 8000] loss: 1.525 [1, 10000] loss: 1.423 [1, 12000] loss: 1.335 [2, 2000] loss: 1.225 [2, 4000] loss: 1.172 [2, 6000] loss: 1.131 [2, 8000] loss: 1.101 [2, 10000] loss: 1.041 [2, 12000] loss: 1.020 [3, 2000] loss: 0.932 [3, 4000] loss: 0.912 [3, 6000] loss: 0.917 [3, 8000] loss: 0.857 [3, 10000] loss: 0.843 [3, 12000] loss: 0.824 [4, 2000] loss: 0.758 [4, 4000] loss: 0.746 [4, 6000] loss: 0.745 [4, 8000] loss: 0.750 [4, 10000] loss: 0.712 [4, 12000] loss: 0.709 PATH = './cifar_net.pth' torch.save(net.state_dict(), PATH) dataiter = iter ( testloader ) images , labels = dataiter . next () print ( 'GroundTruth: ' , ' ' . join ( '%5s' % classes [ labels[j ] ] for j in range ( 4 ))) GroundTruth: cat ship ship plane Test \u00b6 net = Net () net . load_state_dict ( torch . load ( PATH )) outputs = net ( images ) correct = 0 total = 0 with torch . no_grad (): for data in testloader : images , labels = data outputs = net ( images ) _ , predicted = torch . max ( outputs . data , 1 ) total += labels . size ( 0 ) correct += ( predicted == labels ) . sum () . item () print ( 'Accuracy of the network on the 10000 test images: %d %% ' % ( 100 * correct / total )) Accuracy of the network on the 10000 test images: 28 %","title":"Pa3"},{"location":"MSBD5012/homeworks/pa3/pa3/#train","text":"transform = transforms . Compose ( [ transforms . ToTensor (), transforms . Normalize (( 0.5 , 0.5 , 0.5 ), ( 0.5 , 0.5 , 0.5 ))]) trainset = torchvision . datasets . CIFAR10 ( root = './data' , train = True , download = True , transform = transform ) trainloader = torch . utils . data . DataLoader ( trainset , batch_size = 4 , shuffle = True , num_workers = 2 ) testset = torchvision . datasets . CIFAR10 ( root = './data' , train = False , download = True , transform = transform ) testloader = torch . utils . data . DataLoader ( testset , batch_size = 4 , shuffle = False , num_workers = 2 ) classes = ( 'plane' , 'car' , 'bird' , 'cat' , 'deer' , 'dog' , 'frog' , 'horse' , 'ship' , 'truck' ) Files already downloaded and verified Files already downloaded and verified #import matplotlib.pyplot as plt import numpy as np # get some random training images dataiter = iter ( trainloader ) images , labels = dataiter . next () images [ 0 ] . shape torch.Size([3, 32, 32]) import torch.nn as nn import torch.nn.functional as F class Inception ( nn . Module ): def __init__ ( self , in_planes , n1x1 , n3x3red , n3x3 , n5x5red , n5x5 , pool_planes ): super ( Inception , self ) . __init__ () # 1x1 conv branch self . b1 = nn . Sequential ( nn . Conv2d ( in_planes , n1x1 , kernel_size = 1 ), nn . BatchNorm2d ( n1x1 ), nn . ReLU ( True ), ) # 1x1 conv -> 3x3 conv branch self . b2 = nn . Sequential ( nn . Conv2d ( in_planes , n3x3red , kernel_size = 1 ), nn . BatchNorm2d ( n3x3red ), nn . ReLU ( True ), nn . Conv2d ( n3x3red , n3x3 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( n3x3 ), nn . ReLU ( True ), ) # 1x1 conv -> 5x5 conv branch self . b3 = nn . Sequential ( nn . Conv2d ( in_planes , n5x5red , kernel_size = 1 ), nn . BatchNorm2d ( n5x5red ), nn . ReLU ( True ), nn . Conv2d ( n5x5red , n5x5 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( n5x5 ), nn . ReLU ( True ), nn . Conv2d ( n5x5 , n5x5 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( n5x5 ), nn . ReLU ( True ), ) # 3x3 pool -> 1x1 conv branch self . b4 = nn . Sequential ( nn . MaxPool2d ( 3 , stride = 1 , padding = 1 ), nn . Conv2d ( in_planes , pool_planes , kernel_size = 1 ), nn . BatchNorm2d ( pool_planes ), nn . ReLU ( True ), ) def forward ( self , x ): y1 = self . b1 ( x ) y2 = self . b2 ( x ) y3 = self . b3 ( x ) y4 = self . b4 ( x ) return torch . cat ([ y1 , y2 , y3 , y4 ], 1 ) class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . pre_layers = nn . Sequential ( nn . Conv2d ( 3 , 192 , kernel_size = 3 , padding = 1 ), nn . BatchNorm2d ( 192 ), nn . ReLU ( True ), ) self . a3 = Inception ( 192 , 64 , 96 , 128 , 16 , 32 , 32 ) self . b3 = Inception ( 256 , 128 , 128 , 192 , 32 , 96 , 64 ) self . maxpool = nn . MaxPool2d ( 3 , stride = 2 , padding = 1 ) self . a4 = Inception ( 480 , 192 , 96 , 208 , 16 , 48 , 64 ) self . b4 = Inception ( 512 , 160 , 112 , 224 , 24 , 64 , 64 ) self . c4 = Inception ( 512 , 128 , 128 , 256 , 24 , 64 , 64 ) self . d4 = Inception ( 512 , 112 , 144 , 288 , 32 , 64 , 64 ) self . e4 = Inception ( 528 , 256 , 160 , 320 , 32 , 128 , 128 ) self . a5 = Inception ( 832 , 256 , 160 , 320 , 32 , 128 , 128 ) self . b5 = Inception ( 832 , 384 , 192 , 384 , 48 , 128 , 128 ) self . avgpool = nn . AvgPool2d ( 8 , stride = 1 ) self . linear = nn . Linear ( 1024 , 10 ) def forward ( self , x ): out = self . pre_layers ( x ) out = self . a3 ( out ) out = self . b3 ( out ) out = self . maxpool ( out ) out = self . a4 ( out ) out = self . b4 ( out ) out = self . c4 ( out ) out = self . d4 ( out ) out = self . e4 ( out ) out = self . maxpool ( out ) out = self . a5 ( out ) out = self . b5 ( out ) out = self . avgpool ( out ) out = out . view ( out . size ( 0 ), - 1 ) out = self . linear ( out ) return out net = Net () net . to ( device ) Net( (pre_layers): Sequential( (0): Conv2d(3, 192, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (a3): Inception( (b1): Sequential( (0): Conv2d(192, 64, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(192, 96, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(96, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(192, 16, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(16, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(192, 32, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (b3): Inception( (b1): Sequential( (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(128, 192, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(256, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False) (a4): Inception( (b1): Sequential( (0): Conv2d(480, 192, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(480, 96, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(96, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(480, 16, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(16, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(480, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (b4): Inception( (b1): Sequential( (0): Conv2d(512, 160, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(512, 112, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(112, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(112, 224, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(224, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(512, 24, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(24, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(512, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (c4): Inception( (b1): Sequential( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(512, 24, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(24, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(512, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (d4): Inception( (b1): Sequential( (0): Conv2d(512, 112, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(112, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(512, 144, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(144, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(144, 288, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(288, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(512, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(512, 64, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (e4): Inception( (b1): Sequential( (0): Conv2d(528, 256, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(528, 160, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(160, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(528, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(528, 128, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (a5): Inception( (b1): Sequential( (0): Conv2d(832, 256, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(832, 160, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(160, 320, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(832, 32, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(32, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(832, 128, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (b5): Inception( (b1): Sequential( (0): Conv2d(832, 384, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) ) (b2): Sequential( (0): Conv2d(832, 192, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(192, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) ) (b3): Sequential( (0): Conv2d(832, 48, kernel_size=(1, 1), stride=(1, 1)) (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU(inplace=True) (3): Conv2d(48, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (5): ReLU(inplace=True) (6): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (8): ReLU(inplace=True) ) (b4): Sequential( (0): MaxPool2d(kernel_size=3, stride=1, padding=1, dilation=1, ceil_mode=False) (1): Conv2d(832, 128, kernel_size=(1, 1), stride=(1, 1)) (2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (3): ReLU(inplace=True) ) ) (avgpool): AvgPool2d(kernel_size=8, stride=1, padding=0) (linear): Linear(in_features=1024, out_features=10, bias=True) ) import torch.optim as optim criterion = nn . CrossEntropyLoss () optimizer = optim . RMSprop ( net . parameters (), lr = 0.001 ) from time import time start = time () for epoch in range ( 4 ): # loop over the dataset multiple times running_loss = 0.0 for i , data in enumerate ( trainloader , 0 ): # get the inputs; data is a list of [inputs, labels] inputs , labels = data inputs = inputs . to ( device ) labels = labels . to ( device ) # zero the parameter gradients optimizer . zero_grad () # forward + backward + optimize outputs = net ( inputs ) loss = criterion ( outputs , labels ) loss . backward () optimizer . step () # print statistics running_loss += loss . item () if i % 2000 == 1999 : # print every 2000 mini-batches print ( '[ %d , %5d ] loss: %.3f ' % ( epoch + 1 , i + 1 , running_loss / 2000 )) running_loss = 0.0 print ( f 'Finished Training. Time: {time() - start}' ) [1, 2000] loss: 2.149 [1, 4000] loss: 1.826 [1, 6000] loss: 1.675 [1, 8000] loss: 1.525 [1, 10000] loss: 1.423 [1, 12000] loss: 1.335 [2, 2000] loss: 1.225 [2, 4000] loss: 1.172 [2, 6000] loss: 1.131 [2, 8000] loss: 1.101 [2, 10000] loss: 1.041 [2, 12000] loss: 1.020 [3, 2000] loss: 0.932 [3, 4000] loss: 0.912 [3, 6000] loss: 0.917 [3, 8000] loss: 0.857 [3, 10000] loss: 0.843 [3, 12000] loss: 0.824 [4, 2000] loss: 0.758 [4, 4000] loss: 0.746 [4, 6000] loss: 0.745 [4, 8000] loss: 0.750 [4, 10000] loss: 0.712 [4, 12000] loss: 0.709 PATH = './cifar_net.pth' torch.save(net.state_dict(), PATH) dataiter = iter ( testloader ) images , labels = dataiter . next () print ( 'GroundTruth: ' , ' ' . join ( '%5s' % classes [ labels[j ] ] for j in range ( 4 ))) GroundTruth: cat ship ship plane","title":"Train"},{"location":"MSBD5012/homeworks/pa3/pa3/#test","text":"net = Net () net . load_state_dict ( torch . load ( PATH )) outputs = net ( images ) correct = 0 total = 0 with torch . no_grad (): for data in testloader : images , labels = data outputs = net ( images ) _ , predicted = torch . max ( outputs . data , 1 ) total += labels . size ( 0 ) correct += ( predicted == labels ) . sum () . item () print ( 'Accuracy of the network on the 10000 test images: %d %% ' % ( 100 * correct / total )) Accuracy of the network on the 10000 test images: 28 %","title":"Test"},{"location":"MSBD5012/homeworks/pa4/assignment4/","text":"import tensorflow as tf from os import listdir from os.path import isfile , join import matplotlib.pyplot as plt Use Pre-trained model \u00b6 # We will use google drive as dataset's folder IMAGE_PATH = \"/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images\" image_files = [join(IMAGE_PATH, f) for f in listdir(IMAGE_PATH) if isfile(join(IMAGE_PATH, f))] image_files ['/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/9.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/8.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/6.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/4.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/10.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/3.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/2.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/7.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/5.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/1.png'] # Helper function to preprocess the image so that it can be inputted in MobileNetV2 def preprocess ( image ): image = tf . cast ( image , tf . float32 ) image = image / 255 image = image / tf . math . reduce_max ( image ) image = tf . image . resize ( image , ( 224 , 224 )) image = image [ None , ...] return image # Helper function to extract labels from probability vector def get_imagenet_label ( probs ): return decode_predictions ( probs , top = 1 )[ 0 ][ 0 ] images = [] for i in image_files: image_raw = tf.io.read_file(i) image = tf.image.decode_image(image_raw,3) image = preprocess(image) images.append(image) plt.imshow(images[0][0]) <matplotlib.image.AxesImage at 0x7f36e1fe5390> Use pre-trained model \u00b6 pretrained_model = tf . keras . applications . MobileNetV2 ( include_top = True , weights = 'imagenet' ) # pretrained_model = tf . keras . applications . resnet50 . ResNet50 ( include_top = True , # weights = 'imagenet' ) # pretrained_model = tf . keras . applications . inception_v3 . InceptionV3 ( include_top = True , # weights = 'imagenet' ) # pretrained_model = tf . keras . applications . nasnet . NASNetMobile ( include_top = True , # weights = 'imagenet' ) pretrained_model . trainable = False # ImageNet labels # Decoder is the same for all pretrained imagenet models . decode_predictions = tf . keras . applications . mobilenet_v2 . decode_predictions results = [] confidences = [] probs = [] for i in images: image_probs = pretrained_model.predict(i) plt.figure() plt.imshow(i[0]) _, image_class, class_confidence = get_imagenet_label(image_probs) results.append(image_class) confidences.append(class_confidence * 100) probs.append(image_probs) plt.title('{} : {:.2f}% Confidence'.format(image_class, class_confidence*100)) plt.show() print(results) ['fireboat', 'pillow', 'zebra', 'hourglass', 'carousel', 'yurt', 'peacock', 'school_bus', 'water_tower', 'rapeseed'] plt.figure(num=None, figsize=(15, 8), dpi=80, facecolor='w', edgecolor='k') plt.bar(results, confidences) <BarContainer object of 10 artists> Adversarial Example \u00b6 loss_object = tf . keras . losses . CategoricalCrossentropy () def create_adversarial_pattern ( input_image , input_label ): with tf . GradientTape () as tape : tape . watch ( input_image ) prediction = pretrained_model ( input_image ) loss = loss_object ( input_label , prediction ) # Get the gradients of the loss w . r . t to the input image . gradient = tape . gradient ( loss , input_image ) # Get the sign of the gradients to create the perturbation signed_grad = tf . sign ( gradient ) return signed_grad , gradient # Get the input label of the image . labrador_retriever_index = 208 label = tf . one_hot ( labrador_retriever_index , image_probs . shape [ - 1 ]) label = tf . reshape ( label , ( 1 , image_probs . shape [ - 1 ])) perturbations , enhance = create_adversarial_pattern ( image , label ) plt . imshow ( perturbations [ 0 ]) Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). <matplotlib.image.AxesImage at 0x7f36d12e2668> def display_images ( image , description , index ): _ , label , confidence = get_imagenet_label ( pretrained_model . predict ( image )) plt . figure () plt . imshow ( image [ 0 ]) plt . title ( '{} \\n {} : {:.2f}% Confidence' . format ( description , label , confidence * 100 )) # plt . savefig ( f \"{index}-{description}.jpg\" ) plt . show () return label , confidence Display images \u00b6 epsilons = [ 0.1, 0.5 ] new_labels = [] new_confidences = [] for index , prob in enumerate ( probs ) : label = tf . one_hot ( labrador_retriever_index , prob . shape [ -1 ] ) label = tf . reshape ( label , ( 1 , prob . shape [ -1 ] )) perturbations , enhance = create_adversarial_pattern ( images [ index ] , label ) descriptions = [ ('Epsilon = {:0.3f}'.format(eps) if eps else 'Input') for eps in epsilons ] temp_confidence = [] temp_label = [] for i , eps in enumerate ( epsilons ) : adv_x = eps * perturbations + images [ index ] adv_x = tf . clip_by_value ( adv_x , 0 , 1 ) label , confidence = display_images ( adv_x , descriptions [ i ] , index ) temp_label . append ( label ) temp_confidence . append ( confidence * 100 ) new_labels . append ( temp_label ) new_confidences . append ( temp_confidence ) for i in range ( len ( results )) : print ( f \"Original label: {results[i]} {confidences[i]}\" ) print ( f \"New result 0.1: {new_labels[i][0]} {new_confidences[i][0]}\" ) print ( f \"New result 0.5: {new_labels[i][1]} {new_confidences[i][1]}\" ) Original label: fireboat 75.41137337684631 New result 0.1: paddlewheel 9.37194898724556 New result 0.5: dishrag 12.636317312717438 Original label: pillow 99.77816939353943 New result 0.1: pillow 98.71640205383301 New result 0.5: stole 20.831426978111267 Original label: zebra 98.61569404602051 New result 0.1: zebra 17.946863174438477 New result 0.5: prayer_rug 60.016703605651855 Original label: hourglass 97.2355604171753 New result 0.1: hourglass 95.40168046951294 New result 0.5: prayer_rug 42.5665944814682 Original label: carousel 97.31283783912659 New result 0.1: carousel 9.904991090297699 New result 0.5: prayer_rug 21.937750279903412 Original label: yurt 92.97380447387695 New result 0.1: yurt 77.24021673202515 New result 0.5: prayer_rug 40.29488265514374 Original label: peacock 99.12651181221008 New result 0.1: brain_coral 23.743192851543427 New result 0.5: wool 20.01730054616928 Original label: school_bus 98.6170768737793 New result 0.1: school_bus 37.114837765693665 New result 0.5: stole 21.422338485717773 Original label: water_tower 95.00780701637268 New result 0.1: water_tower 26.783213019371033 New result 0.5: prayer_rug 37.235623598098755 Original label: rapeseed 36.22219264507294 New result 0.1: bath_towel 18.45916509628296 New result 0.5: wool 18.765641748905182 plt.bar(range(10), confidences) <BarContainer object of 10 artists> !sudo apt-get install texlive-xetex texlive-fonts-recommended texlive-generic-recommended !jupyter nbconvert --to pdf assignment4.ipynb [NbConvertApp] Converting notebook assignment4.ipynb to pdf [NbConvertApp] Support files will be in assignment4_files/ [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Writing 42903 bytes to ./notebook.tex [NbConvertApp] Building PDF [NbConvertApp] Running xelatex 3 times: [u'xelatex', u'./notebook.tex', '-quiet'] Traceback (most recent call last): File \"/usr/local/bin/jupyter-nbconvert\", line 8, in <module> sys.exit(main()) File \"/usr/local/lib/python2.7/dist-packages/jupyter_core/application.py\", line 267, in launch_instance return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)","title":"Assignment4"},{"location":"MSBD5012/homeworks/pa4/assignment4/#use-pre-trained-model","text":"# We will use google drive as dataset's folder IMAGE_PATH = \"/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images\" image_files = [join(IMAGE_PATH, f) for f in listdir(IMAGE_PATH) if isfile(join(IMAGE_PATH, f))] image_files ['/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/9.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/8.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/6.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/4.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/10.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/3.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/2.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/7.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/5.png', '/content/drive/My Drive/courses/HKUST/MSBD5012/homeworks/pa4/images/1.png'] # Helper function to preprocess the image so that it can be inputted in MobileNetV2 def preprocess ( image ): image = tf . cast ( image , tf . float32 ) image = image / 255 image = image / tf . math . reduce_max ( image ) image = tf . image . resize ( image , ( 224 , 224 )) image = image [ None , ...] return image # Helper function to extract labels from probability vector def get_imagenet_label ( probs ): return decode_predictions ( probs , top = 1 )[ 0 ][ 0 ] images = [] for i in image_files: image_raw = tf.io.read_file(i) image = tf.image.decode_image(image_raw,3) image = preprocess(image) images.append(image) plt.imshow(images[0][0]) <matplotlib.image.AxesImage at 0x7f36e1fe5390>","title":"Use Pre-trained model"},{"location":"MSBD5012/homeworks/pa4/assignment4/#use-pre-trained-model_1","text":"pretrained_model = tf . keras . applications . MobileNetV2 ( include_top = True , weights = 'imagenet' ) # pretrained_model = tf . keras . applications . resnet50 . ResNet50 ( include_top = True , # weights = 'imagenet' ) # pretrained_model = tf . keras . applications . inception_v3 . InceptionV3 ( include_top = True , # weights = 'imagenet' ) # pretrained_model = tf . keras . applications . nasnet . NASNetMobile ( include_top = True , # weights = 'imagenet' ) pretrained_model . trainable = False # ImageNet labels # Decoder is the same for all pretrained imagenet models . decode_predictions = tf . keras . applications . mobilenet_v2 . decode_predictions results = [] confidences = [] probs = [] for i in images: image_probs = pretrained_model.predict(i) plt.figure() plt.imshow(i[0]) _, image_class, class_confidence = get_imagenet_label(image_probs) results.append(image_class) confidences.append(class_confidence * 100) probs.append(image_probs) plt.title('{} : {:.2f}% Confidence'.format(image_class, class_confidence*100)) plt.show() print(results) ['fireboat', 'pillow', 'zebra', 'hourglass', 'carousel', 'yurt', 'peacock', 'school_bus', 'water_tower', 'rapeseed'] plt.figure(num=None, figsize=(15, 8), dpi=80, facecolor='w', edgecolor='k') plt.bar(results, confidences) <BarContainer object of 10 artists>","title":"Use pre-trained model"},{"location":"MSBD5012/homeworks/pa4/assignment4/#adversarial-example","text":"loss_object = tf . keras . losses . CategoricalCrossentropy () def create_adversarial_pattern ( input_image , input_label ): with tf . GradientTape () as tape : tape . watch ( input_image ) prediction = pretrained_model ( input_image ) loss = loss_object ( input_label , prediction ) # Get the gradients of the loss w . r . t to the input image . gradient = tape . gradient ( loss , input_image ) # Get the sign of the gradients to create the perturbation signed_grad = tf . sign ( gradient ) return signed_grad , gradient # Get the input label of the image . labrador_retriever_index = 208 label = tf . one_hot ( labrador_retriever_index , image_probs . shape [ - 1 ]) label = tf . reshape ( label , ( 1 , image_probs . shape [ - 1 ])) perturbations , enhance = create_adversarial_pattern ( image , label ) plt . imshow ( perturbations [ 0 ]) Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). <matplotlib.image.AxesImage at 0x7f36d12e2668> def display_images ( image , description , index ): _ , label , confidence = get_imagenet_label ( pretrained_model . predict ( image )) plt . figure () plt . imshow ( image [ 0 ]) plt . title ( '{} \\n {} : {:.2f}% Confidence' . format ( description , label , confidence * 100 )) # plt . savefig ( f \"{index}-{description}.jpg\" ) plt . show () return label , confidence","title":"Adversarial Example"},{"location":"MSBD5012/homeworks/pa4/assignment4/#display-images","text":"epsilons = [ 0.1, 0.5 ] new_labels = [] new_confidences = [] for index , prob in enumerate ( probs ) : label = tf . one_hot ( labrador_retriever_index , prob . shape [ -1 ] ) label = tf . reshape ( label , ( 1 , prob . shape [ -1 ] )) perturbations , enhance = create_adversarial_pattern ( images [ index ] , label ) descriptions = [ ('Epsilon = {:0.3f}'.format(eps) if eps else 'Input') for eps in epsilons ] temp_confidence = [] temp_label = [] for i , eps in enumerate ( epsilons ) : adv_x = eps * perturbations + images [ index ] adv_x = tf . clip_by_value ( adv_x , 0 , 1 ) label , confidence = display_images ( adv_x , descriptions [ i ] , index ) temp_label . append ( label ) temp_confidence . append ( confidence * 100 ) new_labels . append ( temp_label ) new_confidences . append ( temp_confidence ) for i in range ( len ( results )) : print ( f \"Original label: {results[i]} {confidences[i]}\" ) print ( f \"New result 0.1: {new_labels[i][0]} {new_confidences[i][0]}\" ) print ( f \"New result 0.5: {new_labels[i][1]} {new_confidences[i][1]}\" ) Original label: fireboat 75.41137337684631 New result 0.1: paddlewheel 9.37194898724556 New result 0.5: dishrag 12.636317312717438 Original label: pillow 99.77816939353943 New result 0.1: pillow 98.71640205383301 New result 0.5: stole 20.831426978111267 Original label: zebra 98.61569404602051 New result 0.1: zebra 17.946863174438477 New result 0.5: prayer_rug 60.016703605651855 Original label: hourglass 97.2355604171753 New result 0.1: hourglass 95.40168046951294 New result 0.5: prayer_rug 42.5665944814682 Original label: carousel 97.31283783912659 New result 0.1: carousel 9.904991090297699 New result 0.5: prayer_rug 21.937750279903412 Original label: yurt 92.97380447387695 New result 0.1: yurt 77.24021673202515 New result 0.5: prayer_rug 40.29488265514374 Original label: peacock 99.12651181221008 New result 0.1: brain_coral 23.743192851543427 New result 0.5: wool 20.01730054616928 Original label: school_bus 98.6170768737793 New result 0.1: school_bus 37.114837765693665 New result 0.5: stole 21.422338485717773 Original label: water_tower 95.00780701637268 New result 0.1: water_tower 26.783213019371033 New result 0.5: prayer_rug 37.235623598098755 Original label: rapeseed 36.22219264507294 New result 0.1: bath_towel 18.45916509628296 New result 0.5: wool 18.765641748905182 plt.bar(range(10), confidences) <BarContainer object of 10 artists> !sudo apt-get install texlive-xetex texlive-fonts-recommended texlive-generic-recommended !jupyter nbconvert --to pdf assignment4.ipynb [NbConvertApp] Converting notebook assignment4.ipynb to pdf [NbConvertApp] Support files will be in assignment4_files/ [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Making directory ./assignment4_files [NbConvertApp] Writing 42903 bytes to ./notebook.tex [NbConvertApp] Building PDF [NbConvertApp] Running xelatex 3 times: [u'xelatex', u'./notebook.tex', '-quiet'] Traceback (most recent call last): File \"/usr/local/bin/jupyter-nbconvert\", line 8, in <module> sys.exit(main()) File \"/usr/local/lib/python2.7/dist-packages/jupyter_core/application.py\", line 267, in launch_instance return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)","title":"Display images"},{"location":"MSBD5012/lectures/Lecture%202/","text":"Divergence \u00b6 ML Setup \\(P(x)\\) -> generate -> Data -> learn \\(Q(x)\\) where Q should as close to P as possible. Entropy, cross entropy, and KL divergence \u00b6 Entropy \u00b6 \\[H(p) = -\\sum_{i}p_{i}log(p_i)\\] Cross Entropy \u00b6 p = true distribution q = predicted distribution \\[H(p, q) = -\\sum_ip_ilog(q_i)\\] Relative entropy or Kullback-Leibler divergence \u00b6 Meassure how much a distribution Q(X) differs from a \"True\" probability distribution P(X) K-L Divergence if Q from P is defined as follows: \\[ KL(P||Q) = \\sum_x{P(X)log(\\frac{P(X)}{Q(X)})} = -log\\sum_x{Q(X)}\\] Relationship between entropy, cross-entropy, and kl divergence $$cross-entropy = entropy + kl divergence $$ \\[or\\] \\[D_{kl}(p||q) = H(p, q) - H(p)\\] Minimize cross entropy = Maximizing log likelyhood Suppose we have likelihood of the training set is \\[\\sum_{i}(probability\\ of\\ i)^{number\\ of\\ occurrences\\ of\\ i} = \\sum_{i}q_i^{Np_i}\\] where N is number of conditionally independent samples in training set So the log-likelihood divided by N is \\[\\frac{1}{N}log\\sum_iq_i^{Np_i} = \\sum_ip_ilog(q_i) = -H(p, q)\\] Supervised learning \u00b6 Unsupervised learning \u00b6 Multual information \u00b6 H(x): Initial uncertainty about x H(X | Y): Expected uncertainty about x if y is tested Linear Regression \u00b6 \\[y = w_0 + w_1x_1\\] Least Square Regression \u00b6 import matplotlib.pyplot as plt import numpy as np x1 = [ 0 , 0 , 1 , 1 ] x2 = [ 0 , 1 , 0 , 1 ] y = [ 1 , 0 , 0 , 1 ] fig = plt . figure () ax = fig . add_subplot ( 111 , projection = '3d' ) ax . scatter ( x1 , x2 , y ) <mpl_toolkits.mplot3d.art3d.Path3DCollection at 0x7f2ec3a9ae80> using sklearn from sklearn import linear_model X = np . column_stack (( x1 , x2 )) lm = linear_model . LinearRegression () model = lm . fit ( X , y ) print ( model . coef_ ) print ( model . intercept_ ) print ( model . score ( X , y )) [0.00000000e+00 2.22044605e-16] 0.4999999999999999 0.0 using numpy \\( \\(A = (X^TX)^{-1}X^TY\\) \\) ones = [1 for i in range(len(x1))] X = np.column_stack((ones, x1, x2)) X_T = X.transpose() print(X) print(X_T) [[1 0 1] [1 0 1] [1 1 1] [1 1 0] [1 1 0]] [[1 1 1 1 1] [0 0 1 1 1] [1 1 1 0 0]] dot = np.dot(X_T, X) inverse = np.linalg.inv(dot) print(dot) print(inverse) [[5 3 3] [3 3 1] [3 1 3]] [[ 2. -1.5 -1.5] [-1.5 1.5 1. ] [-1.5 1. 1.5]] dot2 = np.dot(inverse, X_T).dot(y) dot2 array([ 2. , 1.5, -1.5]) Mean Square Error \u00b6 import numpy as np # Given values Y_true = [ 1 , 1 , 2 , 2 , 4 ] # Y_true = Y (original values) # Calculated values Y_pred = [ 0.6 , 1.29 , 1.99 , 2.69 , 3.4 ] # Y_pred = Y' # Mean Squared Error MSE = np . square ( np . subtract ( Y_true , Y_pred )) . mean () MSE 0.21606 Hypothesis space \u00b6 Is the set of functioins that it is allowed to select as being the solution. Thhe size of the hypothesis space is called the capacity of the model. For polynomial regression, the larger the d, the higher the model capacity. Higher model capacity implies better fit to training data. \\(S_1 = \\{y = w_0 + w_1x_1 | w_0, w_1 \\in R\\}\\) \\(S_2 = \\{y=w_0 + w_1x_1 + w_2x_1^2 + w_3x_1^3 | w_0, w_1, w_2, w_3 \\in R\\}\\) Generalization Error \u00b6 Model select: Validation Split training data into two parts. One part for training and second part for validation. This has to be randomly split. Regularization Regilarization \u00b6 ridge regression \u00b6 The larger the regularization constant \\(\\lambda\\) , the smaller the weights","title":"Lecture 2"},{"location":"MSBD5012/lectures/Lecture%202/#divergence","text":"ML Setup \\(P(x)\\) -> generate -> Data -> learn \\(Q(x)\\) where Q should as close to P as possible.","title":"Divergence"},{"location":"MSBD5012/lectures/Lecture%202/#entropy-cross-entropy-and-kl-divergence","text":"","title":"Entropy, cross entropy, and KL divergence"},{"location":"MSBD5012/lectures/Lecture%202/#entropy","text":"\\[H(p) = -\\sum_{i}p_{i}log(p_i)\\]","title":"Entropy"},{"location":"MSBD5012/lectures/Lecture%202/#cross-entropy","text":"p = true distribution q = predicted distribution \\[H(p, q) = -\\sum_ip_ilog(q_i)\\]","title":"Cross Entropy"},{"location":"MSBD5012/lectures/Lecture%202/#relative-entropy-or-kullback-leibler-divergence","text":"Meassure how much a distribution Q(X) differs from a \"True\" probability distribution P(X) K-L Divergence if Q from P is defined as follows: \\[ KL(P||Q) = \\sum_x{P(X)log(\\frac{P(X)}{Q(X)})} = -log\\sum_x{Q(X)}\\] Relationship between entropy, cross-entropy, and kl divergence $$cross-entropy = entropy + kl divergence $$ \\[or\\] \\[D_{kl}(p||q) = H(p, q) - H(p)\\] Minimize cross entropy = Maximizing log likelyhood Suppose we have likelihood of the training set is \\[\\sum_{i}(probability\\ of\\ i)^{number\\ of\\ occurrences\\ of\\ i} = \\sum_{i}q_i^{Np_i}\\] where N is number of conditionally independent samples in training set So the log-likelihood divided by N is \\[\\frac{1}{N}log\\sum_iq_i^{Np_i} = \\sum_ip_ilog(q_i) = -H(p, q)\\]","title":"Relative entropy or Kullback-Leibler divergence"},{"location":"MSBD5012/lectures/Lecture%202/#supervised-learning","text":"","title":"Supervised learning"},{"location":"MSBD5012/lectures/Lecture%202/#unsupervised-learning","text":"","title":"Unsupervised learning"},{"location":"MSBD5012/lectures/Lecture%202/#multual-information","text":"H(x): Initial uncertainty about x H(X | Y): Expected uncertainty about x if y is tested","title":"Multual information"},{"location":"MSBD5012/lectures/Lecture%202/#linear-regression","text":"\\[y = w_0 + w_1x_1\\]","title":"Linear Regression"},{"location":"MSBD5012/lectures/Lecture%202/#least-square-regression","text":"import matplotlib.pyplot as plt import numpy as np x1 = [ 0 , 0 , 1 , 1 ] x2 = [ 0 , 1 , 0 , 1 ] y = [ 1 , 0 , 0 , 1 ] fig = plt . figure () ax = fig . add_subplot ( 111 , projection = '3d' ) ax . scatter ( x1 , x2 , y ) <mpl_toolkits.mplot3d.art3d.Path3DCollection at 0x7f2ec3a9ae80> using sklearn from sklearn import linear_model X = np . column_stack (( x1 , x2 )) lm = linear_model . LinearRegression () model = lm . fit ( X , y ) print ( model . coef_ ) print ( model . intercept_ ) print ( model . score ( X , y )) [0.00000000e+00 2.22044605e-16] 0.4999999999999999 0.0 using numpy \\( \\(A = (X^TX)^{-1}X^TY\\) \\) ones = [1 for i in range(len(x1))] X = np.column_stack((ones, x1, x2)) X_T = X.transpose() print(X) print(X_T) [[1 0 1] [1 0 1] [1 1 1] [1 1 0] [1 1 0]] [[1 1 1 1 1] [0 0 1 1 1] [1 1 1 0 0]] dot = np.dot(X_T, X) inverse = np.linalg.inv(dot) print(dot) print(inverse) [[5 3 3] [3 3 1] [3 1 3]] [[ 2. -1.5 -1.5] [-1.5 1.5 1. ] [-1.5 1. 1.5]] dot2 = np.dot(inverse, X_T).dot(y) dot2 array([ 2. , 1.5, -1.5])","title":"Least Square Regression"},{"location":"MSBD5012/lectures/Lecture%202/#mean-square-error","text":"import numpy as np # Given values Y_true = [ 1 , 1 , 2 , 2 , 4 ] # Y_true = Y (original values) # Calculated values Y_pred = [ 0.6 , 1.29 , 1.99 , 2.69 , 3.4 ] # Y_pred = Y' # Mean Squared Error MSE = np . square ( np . subtract ( Y_true , Y_pred )) . mean () MSE 0.21606","title":"Mean Square Error"},{"location":"MSBD5012/lectures/Lecture%202/#hypothesis-space","text":"Is the set of functioins that it is allowed to select as being the solution. Thhe size of the hypothesis space is called the capacity of the model. For polynomial regression, the larger the d, the higher the model capacity. Higher model capacity implies better fit to training data. \\(S_1 = \\{y = w_0 + w_1x_1 | w_0, w_1 \\in R\\}\\) \\(S_2 = \\{y=w_0 + w_1x_1 + w_2x_1^2 + w_3x_1^3 | w_0, w_1, w_2, w_3 \\in R\\}\\)","title":"Hypothesis space"},{"location":"MSBD5012/lectures/Lecture%202/#generalization-error","text":"Model select: Validation Split training data into two parts. One part for training and second part for validation. This has to be randomly split. Regularization","title":"Generalization Error"},{"location":"MSBD5012/lectures/Lecture%202/#regilarization","text":"","title":"Regilarization"},{"location":"MSBD5012/lectures/Lecture%202/#ridge-regression","text":"The larger the regularization constant \\(\\lambda\\) , the smaller the weights","title":"ridge regression"},{"location":"MSBD5012/lectures/Lecture1/","text":"Likehood possibility \u00b6 \\[L(H|E) = P(E|H) \\] import matplotlib.pyplot as plt import numpy as np import scipy.stats mu = 3.0 sigma = 0.5 data = np . random . randn ( 100000 ) * sigma + mu hx , hy , _ = plt . hist ( data , bins = 50 , color = \"lightblue\" ) plt . ylim ( 0 . 0 , max ( hx ) + 0 . 05 ) plt . title ( r 'Normal distribution $\\mu_0 = 3$ and $\\sigma_0 = 0.5$' ) plt . grid () Calculate the log-likelihood \u00b6 scipy . stats . norm . pdf ( 6 , 2 . 0 , 1 . 0 ) print ( np . log ( scipy . stats . norm . pdf ( data , 2 . 0 , 1 . 0 )). sum () ) x = np . linspace ( - 10 , 10 , 1000 , endpoint = True ) y = [] for i in x : y . append ( np . log ( scipy . stats . norm . pdf ( data , i , 0 . 5 )). sum ()) plt . plot ( x , y ) plt . title ( r 'Log-Likelihood' ) plt . xlabel ( r '$\\mu$' ) plt . grid () -154314.14596206427 print('mean ---> ', np.mean(data)) print('std deviation ---> ', np.std(data)) mean ---> 2.999606326069087 std deviation ---> 0.4991923934863224 y_min = y . index ( max ( y )) print ( 'mean (from max log likelohood) ---> ' , x [ y_min ] ) mean (from max log likelohood) ---> 2.9929929929929937","title":"Lecture1"},{"location":"MSBD5012/lectures/Lecture1/#likehood-possibility","text":"\\[L(H|E) = P(E|H) \\] import matplotlib.pyplot as plt import numpy as np import scipy.stats mu = 3.0 sigma = 0.5 data = np . random . randn ( 100000 ) * sigma + mu hx , hy , _ = plt . hist ( data , bins = 50 , color = \"lightblue\" ) plt . ylim ( 0 . 0 , max ( hx ) + 0 . 05 ) plt . title ( r 'Normal distribution $\\mu_0 = 3$ and $\\sigma_0 = 0.5$' ) plt . grid ()","title":"Likehood possibility"},{"location":"MSBD5012/lectures/Lecture1/#calculate-the-log-likelihood","text":"scipy . stats . norm . pdf ( 6 , 2 . 0 , 1 . 0 ) print ( np . log ( scipy . stats . norm . pdf ( data , 2 . 0 , 1 . 0 )). sum () ) x = np . linspace ( - 10 , 10 , 1000 , endpoint = True ) y = [] for i in x : y . append ( np . log ( scipy . stats . norm . pdf ( data , i , 0 . 5 )). sum ()) plt . plot ( x , y ) plt . title ( r 'Log-Likelihood' ) plt . xlabel ( r '$\\mu$' ) plt . grid () -154314.14596206427 print('mean ---> ', np.mean(data)) print('std deviation ---> ', np.std(data)) mean ---> 2.999606326069087 std deviation ---> 0.4991923934863224 y_min = y . index ( max ( y )) print ( 'mean (from max log likelohood) ---> ' , x [ y_min ] ) mean (from max log likelohood) ---> 2.9929929929929937","title":"Calculate the log-likelihood"},{"location":"MSBD5012/lectures/Lecture3/","text":"Homework \u00b6 http://home.cse.ust.hk/~lzhang/teach/msbd5012/ Programming assignment (2020.10.10) Writting assignment (2020.10.03) Logestic regression \u00b6 Gradient Descent \u00b6 https://en.wikipedia.org/wiki/Gradient_descent#:~:text=Gradient%20descent%20is%20a%20first,function%20at%20the%20current%20point. \\[J'(w) = \\frac{dJ(w)}{dw} = lim_{e \\to 0}\\frac{J(w+e) - l(w)}{E}$$ $$J(w + e) = J(w) + eJ'(w)\\] from sklearn.linear_model import SGDRegressor import matplotlib.pyplot as plt import numpy as np x0 = np . array ([ 1 , 1 , 1 , 1 ]) x1 = np . array ([ 0 , 0 , 1 , 1 ]) x2 = np . array ([ 0 , 1 , 0 , 1 ]) x3 = x1 * x2 y = [ 1 , 0 , 0 , 1 ] colors = [ 'red' if i == 0 else 'blue' for i in y ] X = np . column_stack (( x1 , x2 )) # X = np.column_stack((x0, x1, x2, x3)) plt . scatter ( x1 , x2 , color = colors ) <matplotlib.collections.PathCollection at 0x7faa3604e198> import statsmodels.api as sm print ( X ) logit_model = sm . Logit ( y , X ) result = logit_model . fit () print ( result . summary2 ()) [[0 0] [0 1] [1 0] [1 1]] Optimization terminated successfully. Current function value: 0.693147 Iterations 1 Results: Logit ============================================================== Model: Logit Pseudo R-squared: 0.000 Dependent Variable: y AIC: 9.5452 Date: 2020-10-03 07:41 BIC: 8.3178 No. Observations: 4 Log-Likelihood: -2.7726 Df Model: 1 LL-Null: -2.7726 Df Residuals: 2 LLR p-value: 1.0000 Converged: 1.0000 Scale: 1.0000 No. Iterations: 1.0000 ----------------------------------------------------------------- Coef. Std.Err. z P>|z| [0.025 0.975] ----------------------------------------------------------------- x1 0.0000 1.6330 0.0000 1.0000 -3.2006 3.2006 x2 0.0000 1.6330 0.0000 1.0000 -3.2006 3.2006 ============================================================== predictions = model.predict(X) predictions array([0, 0, 0, 0]) Batch gradient descent \u00b6 https://machinelearningmastery.com/gentle-introduction-mini-batch-gradient-descent-configure-batch-size/#:~:text=Batch%20gradient%20descent%20is%20a,is%20called%20a%20training%20epoch. \\[w_j \\leftarrow w_j + \\alpha \\frac{1}{N}\\sum^{N}_{i=1}[y_i - \\sigma (w^Tx_i)]x_{i,j} \\] \\(y_i\\) : Observed output \\(\\sigma (w^Tx_i)\\) Predicted output \\(x_{i, j}\\) input import math import numpy as np def sigmoid ( x ): return 1 / ( 1 + math . exp ( - x )) a = 0.1 x_1 = [ 1, 1, 1, 1 ] x_2 = [ 0, 0, 1, 1 ] x_3 = [ 0, 1, 0 ,1 ] w_1 = - 2 w_2 = 1 w_3 = 1 y = [ 1, 0, 0, 1 ] def compute ( x , w_i ) : sum_i = 0 n = len ( x ) for i in range ( n ) : predicted_output = w_1 + w_2 * x_2 [ i ] + w_3 * x_3 [ i ] temp = ( y [ i ] - sigmoid ( predicted_output )) * x [ i ] sum_i += temp result = w_i + a * sum_i / n return result print ( compute ( x_1 , w_1 )) print ( compute ( x_2 , w_2 )) print ( compute ( x_3 , w_3 )) -1.9789271441190528 1.00577646446575 1.00577646446575 for i in range ( 100 ): w_1 = compute ( x_1 , w_1 ) w_2 = compute ( x_2 , w_2 ) w_3 = compute ( x_3 , w_3 ) err1 = w_1 + w_2 * x_2 [ 0 ] + w_3 * x_3 [ 0 ] err2 = w_1 + w_2 * x_2 [ 1 ] + w_3 * x_3 [ 1 ] err3 = w_1 + w_2 * x_2 [ 2 ] + w_3 * x_3 [ 2 ] err4 = w_1 + w_2 * x_2 [ 3 ] + w_3 * x_3 [ 3 ] ( err1 + err2 + err3 + err4 ) / 4 -0.07952691518172225 Stochastic Gradient descent \u00b6 https://en.wikipedia.org/wiki/Stochastic_gradient_descent Newton's method \u00b6 Adavantages \u00b6 If we only do the 1st order, then we will get overestimate, but with second order estimate, we will correct the overestimate. Softmax Regression \u00b6","title":"Lecture3"},{"location":"MSBD5012/lectures/Lecture3/#homework","text":"http://home.cse.ust.hk/~lzhang/teach/msbd5012/ Programming assignment (2020.10.10) Writting assignment (2020.10.03)","title":"Homework"},{"location":"MSBD5012/lectures/Lecture3/#logestic-regression","text":"","title":"Logestic regression"},{"location":"MSBD5012/lectures/Lecture3/#gradient-descent","text":"https://en.wikipedia.org/wiki/Gradient_descent#:~:text=Gradient%20descent%20is%20a%20first,function%20at%20the%20current%20point. \\[J'(w) = \\frac{dJ(w)}{dw} = lim_{e \\to 0}\\frac{J(w+e) - l(w)}{E}$$ $$J(w + e) = J(w) + eJ'(w)\\] from sklearn.linear_model import SGDRegressor import matplotlib.pyplot as plt import numpy as np x0 = np . array ([ 1 , 1 , 1 , 1 ]) x1 = np . array ([ 0 , 0 , 1 , 1 ]) x2 = np . array ([ 0 , 1 , 0 , 1 ]) x3 = x1 * x2 y = [ 1 , 0 , 0 , 1 ] colors = [ 'red' if i == 0 else 'blue' for i in y ] X = np . column_stack (( x1 , x2 )) # X = np.column_stack((x0, x1, x2, x3)) plt . scatter ( x1 , x2 , color = colors ) <matplotlib.collections.PathCollection at 0x7faa3604e198> import statsmodels.api as sm print ( X ) logit_model = sm . Logit ( y , X ) result = logit_model . fit () print ( result . summary2 ()) [[0 0] [0 1] [1 0] [1 1]] Optimization terminated successfully. Current function value: 0.693147 Iterations 1 Results: Logit ============================================================== Model: Logit Pseudo R-squared: 0.000 Dependent Variable: y AIC: 9.5452 Date: 2020-10-03 07:41 BIC: 8.3178 No. Observations: 4 Log-Likelihood: -2.7726 Df Model: 1 LL-Null: -2.7726 Df Residuals: 2 LLR p-value: 1.0000 Converged: 1.0000 Scale: 1.0000 No. Iterations: 1.0000 ----------------------------------------------------------------- Coef. Std.Err. z P>|z| [0.025 0.975] ----------------------------------------------------------------- x1 0.0000 1.6330 0.0000 1.0000 -3.2006 3.2006 x2 0.0000 1.6330 0.0000 1.0000 -3.2006 3.2006 ============================================================== predictions = model.predict(X) predictions array([0, 0, 0, 0])","title":"Gradient Descent"},{"location":"MSBD5012/lectures/Lecture3/#batch-gradient-descent","text":"https://machinelearningmastery.com/gentle-introduction-mini-batch-gradient-descent-configure-batch-size/#:~:text=Batch%20gradient%20descent%20is%20a,is%20called%20a%20training%20epoch. \\[w_j \\leftarrow w_j + \\alpha \\frac{1}{N}\\sum^{N}_{i=1}[y_i - \\sigma (w^Tx_i)]x_{i,j} \\] \\(y_i\\) : Observed output \\(\\sigma (w^Tx_i)\\) Predicted output \\(x_{i, j}\\) input import math import numpy as np def sigmoid ( x ): return 1 / ( 1 + math . exp ( - x )) a = 0.1 x_1 = [ 1, 1, 1, 1 ] x_2 = [ 0, 0, 1, 1 ] x_3 = [ 0, 1, 0 ,1 ] w_1 = - 2 w_2 = 1 w_3 = 1 y = [ 1, 0, 0, 1 ] def compute ( x , w_i ) : sum_i = 0 n = len ( x ) for i in range ( n ) : predicted_output = w_1 + w_2 * x_2 [ i ] + w_3 * x_3 [ i ] temp = ( y [ i ] - sigmoid ( predicted_output )) * x [ i ] sum_i += temp result = w_i + a * sum_i / n return result print ( compute ( x_1 , w_1 )) print ( compute ( x_2 , w_2 )) print ( compute ( x_3 , w_3 )) -1.9789271441190528 1.00577646446575 1.00577646446575 for i in range ( 100 ): w_1 = compute ( x_1 , w_1 ) w_2 = compute ( x_2 , w_2 ) w_3 = compute ( x_3 , w_3 ) err1 = w_1 + w_2 * x_2 [ 0 ] + w_3 * x_3 [ 0 ] err2 = w_1 + w_2 * x_2 [ 1 ] + w_3 * x_3 [ 1 ] err3 = w_1 + w_2 * x_2 [ 2 ] + w_3 * x_3 [ 2 ] err4 = w_1 + w_2 * x_2 [ 3 ] + w_3 * x_3 [ 3 ] ( err1 + err2 + err3 + err4 ) / 4 -0.07952691518172225","title":"Batch gradient descent"},{"location":"MSBD5012/lectures/Lecture3/#stochastic-gradient-descent","text":"https://en.wikipedia.org/wiki/Stochastic_gradient_descent","title":"Stochastic Gradient descent"},{"location":"MSBD5012/lectures/Lecture3/#newtons-method","text":"","title":"Newton's method"},{"location":"MSBD5012/lectures/Lecture3/#adavantages","text":"If we only do the 1st order, then we will get overestimate, but with second order estimate, we will correct the overestimate.","title":"Adavantages"},{"location":"MSBD5012/lectures/Lecture3/#softmax-regression","text":"","title":"Softmax Regression"},{"location":"MSBD5012/lectures/Lecture4/","text":"Empirecal Error \u00b6 Generalization Error \u00b6","title":"Lecture4"},{"location":"MSBD5012/lectures/Lecture4/#empirecal-error","text":"","title":"Empirecal Error"},{"location":"MSBD5012/lectures/Lecture4/#generalization-error","text":"","title":"Generalization Error"},{"location":"MSBD5012/lectures/Lecture8/","text":"","title":"Lecture8"}]}